[{"categories":["CCF CSP"],"content":"CCF CSP 201403 T1 相反数 ","date":"2019-07-30","objectID":"/posts/csp-201403-t1/:0:0","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T1 相反数","uri":"/posts/csp-201403-t1/"},{"categories":["CCF CSP"],"content":"题目 ","date":"2019-07-30","objectID":"/posts/csp-201403-t1/:1:0","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T1 相反数","uri":"/posts/csp-201403-t1/"},{"categories":["CCF CSP"],"content":"问题描述 有 N 个非零且各不相同的整数。请你编一个程序求出它们中有多少对相反数(a 和 -a 为一对相反数)。 ","date":"2019-07-30","objectID":"/posts/csp-201403-t1/:1:1","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T1 相反数","uri":"/posts/csp-201403-t1/"},{"categories":["CCF CSP"],"content":"输入格式 第一行包含一个正整数 N。(1 ≤ N ≤ 500)。 第二行为 N 个用单个空格隔开的非零整数,每个数的绝对值不超过1000,保证这些整数各不相同。 ","date":"2019-07-30","objectID":"/posts/csp-201403-t1/:1:2","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T1 相反数","uri":"/posts/csp-201403-t1/"},{"categories":["CCF CSP"],"content":"输出格式 只输出一个整数,即这 N 个数中包含多少对相反数。 ","date":"2019-07-30","objectID":"/posts/csp-201403-t1/:1:3","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T1 相反数","uri":"/posts/csp-201403-t1/"},{"categories":["CCF CSP"],"content":"样例输入 5 1 2 3 -1 -2 ","date":"2019-07-30","objectID":"/posts/csp-201403-t1/:1:4","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T1 相反数","uri":"/posts/csp-201403-t1/"},{"categories":["CCF CSP"],"content":"样例输出 2 ","date":"2019-07-30","objectID":"/posts/csp-201403-t1/:1:5","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T1 相反数","uri":"/posts/csp-201403-t1/"},{"categories":["CCF CSP"],"content":"时间限制 1.0s ","date":"2019-07-30","objectID":"/posts/csp-201403-t1/:1:6","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T1 相反数","uri":"/posts/csp-201403-t1/"},{"categories":["CCF CSP"],"content":"内存限制 256.0MB ","date":"2019-07-30","objectID":"/posts/csp-201403-t1/:1:7","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T1 相反数","uri":"/posts/csp-201403-t1/"},{"categories":["CCF CSP"],"content":"题解 用set存出现过的数，如果找到相反数答案+1。 ","date":"2019-07-30","objectID":"/posts/csp-201403-t1/:2:0","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T1 相反数","uri":"/posts/csp-201403-t1/"},{"categories":["CCF CSP"],"content":"代码 #include \u003ciostream\u003e#include \u003cset\u003e using namespace std; set\u003cint\u003e all; int main() { int n, x, ans = 0; all.clear(); cin \u003e\u003e n; while (n--) { cin \u003e\u003e x; all.insert(x); if (all.find(-x) != end(all)) ans++; } cout \u003c\u003c ans; return 0; } ","date":"2019-07-30","objectID":"/posts/csp-201403-t1/:3:0","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T1 相反数","uri":"/posts/csp-201403-t1/"},{"categories":["CCF CSP"],"content":"CCF CSP 201403 T2 窗口 ","date":"2019-07-30","objectID":"/posts/csp-201403-t2/:0:0","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T2 窗口","uri":"/posts/csp-201403-t2/"},{"categories":["CCF CSP"],"content":"题目 ","date":"2019-07-30","objectID":"/posts/csp-201403-t2/:1:0","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T2 窗口","uri":"/posts/csp-201403-t2/"},{"categories":["CCF CSP"],"content":"问题描述 在某图形操作系统中,有 N 个窗口,每个窗口都是一个两边与坐标轴分别平行的矩形区域。窗口的边界上的点也属于该窗口。窗口之间有层次的区别,在多于一个窗口重叠的区域里,只会显示位于顶层的窗口里的内容。 当你点击屏幕上一个点的时候,你就选择了处于被点击位置的最顶层窗口,并且这个窗口就会被移到所有窗口的最顶层,而剩余的窗口的层次顺序不变。如果你点击的位置不属于任何窗口,则系统会忽略你这次点击。 现在我们希望你写一个程序模拟点击窗口的过程。 ","date":"2019-07-30","objectID":"/posts/csp-201403-t2/:1:1","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T2 窗口","uri":"/posts/csp-201403-t2/"},{"categories":["CCF CSP"],"content":"输入格式 输入的第一行有两个正整数,即 N 和 M。(1 ≤ N ≤ 10,1 ≤ M ≤ 10) 接下来 N 行按照从最下层到最顶层的顺序给出 N 个窗口的位置。 每行包含四个非负整数 x1, y1, x2, y2,表示该窗口的一对顶点坐标分别为 (x1, y1) 和 (x2, y2)。保证 x1 \u003c x2,y1 2。 接下来 M 行每行包含两个非负整数 x, y,表示一次鼠标点击的坐标。 题目中涉及到的所有点和矩形的顶点的 x, y 坐标分别不超过2559和1439。 ","date":"2019-07-30","objectID":"/posts/csp-201403-t2/:1:2","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T2 窗口","uri":"/posts/csp-201403-t2/"},{"categories":["CCF CSP"],"content":"输出格式 输出包括 M 行,每一行表示一次鼠标点击的结果。如果该次鼠标点击选择了一个窗口,则输出这个窗口的编号(窗口按照输入中的顺序从 1 编号到 N);如果没有,则输出\"IGNORED”(不含双引号)。 ","date":"2019-07-30","objectID":"/posts/csp-201403-t2/:1:3","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T2 窗口","uri":"/posts/csp-201403-t2/"},{"categories":["CCF CSP"],"content":"样例输入 3 4 0 0 4 4 1 1 5 5 2 2 6 6 1 1 0 0 4 4 0 5 ","date":"2019-07-30","objectID":"/posts/csp-201403-t2/:1:4","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T2 窗口","uri":"/posts/csp-201403-t2/"},{"categories":["CCF CSP"],"content":"样例输出 2 1 1 IGNORED ","date":"2019-07-30","objectID":"/posts/csp-201403-t2/:1:5","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T2 窗口","uri":"/posts/csp-201403-t2/"},{"categories":["CCF CSP"],"content":"样例说明 第一次点击的位置同时属于第 1 和第 2 个窗口,但是由于第 2 个窗口在上面,它被选择并且被置于顶层。 第二次点击的位置只属于第 1 个窗口,因此该次点击选择了此窗口并将其置于顶层。现在的三个窗口的层次关系与初始状态恰好相反了。 第三次点击的位置同时属于三个窗口的范围,但是由于现在第 1 个窗口处于顶层,它被选择。 最后点击的 (0, 5) 不属于任何窗口。 ","date":"2019-07-30","objectID":"/posts/csp-201403-t2/:1:6","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T2 窗口","uri":"/posts/csp-201403-t2/"},{"categories":["CCF CSP"],"content":"时间限制 1.0s ","date":"2019-07-30","objectID":"/posts/csp-201403-t2/:1:7","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T2 窗口","uri":"/posts/csp-201403-t2/"},{"categories":["CCF CSP"],"content":"内存限制 256.0MB ","date":"2019-07-30","objectID":"/posts/csp-201403-t2/:1:8","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T2 窗口","uri":"/posts/csp-201403-t2/"},{"categories":["CCF CSP"],"content":"题解 简单模拟题，注意边界条件，将被点击的窗口移动到最前。 ","date":"2019-07-30","objectID":"/posts/csp-201403-t2/:2:0","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T2 窗口","uri":"/posts/csp-201403-t2/"},{"categories":["CCF CSP"],"content":"代码 #include \u003ciostream\u003e#include \u003cvector\u003e using namespace std; struct point { int x, y; point(int _x, int _y) { this-\u003ex = _x; this-\u003ey = _y; } }; struct rect { point s, t; int id = 0; rect(int _x1, int _y1, int _x2, int _y2, int _id) : s(_x1, _y1), t(_x2, _y2) { this-\u003eid = _id; } }; vector\u003crect\u003e windows; bool in(point p, rect r) { if (p.x \u003e= r.s.x \u0026\u0026 p.x \u003c= r.t.x \u0026\u0026 p.y \u003e= r.s.y \u0026\u0026 p.y \u003c= r.t.y) return true; return false; } int main() { int n, m; windows.clear(); cin \u003e\u003e n \u003e\u003e m; for (int i = 1; i \u003c= n; i++) { int x1, y1, x2, y2; cin \u003e\u003e x1 \u003e\u003e y1 \u003e\u003e x2 \u003e\u003e y2; windows.insert(windows.begin(), rect(x1, y1, x2, y2, i)); } while (m--) { int x, y; cin \u003e\u003e x \u003e\u003e y; point p = {x, y}; bool ignored = true; for (vector\u003crect\u003e::iterator it = windows.begin(); it != windows.end(); it++) { if (in(p, *it)) { cout \u003c\u003c it-\u003eid \u003c\u003c endl; ignored = false; rect window = *it; windows.erase(it); windows.insert(windows.begin(), window); break; } } if (ignored) cout \u003c\u003c \"IGNORED\" \u003c\u003c endl; } return 0; } ","date":"2019-07-30","objectID":"/posts/csp-201403-t2/:3:0","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T2 窗口","uri":"/posts/csp-201403-t2/"},{"categories":["CCF CSP"],"content":"CCF CSP 201403 T3 命令行选项 ","date":"2019-07-30","objectID":"/posts/csp-201403-t3/:0:0","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T3 命令行选项","uri":"/posts/csp-201403-t3/"},{"categories":["CCF CSP"],"content":"题目 ","date":"2019-07-30","objectID":"/posts/csp-201403-t3/:1:0","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T3 命令行选项","uri":"/posts/csp-201403-t3/"},{"categories":["CCF CSP"],"content":"问题描述 请你写一个命令行分析程序,用以分析给定的命令行里包含哪些选项。每个命令行由若干个字符串组成,它们之间恰好由一个空格分隔。这些字符串中的第一个为该命令行工具的名字,由小写字母组成,你的程序不用对它进行处理。在工具名字之后可能会包含若干选项,然后可能会包含一 些不是选项的参数。 选项有两类:带参数的选项和不带参数的选项。一个合法的无参数选项的形式是一个减号后面跟单个小写字母,如”-a” 或”-b”。而带参数选项则由两个由空格分隔的字符串构成,前者的格式要求与无参数选项相同,后者则是该选项的参数,是由小写字母,数字和减号组成的非空字符串。 该命令行工具的作者提供给你一个格式字符串以指定他的命令行工具需要接受哪些选项。这个字符串由若干小写字母和冒号组成,其中的每个小写字母表示一个该程序接受的选项。如果该小写字母后面紧跟了一个冒号,它就表示一个带参数的选项,否则则为不带参数的选项。例如, “ab:m:” 表示该程序接受三种选项,即”-a”(不带参数),\"-b”(带参数), 以及”-m”(带参数)。 命令行工具的作者准备了若干条命令行用以测试你的程序。对于每个命令行,你的工具应当一直向后分析。当你的工具遇到某个字符串既不是合法的选项,又不是某个合法选项的参数时,分析就停止。命令行剩余的未分析部分不构成该命令的选项,因此你的程序应当忽略它们。 ","date":"2019-07-30","objectID":"/posts/csp-201403-t3/:1:1","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T3 命令行选项","uri":"/posts/csp-201403-t3/"},{"categories":["CCF CSP"],"content":"输入格式 输入的第一行是一个格式字符串,它至少包含一个字符,且长度不超过 52。格式字符串只包含小写字母和冒号,保证每个小写字母至多出现一次,不会有两个相邻的冒号,也不会以冒号开头。 输入的第二行是一个正整数 N(1 ≤ N ≤ 20),表示你需要处理的命令行的个数。 接下来有 N 行,每行是一个待处理的命令行,它包括不超过 256 个字符。该命令行一定是若干个由单个空格分隔的字符串构成,每个字符串里只包含小写字母,数字和减号。 ","date":"2019-07-30","objectID":"/posts/csp-201403-t3/:1:2","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T3 命令行选项","uri":"/posts/csp-201403-t3/"},{"categories":["CCF CSP"],"content":"输出格式 输出有 N 行。其中第 i 行以\"Case i:” 开始,然后应当有恰好一个空格,然后应当按照字母升序输出该命令行中用到的所有选项的名称,对于带参数的选项,在输出它的名称之后还要输出它的参数。如果一个选项在命令行中出现了多次,只输出一次。如果一个带参数的选项在命令行中出 现了多次,只输出最后一次出现时所带的参数。 ","date":"2019-07-30","objectID":"/posts/csp-201403-t3/:1:3","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T3 命令行选项","uri":"/posts/csp-201403-t3/"},{"categories":["CCF CSP"],"content":"样例输入 albw:x 4 ls -a -l -a documents -b ls ls -w 10 -x -w 15 ls -a -b -c -d -e -l ","date":"2019-07-30","objectID":"/posts/csp-201403-t3/:1:4","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T3 命令行选项","uri":"/posts/csp-201403-t3/"},{"categories":["CCF CSP"],"content":"样例输出 Case 1: -a -l Case 2: Case 3: -w 15 -x Case 4: -a -b ","date":"2019-07-30","objectID":"/posts/csp-201403-t3/:1:5","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T3 命令行选项","uri":"/posts/csp-201403-t3/"},{"categories":["CCF CSP"],"content":"时间限制 1.0s ","date":"2019-07-30","objectID":"/posts/csp-201403-t3/:1:6","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T3 命令行选项","uri":"/posts/csp-201403-t3/"},{"categories":["CCF CSP"],"content":"内存限制 256.0MB ","date":"2019-07-30","objectID":"/posts/csp-201403-t3/:1:7","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T3 命令行选项","uri":"/posts/csp-201403-t3/"},{"categories":["CCF CSP"],"content":"题解 字符串题，据说CSP现场编译器还不支持C++11的正则表达式。 认真读题，冷静Debug。 ","date":"2019-07-30","objectID":"/posts/csp-201403-t3/:2:0","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T3 命令行选项","uri":"/posts/csp-201403-t3/"},{"categories":["CCF CSP"],"content":"代码 #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003cmap\u003e#include \u003ccstring\u003e#include \u003cvector\u003e using namespace std; map\u003cchar, bool\u003e hasV; map\u003cchar, string\u003e *mapper(string str) { map\u003cchar, string\u003e *paras = new map\u003cchar, string\u003e(); vector\u003cstring\u003e *cmd = new vector\u003cstring\u003e(); paras-\u003eclear(); cmd-\u003eclear(); int s, t; s = 0; while ((t = str.find(\"\", s)) != string::npos) { cmd-\u003epush_back(str.substr(s, t - s)); s = t + 1; } cmd-\u003epush_back(str.substr(s, str.length() - s)); for (int i = 1; i \u003c cmd-\u003esize(); i++) { string now = cmd-\u003eat(i); if (now.length() != 2 || now[0] != '-') break; char k = now[1]; if (hasV.find(k) == hasV.end()) break; if (!hasV[k]) { (*paras)[k] = \"\"; continue; } if (i == cmd-\u003esize() - 1) break; string v = cmd-\u003eat(i + 1); (*paras)[k] = v; i++; } return paras; } int main() { hasV.clear(); string pattern; int n; getline(cin, pattern); char last = 0; for (char c : pattern) { if (c == ':') { hasV[last] = true; continue; } hasV[c] = false; last = c; } cin \u003e\u003e n; getchar(); for (int k = 1; k \u003c= n; k++) { cout \u003c\u003c \"Case \" \u003c\u003c k \u003c\u003c \":\" \u003c\u003c \"\"; string str; getline(cin, str); map\u003cchar, string\u003e *paras = mapper(str); for (map\u003cchar, string\u003e::iterator it = paras-\u003ebegin(); it != paras-\u003eend(); it++) { cout \u003c\u003c '-' \u003c\u003c it-\u003efirst \u003c\u003c ''; if (it-\u003esecond != \"\") cout \u003c\u003c it-\u003esecond \u003c\u003c ''; } cout \u003c\u003c endl; } return 0; } ","date":"2019-07-30","objectID":"/posts/csp-201403-t3/:3:0","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T3 命令行选项","uri":"/posts/csp-201403-t3/"},{"categories":["CCF CSP"],"content":"CCF CSP 201403 T4 无线网络 ","date":"2019-07-30","objectID":"/posts/csp-201403-t4/:0:0","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T4 无线网络","uri":"/posts/csp-201403-t4/"},{"categories":["CCF CSP"],"content":"题目 ","date":"2019-07-30","objectID":"/posts/csp-201403-t4/:1:0","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T4 无线网络","uri":"/posts/csp-201403-t4/"},{"categories":["CCF CSP"],"content":"问题描述 目前在一个很大的平面房间里有 n 个无线路由器,每个无线路由器都固定在某个点上。任何两个无线路由器只要距离不超过 r 就能互相建立网络连接。 除此以外,另有 m 个可以摆放无线路由器的位置。你可以在这些位置中选择至多 k 个增设新的路由器。 你的目标是使得第 1 个路由器和第 2 个路由器之间的网络连接经过尽量少的中转路由器。请问在最优方案下中转路由器的最少个数是多少? ","date":"2019-07-30","objectID":"/posts/csp-201403-t4/:1:1","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T4 无线网络","uri":"/posts/csp-201403-t4/"},{"categories":["CCF CSP"],"content":"输入格式 第一行包含四个正整数 n,m,k,r。(2 ≤ n ≤ 100,1 ≤ k ≤ m ≤ 100, 1 ≤ r ≤ 108)。 接下来 n 行,每行包含两个整数 xi 和 yi,表示一个已经放置好的无线 路由器在 (xi, yi) 点处。输入数据保证第 1 和第 2 个路由器在仅有这 n 个路由器的情况下已经可以互相连接(经过一系列的中转路由器)。 接下来 m 行,每行包含两个整数 xi 和 yi,表示 (xi, yi) 点处可以增设 一个路由器。 输入中所有的坐标的绝对值不超过 108,保证输入中的坐标各不相同。 ","date":"2019-07-30","objectID":"/posts/csp-201403-t4/:1:2","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T4 无线网络","uri":"/posts/csp-201403-t4/"},{"categories":["CCF CSP"],"content":"输出格式 输出只有一个数,即在指定的位置中增设 k 个路由器后,从第 1 个路 由器到第 2 个路由器最少经过的中转路由器的个数。 ","date":"2019-07-30","objectID":"/posts/csp-201403-t4/:1:3","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T4 无线网络","uri":"/posts/csp-201403-t4/"},{"categories":["CCF CSP"],"content":"样例输入 5 3 1 3 0 0 5 5 0 3 0 5 3 5 3 3 4 4 3 0 ","date":"2019-07-30","objectID":"/posts/csp-201403-t4/:1:4","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T4 无线网络","uri":"/posts/csp-201403-t4/"},{"categories":["CCF CSP"],"content":"样例输出 2 ","date":"2019-07-30","objectID":"/posts/csp-201403-t4/:1:5","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T4 无线网络","uri":"/posts/csp-201403-t4/"},{"categories":["CCF CSP"],"content":"时间限制 1.0s ","date":"2019-07-30","objectID":"/posts/csp-201403-t4/:1:6","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T4 无线网络","uri":"/posts/csp-201403-t4/"},{"categories":["CCF CSP"],"content":"内存限制 256.0MB ","date":"2019-07-30","objectID":"/posts/csp-201403-t4/:1:7","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T4 无线网络","uri":"/posts/csp-201403-t4/"},{"categories":["CCF CSP"],"content":"题解 这道题是一道限制经过某类点最大次数的最短路问题,这类问题可以通过二维距离解决。由于图的边权均为1，因此直接使用二维距离BFS即可，如dis[i][j]表示从0号路由器到i号路由器，在新增了j个路由器时的最少总路由器数。 之前在网上查看大多数的题解都是直接在一维的距离上使用BFS，由于这道题数据比较弱，可以AC，但是实际上这样如下问题: 当在BFS过程中，已经过的新增路由器已经耗尽了可以添加的最大次数，而未经过的路由器中存在添加后可以缩短的路径长度大于已添加某一新增路由器能够缩短的路径长度。由于dis只有一维，BFS对每个路由器只会遍历一次，因此不会跳过在前面的新增路由器，导致得到的答案大于最优解。 如果上面这段话比较绕嘴，可以通过如下的一组数据来演示： 13 2 1 1 0 0 6 0 0 1 1 1 2 1 2 0 3 0 4 0 4 1 4 2 5 2 6 2 6 1 1 0 5 0 将这组数据绘制成图，虚线表示0号和1号路由器，白点表示已有的路由器，黑点表示可以添加的路由器。可以互相连通的路由器中间使用直线连接： 样例数据\" 样例数据 在这组数据中，k=1。如果dis只有一维，在遇到第一个黑点时会经过，这样到黑点后的第一个路由器的距离为2，我们设这个点为x点。当绕过黑点的路径到达该点时，该点已被遍历，不会再次遍历。而到达第二个黑点时，由于第一个黑点已经耗尽了增加路由器的次数，因此只能绕更远的路。最终导致得到的答案为9。其路径如下图所示； 错误路径\" 错误路径 而使用二维距离时，dis[i][j]表示从0号路由器到i号路由器，在新增了j个路由器时的最少总路由器数。因此对于我们命名为x的点时，有两种不同的状态：dis[x][1]=2与dis[x][0]=4。这样，可以通过dis[x][0]=4继续遍历，经过第二个黑点找到到达终点的真正最短路7。其路径如下图所示： 正确路径\" 正确路径 通过比较网上一维BFS的结果与二维BFS在这组数据下得到的结果，证明这个问题确实存在。 ","date":"2019-07-30","objectID":"/posts/csp-201403-t4/:2:0","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T4 无线网络","uri":"/posts/csp-201403-t4/"},{"categories":["CCF CSP"],"content":"代码 这里为了复习最短路的写法，使用SPFA的方式写的。 #include \u003ciostream\u003e#include \u003ccstring\u003e#include \u003cvector\u003e#include \u003cqueue\u003e #define ll long long#define N 205 using namespace std; struct point { ll x, y; }; queue\u003cint\u003e q; bool inq[N]; vector\u003cint\u003e nxt[N]; point pos[N]; // index \u003c n : 已有 int dis[N][N]; bool reach(point a, point b, ll r) { if ((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y) \u003c= r * r) return true; return false; } int main() { int n, m, k; ll r; cin \u003e\u003e n \u003e\u003e m \u003e\u003e k \u003e\u003e r; memset(inq, 0, sizeof(inq)); memset(dis, 0x7f, sizeof(dis)); while (!q.empty()) q.pop(); for (int i = 0; i \u003c n + m; i++) cin \u003e\u003e pos[i].x \u003e\u003e pos[i].y; for (int i = 0; i \u003c n + m; i++) for (int j = 0; j \u003c n + m; j++) if (reach(pos[i], pos[j], r)) nxt[i].push_back(j); q.push(0); inq[0] = true; dis[0][0] = 0; while (!q.empty()) { int s = q.front(); q.pop(); inq[s] = false; if (s == 1) break; for (int c = 0; c \u003c= k; c++) for (vector\u003cint\u003e::iterator it = nxt[s].begin(); it != nxt[s].end(); it++) { int t = *it; int ct = (s \u003c n) ? (c) : (c + 1); if (ct \u003e k) continue; if (dis[t][ct] \u003e dis[s][c] + 1) { dis[t][ct] = dis[s][c] + 1; if (!inq[t]) { q.push(t); inq[t] = true; } } } } int ans = m + n + 1; for (int c = 0; c \u003c= k; c++) if (dis[1][c] \u003c ans) ans = dis[1][c]; cout \u003c\u003c ans - 1; return 0; } ","date":"2019-07-30","objectID":"/posts/csp-201403-t4/:3:0","tags":["CCF CSP","algorithm"],"title":"CSP 201403 T4 无线网络","uri":"/posts/csp-201403-t4/"},{"categories":["docker","LDAP","registry"],"content":"带LDAP认证与WebUI的Docker私有仓库搭建 ","date":"2019-07-22","objectID":"/posts/private-docker-registry-with-ldap-auth-and-webui/:0:0","tags":null,"title":"带LDAP认证与WebUI的Docker私有仓库搭建","uri":"/posts/private-docker-registry-with-ldap-auth-and-webui/"},{"categories":["docker","LDAP","registry"],"content":"1. 获取docker仓库并运行 docker pull registry:latest docker run -d -p 127.0.0.1:5000:5000 --name registry-localhost -v /opt/docker-registry:/var/lib/registry --restart=always registry:latest ","date":"2019-07-22","objectID":"/posts/private-docker-registry-with-ldap-auth-and-webui/:1:0","tags":null,"title":"带LDAP认证与WebUI的Docker私有仓库搭建","uri":"/posts/private-docker-registry-with-ldap-auth-and-webui/"},{"categories":["docker","LDAP","registry"],"content":"2. 获取WebUI并运行 Docker Registry的WebUI有很多，这里使用konradkleine/docker-registry-frontend:v2 docker pull konradkleine/docker-registry-frontend:v2 docker run -d -e ENV_DOCKER_REGISTRY_HOST=barricade.ivic.org.cn -e ENV_DOCKER_REGISTRY_PORT=80 -p 127.0.0.1:8081:80 --restart=always --name frontend-localhost konradkleine/docker-registry-frontend:v2 ","date":"2019-07-22","objectID":"/posts/private-docker-registry-with-ldap-auth-and-webui/:2:0","tags":null,"title":"带LDAP认证与WebUI的Docker私有仓库搭建","uri":"/posts/private-docker-registry-with-ldap-auth-and-webui/"},{"categories":["docker","LDAP","registry"],"content":"3. 搭建带有LDAP认证的Nginx服务 预编译版本的nginx默认不带有LDAP认证所需模块，需要手动编译nginx与拓展模块。 ","date":"2019-07-22","objectID":"/posts/private-docker-registry-with-ldap-auth-and-webui/:3:0","tags":null,"title":"带LDAP认证与WebUI的Docker私有仓库搭建","uri":"/posts/private-docker-registry-with-ldap-auth-and-webui/"},{"categories":["docker","LDAP","registry"],"content":"3.1 编译安装nginx依赖 # 编译安装pcre wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.42.tar.gz tar -zxf pcre-8.42.tar.gz cd pcre-8.42 ./configure make sudo make install # 编译安装zlib wget http://zlib.net/zlib-1.2.11.tar.gz tar -zxf zlib-1.2.11.tar.gz cd zlib-1.2.11 ./configure make sudo make install # 如果没有安装openssl，请自行安装openssl # ... # 安装ldap依赖库 # Ubuntu/Debian sudo apt install libldap2-dev # CentOS yum install openldap-devel ","date":"2019-07-22","objectID":"/posts/private-docker-registry-with-ldap-auth-and-webui/:3:1","tags":null,"title":"带LDAP认证与WebUI的Docker私有仓库搭建","uri":"/posts/private-docker-registry-with-ldap-auth-and-webui/"},{"categories":["docker","LDAP","registry"],"content":"3.2 下载nginx与拓展模块源码 # 下载解压nginx源码 wget https://nginx.org/download/nginx-1.15.11.tar.gz tar zxf nginx-1.15.11.tar.gz # 下载解压nginx-auth-ldap wget https://github.com/kvspb/nginx-auth-ldap/archive/master.zip unzip master.zip ","date":"2019-07-22","objectID":"/posts/private-docker-registry-with-ldap-auth-and-webui/:3:2","tags":null,"title":"带LDAP认证与WebUI的Docker私有仓库搭建","uri":"/posts/private-docker-registry-with-ldap-auth-and-webui/"},{"categories":["docker","LDAP","registry"],"content":"3.3 编译安装nginx # 编译nginx cd nginx-1.15.11 ./configure --sbin-path=/usr/local/nginx/nginx --conf-path=/etc/nginx/nginx.conf --pid-path=/usr/local/nginx/nginx.pid --with-pcre=../pcre-8.42 --with-zlib=../zlib-1.2.11 --with-http_ssl_module --with-stream --with-mail=dynamic --add-module=~/nginx-auth-ldap-master make sudo make install # 创建软连接 sudo ln -s /usr/local/nginx/nginx /usr/bin/nginx ","date":"2019-07-22","objectID":"/posts/private-docker-registry-with-ldap-auth-and-webui/:3:3","tags":null,"title":"带LDAP认证与WebUI的Docker私有仓库搭建","uri":"/posts/private-docker-registry-with-ldap-auth-and-webui/"},{"categories":["docker","LDAP","registry"],"content":"3.4 编写nginx配置文件/etc/nginx/nginx.conf 注意替换ldap_server中参数，同时注意其他位置关于host与port的配置 worker_processes 1; events { worker_connections 1024; } http { upstream docker-registry { server localhost:5000; } ldap_server ldapserver { url ldap://\u003cLDAP-SERVER-HOST\u003e:\u003cLDAP-SERVER-PORT\u003e/\u003cOU=...,DC=...\u003e?samaccountname?sub?(objectClass=user); binddn \u003cBINDDN\u003e; binddn_passwd \u003cPASSWORD-FOR-BINDDN\u003e; group_attribute uniquemember; group_attribute_is_dn on; } server { listen 80; error_log /var/log/nginx/error.log debug; access_log /var/log/nginx/access.log; client_max_body_size 0; chunked_transfer_encoding on; location / { return 301 http://barricade.ivic.org.cn:80/v2; } location /v2/ { # Do not allow connections from docker 1.5 and earlier # docker pre-1.6.0 did not properly set the user agent on ping, catch \"Go *\" user agents if ($http_user_agent ~ \"^(docker\\/1\\.(3|4|5(?!\\.[0-9]-dev))|Go ).*$\" ) { return 404; } auth_ldap \"Forbidden\"; auth_ldap_servers ldapserver; add_header 'Docker-Distribution-Api-Version' 'registry/2.0' always; proxy_pass http://docker-registry; proxy_set_header Host $http_host; # required for docker client's sake proxy_set_header X-Real-IP $remote_addr; # pass on real client's IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_read_timeout 900; } } server { listen 8080; error_log /var/log/nginx/error.log debug; access_log /var/log/nginx/access.log; client_max_body_size 0; chunked_transfer_encoding on; location / { auth_ldap \"Forbidden\"; auth_ldap_servers ldapserver; proxy_pass http://localhost:8081; } } } ","date":"2019-07-22","objectID":"/posts/private-docker-registry-with-ldap-auth-and-webui/:3:4","tags":null,"title":"带LDAP认证与WebUI的Docker私有仓库搭建","uri":"/posts/private-docker-registry-with-ldap-auth-and-webui/"},{"categories":["docker","LDAP","registry"],"content":"3.5 配置Nginx服务管理与自启动 编写服务/lib/systemd/system/nginx.service [Unit] Description=nginx - high performance web server Documentation=http://nginx.org/en/docs/ After=network.target [Service] Type=forking ExecStartPre=/usr/local/nginx/nginx -t -c /etc/nginx/nginx.conf ExecStart=/usr/local/nginx/nginx -c /etc/nginx/nginx.conf ExecReload=/usr/local/nginx/nginx -s reload ExecStop=/usr/local/nginx/nginx -s quit PrivateTmp=true [Install] WantedBy=multi-user.target 启动Nginx服务并设置自启动 sudo systemctl daemon-reload sudo systemctl start nginx sudo systemctl status nginx sudo systemctl enable nginx ","date":"2019-07-22","objectID":"/posts/private-docker-registry-with-ldap-auth-and-webui/:3:5","tags":null,"title":"带LDAP认证与WebUI的Docker私有仓库搭建","uri":"/posts/private-docker-registry-with-ldap-auth-and-webui/"},{"categories":["docker","LDAP","registry"],"content":"4. 客户端配置 docker仅支持https的仓库，在内网中无需使用https，因此需要将仓库加入docker的白名单。 ","date":"2019-07-22","objectID":"/posts/private-docker-registry-with-ldap-auth-and-webui/:4:0","tags":null,"title":"带LDAP认证与WebUI的Docker私有仓库搭建","uri":"/posts/private-docker-registry-with-ldap-auth-and-webui/"},{"categories":["docker","LDAP","registry"],"content":"4.1 编写/etc/docker/daemon.json { \"insecure-registries\":[ \"barricade.ivic.org.cn\" ] } ","date":"2019-07-22","objectID":"/posts/private-docker-registry-with-ldap-auth-and-webui/:4:1","tags":null,"title":"带LDAP认证与WebUI的Docker私有仓库搭建","uri":"/posts/private-docker-registry-with-ldap-auth-and-webui/"},{"categories":["docker","LDAP","registry"],"content":"4.2 重启docker服务 sudo systemctl restart docker ","date":"2019-07-22","objectID":"/posts/private-docker-registry-with-ldap-auth-and-webui/:4:2","tags":null,"title":"带LDAP认证与WebUI的Docker私有仓库搭建","uri":"/posts/private-docker-registry-with-ldap-auth-and-webui/"},{"categories":["CCF CSP"],"content":"CCF CSP 201312 T1 出现次数最多的数 ","date":"2019-07-10","objectID":"/posts/csp-201312-t1/:0:0","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T1 出现次数最多的数","uri":"/posts/csp-201312-t1/"},{"categories":["CCF CSP"],"content":"题目 ","date":"2019-07-10","objectID":"/posts/csp-201312-t1/:1:0","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T1 出现次数最多的数","uri":"/posts/csp-201312-t1/"},{"categories":["CCF CSP"],"content":"问题描述 给定n个正整数，找出它们中出现次数最多的数。如果这样的数有多个，请输出其中最小的一个。 ","date":"2019-07-10","objectID":"/posts/csp-201312-t1/:1:1","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T1 出现次数最多的数","uri":"/posts/csp-201312-t1/"},{"categories":["CCF CSP"],"content":"输入格式 输入的第一行只有一个正整数n(1 ≤ n ≤ 1000)，表示数字的个数。 输入的第二行有n个整数s1, s2, …, sn (1 ≤ si ≤ 10000, 1 ≤ i ≤ n)。相邻的数用空格分隔。 ","date":"2019-07-10","objectID":"/posts/csp-201312-t1/:1:2","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T1 出现次数最多的数","uri":"/posts/csp-201312-t1/"},{"categories":["CCF CSP"],"content":"输出格式 输出这n个次数中出现次数最多的数。如果这样的数有多个，输出其中最小的一个。 ","date":"2019-07-10","objectID":"/posts/csp-201312-t1/:1:3","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T1 出现次数最多的数","uri":"/posts/csp-201312-t1/"},{"categories":["CCF CSP"],"content":"样例输入 6 10 1 10 20 30 20 ","date":"2019-07-10","objectID":"/posts/csp-201312-t1/:1:4","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T1 出现次数最多的数","uri":"/posts/csp-201312-t1/"},{"categories":["CCF CSP"],"content":"样例输出 10 ","date":"2019-07-10","objectID":"/posts/csp-201312-t1/:1:5","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T1 出现次数最多的数","uri":"/posts/csp-201312-t1/"},{"categories":["CCF CSP"],"content":"时间限制 1.0s ","date":"2019-07-10","objectID":"/posts/csp-201312-t1/:1:6","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T1 出现次数最多的数","uri":"/posts/csp-201312-t1/"},{"categories":["CCF CSP"],"content":"内存限制 256.0MB ","date":"2019-07-10","objectID":"/posts/csp-201312-t1/:1:7","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T1 出现次数最多的数","uri":"/posts/csp-201312-t1/"},{"categories":["CCF CSP"],"content":"题解 使用map统计数字出现次数。遍历map找到出现次数最多的最小的数即可。 ","date":"2019-07-10","objectID":"/posts/csp-201312-t1/:2:0","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T1 出现次数最多的数","uri":"/posts/csp-201312-t1/"},{"categories":["CCF CSP"],"content":"代码 #include \u003ciostream\u003e#include \u003cmap\u003e using namespace std; map\u003cint, int\u003e cnt; int main() { int n; int maxcnt = 0, ans = 0; cnt.clear(); cin \u003e\u003e n; while (n--) { int x; cin \u003e\u003e x; cnt[x]++; for (map\u003cint, int\u003e::iterator it = cnt.begin(); it != cnt.end(); it++) { if (it-\u003esecond \u003e maxcnt) { maxcnt = it-\u003esecond; ans = it-\u003efirst; } else if (it-\u003esecond == maxcnt \u0026\u0026 it-\u003efirst \u003c ans) { ans = it-\u003efirst; } } } cout \u003c\u003c ans; return 0; } ","date":"2019-07-10","objectID":"/posts/csp-201312-t1/:3:0","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T1 出现次数最多的数","uri":"/posts/csp-201312-t1/"},{"categories":["CCF CSP"],"content":"CCF CSP 201312 T2 ISBN号码 ","date":"2019-07-10","objectID":"/posts/csp-201312-t2/:0:0","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T2 ISBN号码","uri":"/posts/csp-201312-t2/"},{"categories":["CCF CSP"],"content":"题目 ","date":"2019-07-10","objectID":"/posts/csp-201312-t2/:1:0","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T2 ISBN号码","uri":"/posts/csp-201312-t2/"},{"categories":["CCF CSP"],"content":"问题描述 每一本正式出版的图书都有一个ISBN号码与之对应，ISBN码包括9位数字、1位识别码和3位分隔符，其规定格式如“x-xxx-xxxxx-x”，其中符号“-”是分隔符（键盘上的减号），最后一位是识别码，例如0-670-82162-4就是一个标准的ISBN码。ISBN码的首位数字表示书籍的出版语言，例如0代表英语；第一个分隔符“-”之后的三位数字代表出版社，例如670代表维京出版社；第二个分隔之后的五位数字代表该书在出版社的编号；最后一位为识别码。 识别码的计算方法如下： 首位数字乘以1加上次位数字乘以2……以此类推，用所得的结果mod 11，所得的余数即为识别码，如果余数为10，则识别码为大写字母X。例如ISBN号码0-670-82162-4中的识别码4是这样得到的：对067082162这9个数字，从左至右，分别乘以1，2，…，9，再求和，即0×1+6×2+……+2×9=158，然后取158 mod 11的结果4作为识别码。 编写程序判断输入的ISBN号码中识别码是否正确，如果正确，则仅输出“Right”；如果错误，则输出是正确的ISBN号码。 ","date":"2019-07-10","objectID":"/posts/csp-201312-t2/:1:1","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T2 ISBN号码","uri":"/posts/csp-201312-t2/"},{"categories":["CCF CSP"],"content":"输入格式 输入只有一行，是一个字符序列，表示一本书的ISBN号码（保证输入符合ISBN号码的格式要求）。 ","date":"2019-07-10","objectID":"/posts/csp-201312-t2/:1:2","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T2 ISBN号码","uri":"/posts/csp-201312-t2/"},{"categories":["CCF CSP"],"content":"输出格式 输出一行，假如输入的ISBN号码的识别码正确，那么输出“Right”，否则，按照规定的格式，输出正确的ISBN号码（包括分隔符“-”）。 ","date":"2019-07-10","objectID":"/posts/csp-201312-t2/:1:3","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T2 ISBN号码","uri":"/posts/csp-201312-t2/"},{"categories":["CCF CSP"],"content":"样例输入 0-670-82162-4 ","date":"2019-07-10","objectID":"/posts/csp-201312-t2/:1:4","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T2 ISBN号码","uri":"/posts/csp-201312-t2/"},{"categories":["CCF CSP"],"content":"样例输出 Right ","date":"2019-07-10","objectID":"/posts/csp-201312-t2/:1:5","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T2 ISBN号码","uri":"/posts/csp-201312-t2/"},{"categories":["CCF CSP"],"content":"样例输入 0-670-82162-0 ","date":"2019-07-10","objectID":"/posts/csp-201312-t2/:1:6","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T2 ISBN号码","uri":"/posts/csp-201312-t2/"},{"categories":["CCF CSP"],"content":"样例输出 0-670-82162-4 ","date":"2019-07-10","objectID":"/posts/csp-201312-t2/:1:7","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T2 ISBN号码","uri":"/posts/csp-201312-t2/"},{"categories":["CCF CSP"],"content":"时间限制 1.0s ","date":"2019-07-10","objectID":"/posts/csp-201312-t2/:1:8","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T2 ISBN号码","uri":"/posts/csp-201312-t2/"},{"categories":["CCF CSP"],"content":"内存限制 256.0MB ","date":"2019-07-10","objectID":"/posts/csp-201312-t2/:1:9","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T2 ISBN号码","uri":"/posts/csp-201312-t2/"},{"categories":["CCF CSP"],"content":"题解 遍历输入的字符串进行处理即可。 ","date":"2019-07-10","objectID":"/posts/csp-201312-t2/:2:0","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T2 ISBN号码","uri":"/posts/csp-201312-t2/"},{"categories":["CCF CSP"],"content":"代码 #include \u003ciostream\u003e#include \u003cstring\u003e using namespace std; int main() { string isbn; cin \u003e\u003e isbn; int sum = 0; int i = 0; for (char c : isbn) { if (c == '-') continue; i++; if (i == 10) { if ((sum \u003c 10 \u0026\u0026 c - '0' == sum) || (sum == 10 \u0026\u0026 c == 'X')) { cout \u003c\u003c \"Right\"; break; } cout \u003c\u003c isbn.substr(0, 12); if (sum \u003c 10) cout \u003c\u003c sum; else cout \u003c\u003c \"X\"; break; } sum += (c - '0') * i; sum %= 11; } return 0; } ","date":"2019-07-10","objectID":"/posts/csp-201312-t2/:3:0","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T2 ISBN号码","uri":"/posts/csp-201312-t2/"},{"categories":["CCF CSP"],"content":"CCF CSP 201312 T3 最大的矩形 ","date":"2019-07-10","objectID":"/posts/csp-201312-t3/:0:0","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T3 最大的矩形","uri":"/posts/csp-201312-t3/"},{"categories":["CCF CSP"],"content":"题目 ","date":"2019-07-10","objectID":"/posts/csp-201312-t3/:1:0","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T3 最大的矩形","uri":"/posts/csp-201312-t3/"},{"categories":["CCF CSP"],"content":"问题描述 在横轴上放了n个相邻的矩形，每个矩形的宽度是1，而第i（1 ≤ i ≤ n）个矩形的高度是hi。这n个矩形构成了一个直方图。例如，下图中六个矩形的高度就分别是3, 1, 6, 5, 2, 3。 样例\" 样例 请找出能放在给定直方图里面积最大的矩形，它的边要与坐标轴平行。对于上面给出的例子，最大矩形如下图所示的阴影部分，面积是10。 样例\" 样例 ","date":"2019-07-10","objectID":"/posts/csp-201312-t3/:1:1","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T3 最大的矩形","uri":"/posts/csp-201312-t3/"},{"categories":["CCF CSP"],"content":"输入格式 第一行包含一个整数n，即矩形的数量(1 ≤ n ≤ 1000)。 第二行包含n 个整数h1, h2, … , hn，相邻的数之间由空格分隔。(1 ≤ hi ≤ 10000)。hi是第i个矩形的高度。 ","date":"2019-07-10","objectID":"/posts/csp-201312-t3/:1:2","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T3 最大的矩形","uri":"/posts/csp-201312-t3/"},{"categories":["CCF CSP"],"content":"输出格式 输出一行，包含一个整数，即给定直方图内的最大矩形的面积。 ","date":"2019-07-10","objectID":"/posts/csp-201312-t3/:1:3","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T3 最大的矩形","uri":"/posts/csp-201312-t3/"},{"categories":["CCF CSP"],"content":"样例输入 6 3 1 6 5 2 3 ","date":"2019-07-10","objectID":"/posts/csp-201312-t3/:1:4","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T3 最大的矩形","uri":"/posts/csp-201312-t3/"},{"categories":["CCF CSP"],"content":"样例输出 10 ","date":"2019-07-10","objectID":"/posts/csp-201312-t3/:1:5","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T3 最大的矩形","uri":"/posts/csp-201312-t3/"},{"categories":["CCF CSP"],"content":"时间限制 1.0s ","date":"2019-07-10","objectID":"/posts/csp-201312-t3/:1:6","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T3 最大的矩形","uri":"/posts/csp-201312-t3/"},{"categories":["CCF CSP"],"content":"内存限制 256.0MB ","date":"2019-07-10","objectID":"/posts/csp-201312-t3/:1:7","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T3 最大的矩形","uri":"/posts/csp-201312-t3/"},{"categories":["CCF CSP"],"content":"题解 动态规划题。 定义f[i][j]为以第i个矩形为左边界、第j个矩形为右边界的最大矩形面积。显然，当左右边界确定时，最大矩形面积由从左边界到右边界中最低的矩形高度决定。若定义minh[i][j]为左边界到右边界中最低的矩形高度，则有f[i][j] = minh[i][j] * (j-i+1)。因此此题只需要统计举行高度h[i]在任意区间的最小值。 数组任意区间最小值有很多方法统计，对于静态的值我们可以直接使用动态规划的方法在$O(n^2)$的时间复杂度内统计，根据本题的数据规模与时间限制来看是可以接受的。 $$\\text{minh}[i][j]=\\begin{cases} \\text{h}[i] \u0026 \\text{if }i=j \\\\ \\min(\\text{minh}[i][j-1],\\text{h}[j]) \u0026 \\text{if }i\\lt j \\end{cases}$$ 根据动态转移方程可以看出我们可以在读入的同时求解，只需要扫描一次，降低常数。 ","date":"2019-07-10","objectID":"/posts/csp-201312-t3/:2:0","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T3 最大的矩形","uri":"/posts/csp-201312-t3/"},{"categories":["CCF CSP"],"content":"代码 #include \u003ciostream\u003e#include \u003ccstring\u003e #define N 1050 using namespace std; int h[N]; int minh[N][N]; int main() { memset(minh, 0x7f, sizeof(minh)); int n, ans = 0; cin \u003e\u003e n; for (int j = 0; j \u003c n; j++) { cin \u003e\u003e h[j]; minh[j][j] = h[j]; if (minh[j][j] \u003e ans) ans = minh[j][j]; for (int i = 0; i \u003c j; i++) { minh[i][j] = min(minh[i][j-1], h[j]); if (minh[i][j] * (j - i + 1) \u003e ans) ans = minh[i][j] * (j - i + 1); } } cout \u003c\u003c ans; return 0; } ","date":"2019-07-10","objectID":"/posts/csp-201312-t3/:3:0","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T3 最大的矩形","uri":"/posts/csp-201312-t3/"},{"categories":["CCF CSP"],"content":"CCF CSP 201312 T4 有趣的数 ","date":"2019-07-10","objectID":"/posts/csp-201312-t4/:0:0","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T4 有趣的数","uri":"/posts/csp-201312-t4/"},{"categories":["CCF CSP"],"content":"题目 ","date":"2019-07-10","objectID":"/posts/csp-201312-t4/:1:0","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T4 有趣的数","uri":"/posts/csp-201312-t4/"},{"categories":["CCF CSP"],"content":"问题描述 我们把一个数称为有趣的，当且仅当： 它的数字只包含0, 1, 2, 3，且这四个数字都出现过至少一次。 所有的0都出现在所有的1之前，而所有的2都出现在所有的3之前。 最高位数字不为0。 因此，符合我们定义的最小的有趣的数是2013。除此以外，4位的有趣的数还有两个：2031和2301。 请计算恰好有n位的有趣的数的个数。由于答案可能非常大，只需要输出答案除以1000000007的余数。 ","date":"2019-07-10","objectID":"/posts/csp-201312-t4/:1:1","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T4 有趣的数","uri":"/posts/csp-201312-t4/"},{"categories":["CCF CSP"],"content":"输入格式 输入只有一行，包括恰好一个正整数n (4 ≤ n ≤ 1000)。 ","date":"2019-07-10","objectID":"/posts/csp-201312-t4/:1:2","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T4 有趣的数","uri":"/posts/csp-201312-t4/"},{"categories":["CCF CSP"],"content":"输出格式 输出只有一行，包括恰好n 位的整数中有趣的数的个数除以1000000007的余数。 ","date":"2019-07-10","objectID":"/posts/csp-201312-t4/:1:3","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T4 有趣的数","uri":"/posts/csp-201312-t4/"},{"categories":["CCF CSP"],"content":"样例输入 4 ","date":"2019-07-10","objectID":"/posts/csp-201312-t4/:1:4","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T4 有趣的数","uri":"/posts/csp-201312-t4/"},{"categories":["CCF CSP"],"content":"样例输出 3 ","date":"2019-07-10","objectID":"/posts/csp-201312-t4/:1:5","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T4 有趣的数","uri":"/posts/csp-201312-t4/"},{"categories":["CCF CSP"],"content":"时间限制 1.0s ","date":"2019-07-10","objectID":"/posts/csp-201312-t4/:1:6","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T4 有趣的数","uri":"/posts/csp-201312-t4/"},{"categories":["CCF CSP"],"content":"内存限制 256.0MB ","date":"2019-07-10","objectID":"/posts/csp-201312-t4/:1:7","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T4 有趣的数","uri":"/posts/csp-201312-t4/"},{"categories":["CCF CSP"],"content":"题解 递推问题。 首先观察规则，我们可以总结出如下的规则： 首位必须为2； 所有0都在任意1前； 所有2都在任意3前。 0、1、2、3必须出现至少一次。 在计算时，我们其实只需要考虑前三条规则。 我们设f[i][b0][b1][b2][b3]为长度为i的、满足规则123的有趣的数的个数，其中b0、b1、b2、b3表示0、1、2、3是否在这个数中出现。 例如，“满足规则123的、0、1、2、3都出现的、长度为4的有趣的数的个数为3”可表示为f[4][1][1][1][1]=3。 考虑规则123，动态转移方程可表示为： f[i][0][0][1][0] = 1; f[i][1][0][1][0] = f[i - 1][1][0][1][0] * 2 + f[i - 1][0][0][1][0]; f[i][1][1][1][0] = f[i - 1][1][1][1][0] * 2 + f[i - 1][1][0][1][0]; f[i][0][0][1][1] = f[i - 1][0][0][1][1] + f[i - 1][0][0][1][0]; f[i][1][0][1][1] = f[i - 1][1][0][1][1] * 2 + f[i - 1][0][0][1][1] + f[i - 1][1][0][1][0]; f[i][1][1][1][1] = f[i - 1][1][1][1][1] * 2 + f[i - 1][1][0][1][1] + f[i - 1][1][1][1][0]; 其余均为0。 可见，其实有效的状态只有6种，可以按照6中状态进行压缩，由于( 我懒 )本题空间足够，也可以不压缩。 最后输出的答案即f[n][1][1][1][1]。 ","date":"2019-07-10","objectID":"/posts/csp-201312-t4/:2:0","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T4 有趣的数","uri":"/posts/csp-201312-t4/"},{"categories":["CCF CSP"],"content":"代码 #include \u003ciostream\u003e#include \u003ccstring\u003e #define N 1050#define ll long long using namespace std; ll f[N][2][2][2][2]; ll m = 1000000007; int main() { int n; memset(f, 0, sizeof(f)); cin \u003e\u003e n; f[1][0][0][1][0] = 1; for (int i = 2; i \u003c= n; i++) { f[i][0][0][1][0] = 1; f[i][1][0][1][0] = ((f[i - 1][1][0][1][0] * 2) % m + f[i - 1][0][0][1][0]) % m; f[i][1][1][1][0] = ((f[i - 1][1][1][1][0] * 2) % m + f[i - 1][1][0][1][0]) % m; f[i][0][0][1][1] = (f[i - 1][0][0][1][1] + f[i - 1][0][0][1][0]) % m; f[i][1][0][1][1] = ((f[i - 1][1][0][1][1] * 2) % m + f[i - 1][0][0][1][1] + f[i - 1][1][0][1][0]) % m; f[i][1][1][1][1] = ((f[i - 1][1][1][1][1] * 2) % m + f[i - 1][1][0][1][1] + f[i - 1][1][1][1][0]) % m; } cout \u003c\u003c f[n][1][1][1][1]; return 0; } ","date":"2019-07-10","objectID":"/posts/csp-201312-t4/:3:0","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T4 有趣的数","uri":"/posts/csp-201312-t4/"},{"categories":["CCF CSP"],"content":"CCF CSP 201312 T5 I'm stuck! ","date":"2019-07-10","objectID":"/posts/csp-201312-t5/:0:0","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T5 I'm stuck!","uri":"/posts/csp-201312-t5/"},{"categories":["CCF CSP"],"content":"题目 ","date":"2019-07-10","objectID":"/posts/csp-201312-t5/:1:0","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T5 I'm stuck!","uri":"/posts/csp-201312-t5/"},{"categories":["CCF CSP"],"content":"问题描述 给定一个R行C列的地图，地图的每一个方格可能是’#', ‘+’, ‘-', ‘|’, ‘.', ‘S’, ‘T'七个字符中的一个，分别表示如下意思： ‘#': 任何时候玩家都不能移动到此方格； ‘+’: 当玩家到达这一方格后，下一步可以向上下左右四个方向相邻的任意一个非’#‘方格移动一格； ‘-': 当玩家到达这一方格后，下一步可以向左右两个方向相邻的一个非’#‘方格移动一格； ‘|’: 当玩家到达这一方格后，下一步可以向上下两个方向相邻的一个非’#‘方格移动一格； ‘.': 当玩家到达这一方格后，下一步只能向下移动一格。如果下面相邻的方格为’#'，则玩家不能再移动； ‘S’: 玩家的初始位置，地图中只会有一个初始位置。玩家到达这一方格后，下一步可以向上下左右四个方向相邻的任意一个非’#‘方格移动一格； ‘T’: 玩家的目标位置，地图中只会有一个目标位置。玩家到达这一方格后，可以选择完成任务，也可以选择不完成任务继续移动。如果继续移动下一步可以向上下左右四个方向相邻的任意一个非’#‘方格移动一格。 此外，玩家不能移动出地图。 请找出满足下面两个性质的方格个数： 玩家可以从初始位置移动到此方格； 玩家不可以从此方格移动到目标位置。 它的数字只包含0, 1, 2, 3，且这四个数字都出现过至少一次。 所有的0都出现在所有的1之前，而所有的2都出现在所有的3之前。 最高位数字不为0。 因此，符合我们定义的最小的有趣的数是2013。除此以外，4位的有趣的数还有两个：2031和2301。 请计算恰好有n位的有趣的数的个数。由于答案可能非常大，只需要输出答案除以1000000007的余数。 ","date":"2019-07-10","objectID":"/posts/csp-201312-t5/:1:1","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T5 I'm stuck!","uri":"/posts/csp-201312-t5/"},{"categories":["CCF CSP"],"content":"输入格式 输入的第一行包括两个整数R 和C，分别表示地图的行和列数。(1 ≤ R, C ≤ 50)。 接下来的R行每行都包含C个字符。它们表示地图的格子。地图上恰好有一个'S'和一个'T’。 ","date":"2019-07-10","objectID":"/posts/csp-201312-t5/:1:2","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T5 I'm stuck!","uri":"/posts/csp-201312-t5/"},{"categories":["CCF CSP"],"content":"输出格式 如果玩家在初始位置就已经不能到达终点了，就输出“I'm stuck!”（不含双引号）。否则的话，输出满足性质的方格的个数。 ","date":"2019-07-10","objectID":"/posts/csp-201312-t5/:1:3","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T5 I'm stuck!","uri":"/posts/csp-201312-t5/"},{"categories":["CCF CSP"],"content":"样例输入 5 5 --+-+ ..|#. ..|## S-+-T ####. ","date":"2019-07-10","objectID":"/posts/csp-201312-t5/:1:4","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T5 I'm stuck!","uri":"/posts/csp-201312-t5/"},{"categories":["CCF CSP"],"content":"样例输出 2 ","date":"2019-07-10","objectID":"/posts/csp-201312-t5/:1:5","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T5 I'm stuck!","uri":"/posts/csp-201312-t5/"},{"categories":["CCF CSP"],"content":"样例说明 如果把满足性质的方格在地图上用'X'标记出来的话，地图如下所示： --+-+ ..|#X ..|## S-+-T ####X ","date":"2019-07-10","objectID":"/posts/csp-201312-t5/:1:6","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T5 I'm stuck!","uri":"/posts/csp-201312-t5/"},{"categories":["CCF CSP"],"content":"时间限制 1.0s ","date":"2019-07-10","objectID":"/posts/csp-201312-t5/:1:7","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T5 I'm stuck!","uri":"/posts/csp-201312-t5/"},{"categories":["CCF CSP"],"content":"内存限制 256.0MB ","date":"2019-07-10","objectID":"/posts/csp-201312-t5/:1:8","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T5 I'm stuck!","uri":"/posts/csp-201312-t5/"},{"categories":["CCF CSP"],"content":"题解 小模拟题。 按照规则正向遍历再反向遍历即可。 $$ \\lbrace \\text{满足性质的点集} \\rbrace = \\lbrace \\text{正向遍历可达的点集} \\rbrace - \\lbrace \\text{反向遍历可达的点集} \\rbrace $$ 需要注意的是，反向遍历时检查的是相邻点的类型而不是当前点。这样代码可能稍微有点复杂( 比如下面我的 )，可能直接写成图能更好复用代码一点。 ","date":"2019-07-10","objectID":"/posts/csp-201312-t5/:2:0","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T5 I'm stuck!","uri":"/posts/csp-201312-t5/"},{"categories":["CCF CSP"],"content":"代码 #include \u003ciostream\u003e#include \u003cqueue\u003e#include \u003cvector\u003e#include \u003ccstring\u003e#include \u003cset\u003e #define N 55 using namespace std; struct pos { int r, c; bool operator\u003c(const pos \u0026x) const { return (this-\u003er == x.r) ? ( this-\u003ec \u003c x.c) : ( this-\u003er \u003c x.r); } }; struct forwR { bool stuck; }; char m[N][N]; set\u003cpos\u003e *forw(int r, int c, pos s, pos t) { bool b[N][N]; queue\u003cpos\u003e q; memset(b, 0, sizeof(b)); while (!q.empty()) q.pop(); q.push(s); b[s.r][s.c] = true; while (!q.empty()) { pos cur = q.front(); q.pop(); vector\u003cpos\u003e rp; rp.clear(); switch (m[cur.r][cur.c]) { case '+': case 'S': case 'T': rp = { {0, -1}, {0, 1}, {-1, 0}, {1, 0}}; break; case '-': rp = { {0, -1}, {0, 1}}; break; case '|': rp = { {1, 0}, {-1, 0}}; break; case '.': rp = { {1, 0}}; break; } for (pos dp : rp) if (m[cur.r + dp.r][cur.c + dp.c] != '#' \u0026\u0026 !b[cur.r + dp.r][cur.c + dp.c]) { q.push(pos{cur.r + dp.r, cur.c + dp.c}); b[cur.r + dp.r][cur.c + dp.c] = true; } } if (!b[t.r][t.c]) return NULL; set\u003cpos\u003e *result = new set\u003cpos\u003e(); result-\u003eclear(); for (int ir = 1; ir \u003c= r; ir++) { for (int ic = 1; ic \u003c= c; ic++) { if (b[ir][ic]) result-\u003einsert(pos{ir, ic}); } } return result; } set\u003cpos\u003e rev(int r, int c, pos s) { bool b[N][N]; queue\u003cpos\u003e q; memset(b, 0, sizeof(b)); while (!q.empty()) q.pop(); q.push(s); b[s.r][s.c] = true; while (!q.empty()) { pos cur = q.front(); q.pop(); if (!b[cur.r - 1][cur.c] \u0026\u0026 (m[cur.r - 1][cur.c] == '.' || m[cur.r - 1][cur.c] == '|' || m[cur.r - 1][cur.c] == '+' || m[cur.r - 1][cur.c] == 'S' || m[cur.r - 1][cur.c] == 'T')) { q.push({cur.r - 1, cur.c}); b[cur.r - 1][cur.c] = true; } if (!b[cur.r + 1][cur.c] \u0026\u0026 (m[cur.r + 1][cur.c] == '|' || m[cur.r + 1][cur.c] == '+' || m[cur.r + 1][cur.c] == 'S' || m[cur.r + 1][cur.c] == 'T')) { q.push({cur.r + 1, cur.c}); b[cur.r + 1][cur.c] = true; } if (!b[cur.r][cur.c - 1] \u0026\u0026 (m[cur.r][cur.c - 1] == '-' || m[cur.r][cur.c - 1] == '+' || m[cur.r][cur.c - 1] == 'S' || m[cur.r][cur.c - 1] == 'T')) { q.push({cur.r, cur.c - 1}); b[cur.r][cur.c - 1] = true; } if (!b[cur.r][cur.c + 1] \u0026\u0026 (m[cur.r][cur.c + 1] == '-' || m[cur.r][cur.c + 1] == '+' || m[cur.r][cur.c + 1] == 'S' || m[cur.r][cur.c + 1] == 'T')) { q.push({cur.r, cur.c + 1}); b[cur.r][cur.c + 1] = true; } } set\u003cpos\u003e result; result.clear(); for (int i = 1; i \u003c= r; i++) for (int j = 1; j \u003c= c; j++) { if (b[i][j]) result.insert({i, j}); } return result; } int main() { int r, c; cin \u003e\u003e r \u003e\u003e c; pos s, t; for (int i = 0; i \u003c N; i++) for (int j = 0; j \u003c N; j++) { m[i][j] = '#'; } for (int i = 1; i \u003c= r; i++) for (int j = 1; j \u003c= c; j++) { cin \u003e\u003e m[i][j]; if (m[i][j] == 'S') s = pos{i, j}; else if (m[i][j] == 'T') t = pos{i, j}; } set\u003cpos\u003e *pre = forw(r, c, s, t); if (pre == NULL) { cout \u003c\u003c \"I'm stuck!\"; return 0; } set\u003cpos\u003e post = rev(r, c, t); int ans = 0; for (pos p : *pre) { if (post.find(p) == end(post)) ans++; } cout \u003c\u003c ans; return 0; } ","date":"2019-07-10","objectID":"/posts/csp-201312-t5/:3:0","tags":["CCF CSP","algorithm"],"title":"CSP 201312 T5 I'm stuck!","uri":"/posts/csp-201312-t5/"}]