<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="noodp" />
    <title class="pjax-title">深入浅出etcd/raft —— 0x04 Raft日志 - 叉鸽 MrCroxx 的博客</title><meta name="Description" content="Welcome to MrCroxx&#39;s Blog."><meta property="og:title" content="深入浅出etcd/raft —— 0x04 Raft日志" />
<meta property="og:description" content="本文为原创文章，转载请严格遵守CC BY-NC-SA协议。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mrcroxx.github.io/posts/code-reading/etcdraft-made-simple/4-log/" /><meta property="og:image" content="https://mrcroxx.github.io/posts/code-reading/etcdraft-made-simple/4-log/etcd-raft.jpg"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-23T12:22:41+08:00" />
<meta property="article:modified_time" content="2020-12-23T12:22:44+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://mrcroxx.github.io/posts/code-reading/etcdraft-made-simple/4-log/etcd-raft.jpg"/>
<meta name="twitter:title" content="深入浅出etcd/raft —— 0x04 Raft日志"/>
<meta name="twitter:description" content="本文为原创文章，转载请严格遵守CC BY-NC-SA协议。"/>
<meta name="application-name" content="叉鸽 MrCroxx 的博客">
<meta name="apple-mobile-web-app-title" content="叉鸽 MrCroxx 的博客">

<meta name="theme-color" content="#f8f8f8"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="canonical" href="https://mrcroxx.github.io/posts/code-reading/etcdraft-made-simple/4-log/" /><link rel="prev" href="https://mrcroxx.github.io/posts/code-reading/etcdraft-made-simple/3-election/" /><link rel="next" href="https://mrcroxx.github.io/posts/code-reading/etcdraft-made-simple/5-confchange/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/fontawesome-free/all.min.css">
    <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/animate/animate.min.css">
    <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "深入浅出etcd/raft —— 0x04 Raft日志",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/mrcroxx.github.io\/posts\/code-reading\/etcdraft-made-simple\/4-log\/"
        },"image": [{
                            "@type": "ImageObject",
                            "url": "https:\/\/mrcroxx.github.io\/posts\/code-reading\/etcdraft-made-simple\/4-log\/etcd-raft.jpg",
                            "width":  1200 ,
                            "height":  360 
                        }],"genre": "posts","keywords": "etcd, Raft","wordcount":  27379 ,
        "url": "https:\/\/mrcroxx.github.io\/posts\/code-reading\/etcdraft-made-simple\/4-log\/","datePublished": "2020-12-23T12:22:41+08:00","dateModified": "2020-12-23T12:22:44+08:00","publisher": {
            "@type": "Organization",
            "name": "叉鸽"},"author": {
                "@type": "Person",
                "name": "叉鸽"
            },"description": ""
    }
    </script></head>

<body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">
        function setTheme(theme) {document.body.setAttribute('theme', theme);}
        function saveTheme(theme) {window.localStorage && localStorage.setItem('theme', theme);}
        function getMeta(metaName) {const metas = document.getElementsByTagName('meta'); for (let i = 0; i < metas.length; i++) if (metas[i].getAttribute('name') === metaName) return metas[i]; return '';}
        if (window.localStorage && localStorage.getItem('theme')) {let theme = localStorage.getItem('theme');theme === 'light' || theme === 'dark' || theme === 'black' ? setTheme(theme) : (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light')); } else { if ('' === 'light' || '' === 'dark' || '' === 'black') setTheme(''), saveTheme(''); else saveTheme('auto'), window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light');}
        let metaColors = {'light': '#f8f8f8','dark': '#252627','black': '#000000'}
        getMeta('theme-color').content = metaColors[document.body.getAttribute('theme')];
    </script>
    <div id="back-to-top"></div>
    <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="叉鸽 MrCroxx 的博客"><span id="desktop-header-typeit" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/posts/about-me"> 关于我 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="#" onclick="return false;" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" onclick="return false;" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="#" onclick="return false;" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="叉鸽 MrCroxx 的博客"><span id="mobile-header-typeit" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="#" onclick="return false;" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" onclick="return false;" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="#" onclick="return false;" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/posts/about-me" title="">关于我</a><a href="#" onclick="return false;" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
            <div class="container"><div class="toc" id="toc-auto">
        <h2 class="toc-title">目录</h2>
        <div class="toc-content" id="toc-content-auto"></div>
    </div><script>document.getElementsByTagName("main")[0].setAttribute("pageStyle", "normal")</script><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC", "true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">深入浅出etcd/raft —— 0x04 Raft日志</h1><div class="post-meta">
            <div class="post-meta-line">
                <span class="post-author"><i class="author fas fa-user-circle fa-fw"></i><a href="about" title="Author" rel=" author" class="author">叉鸽</a>
                </span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAetcd/raft/"><i class="far fa-folder fa-fw"></i>深入浅出etcd/raft</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2020-12-23">2020-12-23</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime="2020-12-23">2020-12-23</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 27379 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 55 分钟&nbsp;</div>
        </div><div class="featured-image"><img
        class="lazyload"
        data-src="/posts/code-reading/etcdraft-made-simple/4-log/etcd-raft.jpg"
        data-srcset="/posts/code-reading/etcdraft-made-simple/4-log/etcd-raft.jpg, /posts/code-reading/etcdraft-made-simple/4-log/etcd-raft.jpg 1.5x, /posts/code-reading/etcdraft-made-simple/4-log/etcd-raft.jpg 2x"
        data-sizes="auto"
        alt="/posts/code-reading/etcdraft-made-simple/4-log/etcd-raft.jpg"
        title="/posts/code-reading/etcdraft-made-simple/4-log/etcd-raft.jpg" height="360" width="1200"
    /></div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#0-引言">0. 引言</a></li>
    <li><a href="#1-etcdraft日志复制优化">1. etcd/raft日志复制优化</a>
      <ul>
        <li><a href="#11-快速回退">1.1 快速回退</a></li>
        <li><a href="#12-并行写入">1.2 并行写入</a></li>
        <li><a href="#13-批处理与流水线">1.3 批处理与流水线</a>
          <ul>
            <li><a href="#131-批处理">1.3.1 批处理</a></li>
            <li><a href="#132-流水线">1.3.2 流水线</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#2-etcdraft中的日志结构">2. etcd/raft中的日志结构</a>
      <ul>
        <li><a href="#21-raftlog的设计">2.1 raftLog的设计</a></li>
        <li><a href="#22-storage的设计与实现">2.2 Storage的设计与实现</a></li>
        <li><a href="#23-unstable的设计与实现">2.3 unstable的设计与实现</a></li>
        <li><a href="#24-raftlog的实现">2.4 raftLog的实现</a></li>
      </ul>
    </li>
    <li><a href="#3-复制进度跟踪">3. 复制进度跟踪</a>
      <ul>
        <li><a href="#31-progress结构体">3.1 Progress结构体</a></li>
        <li><a href="#32-follower的3种状态">3.2 follower的3种状态</a></li>
        <li><a href="#33-状态转换与更新回退">3.3 状态转换与更新回退</a></li>
      </ul>
    </li>
    <li><a href="#4-etcdraft中日志复制实现">4. etcd/raft中日志复制实现</a>
      <ul>
        <li><a href="#41-节点启动时日志处理">4.1 节点启动时日志处理</a></li>
        <li><a href="#42-leader中的日志提议">4.2 leader中的日志提议</a></li>
        <li><a href="#43-leader为follower复制日志">4.3 leader为follower复制日志</a></li>
        <li><a href="#44-follower处理来自leader的日志">4.4 follower处理来自leader的日志</a></li>
        <li><a href="#45-leader处理来自follower的日志复制响应">4.5 leader处理来自follower的日志复制响应</a></li>
        <li><a href="#46-心跳消息中日志复制相关操作">4.6 心跳消息中日志复制相关操作</a></li>
      </ul>
    </li>
    <li><a href="#5-q--a">5. Q &amp; A</a>
      <ul>
        <li><a href="#51-为什么raftlog使用了unstable也能保证安全性">5.1 为什么raftLog使用了unstable也能保证安全性？</a></li>
        <li><a href="#52-entrieshardstatesnapshot持久化顺序有要求吗">5.2 Entries、HardState、Snapshot持久化顺序有要求吗？</a></li>
      </ul>
    </li>
    <li><a href="#6-总结">6. 总结</a></li>
    <li><a href="#参考文献">参考文献</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><p><em>本文为原创文章，转载请严格遵守<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener noreffer">CC BY-NC-SA协议</a>。</em></p>
<h2 id="0-引言">0. 引言</h2>
<p>本文会对etcd/raft中Raft日志复制算法的实现与优化进行分析。这里假定读者阅读过Diego Ongaro的《In Search of an Understandable Consensus Algorithm (Extended Version)》（这里有笔者的<a href="/posts/paper-reading/raft-extended/" rel="">翻译</a>，笔者英语水平一般，欢迎指正。），其中提到的部分，本文中不会做详细的解释。对etcd/raft的总体结构不熟悉的读者，可以先阅读<a href="/posts/code-reading/etcdraft-made-simple/2-overview/" rel="">《深入浅出etcd/raft —— 0x02 etcd/raft总体设计》</a>。</p>
<p>本文首先介绍了etcd/raft中日志复制部分的优化。由于etcd/raft中对日志复制的优化大部分属于实现上的优化，这些优化是在系统中很常见的优化，因此本文会一笔带过其理论部分，而着重于讲解etcd/raft中日志复制的实现。</p>
<p>因为日志复制的逻辑涉及到的方面多、逻辑复杂、经过数年的版本演进部分逻辑难以理解，因此本文后半部分详细地分析了etcd/raft中与日志复制相关的几乎所有逻辑，以供读者参考。这里不建议读者通读本文讲解实现的部分，而是按照自己的节奏阅读源码，在遇到难以理解的部分时可以将本文作为补充参考。</p>
<h2 id="1-etcdraft日志复制优化">1. etcd/raft日志复制优化</h2>
<p>本节将介绍etcd/raft中日志复制部分采用的优化。</p>
<h3 id="11-快速回退">1.1 快速回退</h3>
<p>在《In Search of an Understandable Consensus Algorithm (Extended Version)》和《CONSENSUS: BRIDGING THEORY AND PRACTICE》介绍Raft算法基本概念时，提到了一种快速回退<em>next index</em>的方法。当follower拒绝leader的AppendEntries RPC（<code>MsgApp</code>）请求时，follower会通过响应消息（<code>MsgAppResp</code>）的一个字段（<code>RejectHint</code>）告知leader日志冲突的位置与当前term的第一条日志的index。这样，leader可以直接将该follower的<em>next index</em>回退到该位置，然后继续以“一次回退一条”的方式检查冲突。</p>
<p>etcd/raft中也实现了类似的优化，但是其将follower的最后一条日志作为该字段的值。正如Diego Ongaro所说，故障不会经常发生，因此出现很多不一致的日志条目的可能性不大（etcd/raft该部分的作者也是这样想的，详见<a href="https://github.com/etcd-io/etcd/pull/2021" target="_blank" rel="noopener noreffer">pull#2021</a>），所以回退到follower的最后一条日志后继续检查冲突即可。</p>
<h3 id="12-并行写入">1.2 并行写入</h3>
<p>《CONSENSUS: BRIDGING THEORY AND PRACTICE》的<em>10.2.1 Writing to the leader’s disk in parallel</em>介绍了一种减少Raft算法关键路径上的磁盘写入的优化。在朴素的实现方式中，leader需要先将新日志写入本地稳定存储之后再为follower复制这些日志，这会大大增加处理的延迟。</p>
<p>事实上，这次关键路径上的磁盘写入是可以优化的。leader可以在为follower复制日志的同时将这些日志写入其本地稳定存储。为了简化实现，leader自己的<em>match index</em>表示其写入到了稳定存储的最后一条日志的索引。当当前term的某日志被大多数的<em>match index</em>覆盖时，leader便可以使<em>commit index</em>前进到该节点处。这种优化是安全的，通过这种优化，leader甚至可以在日志写入本地稳定存储完成之前提交日志。</p>
<h3 id="13-批处理与流水线">1.3 批处理与流水线</h3>
<p>《CONSENSUS: BRIDGING THEORY AND PRACTICE》的<em>10.2.2 Batching and pipelining</em>介绍了Raft算法实现时的批处理与流水线优化。批处理与流水线是各种系统提高吞吐量的常用方式，etcd/raft也不例外。</p>
<h4 id="131-批处理">1.3.1 批处理</h4>
<p>简而言之，批处理（batch）就是在消息到来时先推迟对消息的处理，等到消息积累到一定数量或者经过一段时间后一起处理这批消息，在损失可接受的延迟的情况下提高系统吞吐量。在etcd/raft的实现中主要有两处使用了批处理的设计，一处是网络，一处是存储：</p>
<ul>
<li>网络：leader在为稳定的follower复制日志时，会用一条消息复制多条日志，且每次可能同时发送多条消息。后文会介绍相关实现。</li>
<li>存储：在前文中笔者介绍过数据的存储时etcd/raft的使用者的责任，使用者需要将<code>Ready</code>结构体中的<code>HardStates</code>、<code>Entries</code>、<code>Snapshot</code>保存到稳定存储，然后在处理完所有字段后调用<code>Advance</code>方法以接收下一批数据。<code>Ready</code>和<code>Advance</code>的设计即体现了微批处理的思想。</li>
</ul>
<h4 id="132-流水线">1.3.2 流水线</h4>
<p>流水线（pipeline）同样是各种系统常用的提高吞吐量的方式。在etcd/raft的实现中，leader在向follower发送完日志复制请求后，不会等待follower响应，而是立即更新其<em>nextIndex</em>，并继续处理，以提高吞吐量。</p>
<p>在正常且稳定的情况下，消息应恰好一次且有序到达。但是在异常情况下，可能出现消息丢失、消息乱序、消息超时等等情况，在前文<a href="/posts/code-reading/etcdraft-made-simple/3-election/" rel="">深入浅出etcd/raft —— 0x03 Raft选举</a>介绍<code>Step</code>方法时，介绍了一些对过期消息的处理方式，重复的地方本文不再赘述。当follower收到过期的日志复制请求时，会拒绝该请求，随后follower会回退其<em>nextIndex</em>以重传之后的日志。</p>
<h2 id="2-etcdraft中的日志结构">2. etcd/raft中的日志结构</h2>
<p>在分析etcd/raft的日志复制的实现时，首先要了解etcd/raft中Raft日志结构的实现方式。etcd/raft中Raft日志是通过结构体<code>raftLog</code>实现的。本节将介绍<code>raftLog</code>的设计与实现。</p>
<h3 id="21-raftlog的设计">2.1 raftLog的设计</h3>
<p>etcd/raft中Raft日志是通过<code>raftLog</code>结构体记录的。<code>raftLog</code>结构体中，既有还未持久化的数据，也有已经持久化到稳定存储的数据；其中数据既有日志条目，也有快照。如果直观的给出<code>raftLog</code>中数据的逻辑结构，其大概如下图所示。</p>
<p><figure><a class="lightgallery" href="/posts/code-reading/etcdraft-made-simple/4-log/assets/raftLog.svg" title="raftLog逻辑结构示意图" data-thumbnail="/posts/code-reading/etcdraft-made-simple/4-log/assets/raftLog.svg" data-sub-html="<h2>raftLog逻辑结构示意图</h2><p>raftLog逻辑结构示意图</p>">
        <img
            class="lazyload"
            data-src="assets/raftLog.svg"
            data-srcset="/posts/code-reading/etcdraft-made-simple/4-log/assets/raftLog.svg, assets/raftLog.svg 1.5x, /posts/code-reading/etcdraft-made-simple/4-log/assets/raftLog.svg 2x"
            data-sizes="auto"
            alt="/posts/code-reading/etcdraft-made-simple/4-log/assets/raftLog.svg"
        />
    </a><figcaption class="image-caption">raftLog逻辑结构示意图</figcaption>
    </figure></p>
<p><code>raftLog</code>中的数据，按照是否已持久化到稳定存储，可分为两部分：已持久化到稳定存储的部分（stable）和还未持久化到稳定存储的部分（unstable）。无论是stable的部分还是unstable的部分中，都可能包含快照或日志，且每部分的快照中包含的已压缩的日志比该部分相应的未压缩的日志更旧。需要注意的是，在etcd/raft的实现中，在同一时刻，<code>raftLog</code>中的4个段可能并不是同时存在的。</p>
<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>提示<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">关于日志unstable段对算法安全性的讨论详见<a href="#51-%e4%b8%ba%e4%bb%80%e4%b9%88raftlog%e4%bd%bf%e7%94%a8%e4%ba%86unstable%e4%b9%9f%e8%83%bd%e4%bf%9d%e8%af%81%e5%ae%89%e5%85%a8%e6%80%a7" rel="">5.1节</a>。</div>
        </div>
    </div>
<p>在etcd/raft的日志操作中，有4个经常使用的索引：</p>
<table>
<thead>
<tr>
<th>索引名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>committed</td>
<td>在该节点所知数量达到quorum的节点保存到了稳定存储中的日志里，index最高的日志的index。</td>
</tr>
<tr>
<td>applied</td>
<td>在该节点的应用程序已应用到其状态机的日志里，index最高的日志的index。<br> 其中， $ applied \le committed $ 总是成立的。</td>
</tr>
<tr>
<td>firstIndex</td>
<td>在该节点的日志中，最新的快照之后的第一条日志的index。</td>
</tr>
<tr>
<td>lastIndex</td>
<td>在该节点的日志中，最后一条日志的index。</td>
</tr>
</tbody>
</table>
<p>这里需要注意的是，所有的这些索引都是相对于当前节点而不是整个集群的，例如，当index为$i_1$的日志已被集群中数量达到quorum的节点保存到稳定存储时，一些节点可能还不知道$i_1$已被commit。</p>
<p><code>raftLog</code>中unstable的部分保存在<code>unstable</code>结构体中，而stable的部分稍有些复杂。为了让使用etcd/raft模块的开发者能够根据自己的需求自定义Raft日志存储，stable的部分不是直接通过内部的结构体实现的。<code>go.etcd.io/etcd/raft/storage.go</code>文件中定义了<code>Storage</code>接口，只要实现了该接口，都可以用来存储stable日志。在<a href="/posts/code-reading/etcdraft-made-simple/2-overview/" rel="">深入浅出etcd/raft —— 0x02 etcd/raft总体设计</a>的引言中，笔者提到<code>Storage</code>接口只定义了读取稳定存储中的日志、快照、状态的方法（如下图所示），etcd/raft并不关心也不知道开发者写入稳定存储的方式。那么，etcd/raft是怎样将unstable中的数据写入到稳定存储中的呢？</p>
<p><figure><a class="lightgallery" href="/posts/code-reading/etcdraft-made-simple/4-log/assets/overview.svg" title="etcd/raft职责示意图" data-thumbnail="/posts/code-reading/etcdraft-made-simple/4-log/assets/overview.svg" data-sub-html="<h2>etcd/raft职责示意图</h2><p>etcd/raft职责示意图</p>">
        <img
            class="lazyload"
            data-src="assets/overview.svg"
            data-srcset="/posts/code-reading/etcdraft-made-simple/4-log/assets/overview.svg, assets/overview.svg 1.5x, /posts/code-reading/etcdraft-made-simple/4-log/assets/overview.svg 2x"
            data-sizes="auto"
            alt="/posts/code-reading/etcdraft-made-simple/4-log/assets/overview.svg"
        />
    </a><figcaption class="image-caption">etcd/raft职责示意图</figcaption>
    </figure></p>
<p>在<a href="/posts/code-reading/etcdraft-made-simple/1-raftexample/" rel="">深入浅出etcd/raft —— 0x01 raftexample</a>中，笔者通过了官方提供的raftexample示例，介绍了使用etcd/raft的开发者与<code>Node</code>接口打交道并处理<code>Ready</code>结构体的方式（在<a href="/posts/code-reading/etcdraft-made-simple/2-overview/" rel="">深入浅出etcd/raft —— 0x02 etcd/raft总体设计</a>中也有提到）。其中，开发者需要将<code>Ready</code>结构体<code>Entities</code>和<code>Snapshot</code>字段中的数据保存到稳定存储中，这就是将数据从unstable转移到stable中的过程，这种设计也让etcd/raft不需要依赖稳定存储的具体写入方法。下图直观地表示了follower节点从收到leader发来的日志到将其保存至稳定存储中的大致流程（快照的处理方式也同理）。</p>
<p><figure><a class="lightgallery" href="/posts/code-reading/etcdraft-made-simple/4-log/assets/log-path.svg" title="日志复制流程示意图" data-thumbnail="/posts/code-reading/etcdraft-made-simple/4-log/assets/log-path.svg" data-sub-html="<h2>日志复制流程示意图</h2><p>日志复制流程示意图</p>">
        <img
            class="lazyload"
            data-src="assets/log-path.svg"
            data-srcset="/posts/code-reading/etcdraft-made-simple/4-log/assets/log-path.svg, assets/log-path.svg 1.5x, /posts/code-reading/etcdraft-made-simple/4-log/assets/log-path.svg 2x"
            data-sizes="auto"
            alt="/posts/code-reading/etcdraft-made-simple/4-log/assets/log-path.svg"
        />
    </a><figcaption class="image-caption">日志复制流程示意图</figcaption>
    </figure></p>
<p>接下来，笔者对<code>Storage</code>和<code>unstable</code>进行分析。其中，对<code>Storage</code>的分析包括etcd采用的<code>Storage</code>实现——<code>MemoryStorage</code>。</p>
<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>说明<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><code>Storage</code>接口定义的是稳定存储的读取方法。之所以etcd使用了基于内存的<code>MemoryStorage</code>，是因为etcd在写入<code>MemoryStorage</code>前，需要先写入预写日志（Write Ahead Log，WAL）或快照。而预写日志和快照是保存在稳定存储中的。这样，在每次重启时，etcd可以基于保存在稳定存储中的快照和预写日志恢复<code>MemoryStorage</code>的状态。也就是说，etcd的稳定存储是通过快照、预写日志、<code>MemoryStorage</code>三者共同实现的。</div>
        </div>
    </div>
<h3 id="22-storage的设计与实现">2.2 Storage的设计与实现</h3>
<p><code>Storage</code>接口定义了etcd/raft中需要的读取稳定存储中日志、快照、状态等方法。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Storage is an interface that may be implemented by the application
</span></span></span><span class="line"><span class="cl"><span class="c1">// to retrieve log entries from storage.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// If any Storage method returns an error, the raft instance will
</span></span></span><span class="line"><span class="cl"><span class="c1">// become inoperable and refuse to participate in elections; the
</span></span></span><span class="line"><span class="cl"><span class="c1">// application is responsible for cleanup and recovery in this case.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Storage</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// TODO(tbg): split this into two interfaces, LogStorage and StateStorage.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// InitialState returns the saved HardState and ConfState information.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">InitialState</span><span class="p">()</span> <span class="p">(</span><span class="nx">pb</span><span class="p">.</span><span class="nx">HardState</span><span class="p">,</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">ConfState</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Entries returns a slice of log entries in the range [lo,hi).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// MaxSize limits the total size of the log entries returned, but
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Entries returns at least one entry if any.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">Entries</span><span class="p">(</span><span class="nx">lo</span><span class="p">,</span> <span class="nx">hi</span><span class="p">,</span> <span class="nx">maxSize</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">([]</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Term returns the term of entry i, which must be in the range
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// [FirstIndex()-1, LastIndex()]. The term of the entry before
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// FirstIndex is retained for matching purposes even though the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// rest of that entry may not be available.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">Term</span><span class="p">(</span><span class="nx">i</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// LastIndex returns the index of the last entry in the log.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">LastIndex</span><span class="p">()</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// FirstIndex returns the index of the first log entry that is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// possibly available via Entries (older entries have been incorporated
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// into the latest Snapshot; if storage only contains the dummy entry the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// first log entry is not available).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">FirstIndex</span><span class="p">()</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Snapshot returns the most recent snapshot.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// If snapshot is temporarily unavailable, it should return ErrSnapshotTemporarilyUnavailable,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// so raft state machine could know that Storage needs some time to prepare
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// snapshot and call Snapshot later.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">Snapshot</span><span class="p">()</span> <span class="p">(</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Snapshot</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>Storage</code>中定义了需要从稳定存储读取的6种方法（具体定义见上面给出的代码与注释，这里不再赘述）。其中<code>HardState</code>指Raft状态机需要在本地稳定存储中持久化保存的状态，对应论文中的<em>Persistent State</em>（etcd/raft为了优化Raft日志，其保存的字段与原文稍有不同），相应的，<code>SoftState</code>只不需要持久化保存的状态，对应论文中的<em>Volatile State</em>；另外，由于陈旧的日志会被压缩成快照，因此有些方法并不总能获取到所需的值。</p>
<p>接下来对<code>MemoryStorage</code>的实现进行分析。<code>MemoryStorage</code>是etcd中使用的<code>Storage</code>实现，其实现了<code>Storage</code>中定义的读取稳定存储的方法，还实现了相应的写入稳定存储的方法。<code>MemoryStorage</code>结构体中的字段如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// MemoryStorage implements the Storage interface backed by an
</span></span></span><span class="line"><span class="cl"><span class="c1">// in-memory array.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">MemoryStorage</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Protects access to all fields. Most methods of MemoryStorage are
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// run on the raft goroutine, but Append() is run on an application
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// goroutine.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">hardState</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">HardState</span>
</span></span><span class="line"><span class="cl">	<span class="nx">snapshot</span>  <span class="nx">pb</span><span class="p">.</span><span class="nx">Snapshot</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ents[i] has raft log position i+snapshot.Metadata.Index
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ents</span> <span class="p">[]</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>其中，<code>ents</code>字段就是用来保存日志条目的切片。该切片的首元素被设计为用来保存元数据的条目，而不是真正的日志条目，其保存了快照的最后一条日志对应的term和index，该条目也被成为<em>dummy entry</em>。<code>MemoryStorage</code>中<code>ents</code>字段可以直观表示为下图的结构。</p>
<p><figure><a class="lightgallery" href="/posts/code-reading/etcdraft-made-simple/4-log/assets/memorystorage.svg" title="MemoryStorage中ents结构示意图" data-thumbnail="/posts/code-reading/etcdraft-made-simple/4-log/assets/memorystorage.svg" data-sub-html="<h2>MemoryStorage中ents结构示意图</h2><p>MemoryStorage中ents结构示意图</p>">
        <img
            class="lazyload"
            data-src="assets/memorystorage.svg"
            data-srcset="/posts/code-reading/etcdraft-made-simple/4-log/assets/memorystorage.svg, assets/memorystorage.svg 1.5x, /posts/code-reading/etcdraft-made-simple/4-log/assets/memorystorage.svg 2x"
            data-sizes="auto"
            alt="/posts/code-reading/etcdraft-made-simple/4-log/assets/memorystorage.svg"
        />
    </a><figcaption class="image-caption">MemoryStorage中ents结构示意图</figcaption>
    </figure></p>
<p>注意，图中的<em>first index</em>和<em>last index</em>是<code>Storage</code>接口的<code>FirstIndex</code>和<code>LastIndex</code>方法定义的索引，而不是整个<code>raftLog</code>的<em>first index</em>或<em>last index</em>。</p>
<p><code>MemoryStorage</code>的实现不是很复杂，其中很多逻辑是在处理越界和<em>dummy entry</em>，这里不再占用篇幅详细解释。此外，<code>MemoryStorage</code>通过互斥锁保证其操作是线程安全的。</p>
<h3 id="23-unstable的设计与实现">2.3 unstable的设计与实现</h3>
<p><code>unstable</code>结构体中保存了还未被保存到稳定存储中的快照或日志条目。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// unstable.entries[i] has raft log position i+unstable.offset.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Note that unstable.offset may be less than the highest log
</span></span></span><span class="line"><span class="cl"><span class="c1">// position in storage; this means that the next write to storage
</span></span></span><span class="line"><span class="cl"><span class="c1">// might need to truncate the log before persisting unstable.entries.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">unstable</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// the incoming unstable snapshot, if any.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">snapshot</span> <span class="o">*</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Snapshot</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// all entries that have not yet been written to storage.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">entries</span> <span class="p">[]</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span>
</span></span><span class="line"><span class="cl">	<span class="nx">offset</span>  <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">logger</span> <span class="nx">Logger</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>unstable</code>结构体中的<code>offset</code>字段记录了unstable的日志起点，该起点可能比<code>Storage</code>中index最高的日志条目旧，也就是说<code>Storage</code>和<code>unstable</code>中的日志可能有部分重叠，因此在处理二者之间的日志时，有一些裁剪日志的操作。</p>
<p><code>unstable</code>中较为重要的方法如下表所示。</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法<div style="width: 18em"></div></th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>maybeFirstIndex() (uint64, bool)</code></td>
<td style="text-align:left">获取相对整个<code>raftLog</code>的<em>first index</em>，当<code>unstable</code>无法得知该值时，第二个返回值返回<code>false</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>maybeLastIndex() (uint64, bool)</code></td>
<td style="text-align:left">获取相对整个<code>raftLog</code>的<em>last index</em>，当<code>unstable</code>无法得知该值时，第二个返回值返回<code>false</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>maybeTerm(i uint64) (uint64, bool)</code></td>
<td style="text-align:left">获取给定index的日志条目的term，当<code>unstable</code>无法得知该值时，第二个返回值返回<code>false</code></td>
</tr>
<tr>
<td style="text-align:center"><code>stableTo(i, t uint64)</code></td>
<td style="text-align:left">通知<code>unstable</code>当前index为<code>i</code>、term为<code>t</code>及其之前的日志已经被保存到了稳定存储中，可以裁剪掉<code>unstable</code>中的这段日志了。裁剪后会根据空间利用率适当地对空间进行优化。</td>
</tr>
<tr>
<td style="text-align:center"><code>stableSnapTo(i uint64)</code></td>
<td style="text-align:left">通知<code>unstable</code>当前index在<code>i</code>及其之前的快照已经保存到了稳定存储中，如果<code>unstable</code>中保存了该快照，那么可以释放该快照了。</td>
</tr>
<tr>
<td style="text-align:center"><code>restore(s pb.Snapshot)</code></td>
<td style="text-align:left">根据快照恢复<code>unstable</code>的状态（设置<code>unstbale</code>中的<code>offset</code>、<code>snapshot</code>，并将<code>entries</code>置空）。</td>
</tr>
<tr>
<td style="text-align:center"><code>truncateAndAppend(ents []pb.Entry)</code></td>
<td style="text-align:left">对给定的日志切片进行裁剪，并将其加入到<code>unstable</code>保存的日志中。</td>
</tr>
<tr>
<td style="text-align:center"><code>slice(lo uint64, hi uint64)</code></td>
<td style="text-align:left">返回给定范围内的日志切片。首先会通过<code>mustCheckOutOfBounds(lo, hi uint64)</code>方法检查是否越界，如果越界会因此panic。</td>
</tr>
</tbody>
</table>
<p><code>unstable</code>中的<em>first index</em>和<em>last index</em>的实现与<code>Storage</code>稍有不同。<code>unstable</code>的<code>maybeFirstIndex</code>方法与<code>maybeLastIndex</code>方法获取的是相对整个<code>raftLog</code>的<em>first index</em>或<em>last index</em>，当<code>unstable</code>无法得知整个<code>raftLog</code>的<em>first index</em>或<em>last index</em>时，这两个方法的第二个返回值会被置为<code>false</code>。这种设计与<code>raftLog</code>的实现有关，在<code>raftLog</code>的<code>firstIndex</code>和<code>lastIndex</code>方法中，首先会调用<code>unstable</code>的<code>maybeFirstIndex</code>方法或<code>maybeLastIndex</code>方法，如果查询的索引不在<code>unstable</code>中时，其会继续询问<code>Storage</code>。<code>unstable</code>中<code>maybeFirstIndex</code>方法与<code>maybeLastIndex</code>方法的实现如下。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// maybeFirstIndex returns the index of the first possible entry in entries
</span></span></span><span class="line"><span class="cl"><span class="c1">// if it has a snapshot.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">u</span> <span class="o">*</span><span class="nx">unstable</span><span class="p">)</span> <span class="nf">maybeFirstIndex</span><span class="p">()</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">u</span><span class="p">.</span><span class="nx">snapshot</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">u</span><span class="p">.</span><span class="nx">snapshot</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">.</span><span class="nx">Index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// maybeLastIndex returns the last index if it has at least one
</span></span></span><span class="line"><span class="cl"><span class="c1">// unstable entry or snapshot.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">u</span> <span class="o">*</span><span class="nx">unstable</span><span class="p">)</span> <span class="nf">maybeLastIndex</span><span class="p">()</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">l</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">u</span><span class="p">.</span><span class="nx">entries</span><span class="p">);</span> <span class="nx">l</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">u</span><span class="p">.</span><span class="nx">offset</span> <span class="o">+</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">l</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">u</span><span class="p">.</span><span class="nx">snapshot</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">u</span><span class="p">.</span><span class="nx">snapshot</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">.</span><span class="nx">Index</span><span class="p">,</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>简单来说，只有<code>unstable</code>中包含快照时，<code>unstable</code>才可能得知整个<code>raftLog</code>的<em>first index</em>的位置（快照前的日志不会影响快照后的状态）；而只有当<code>unstable</code>中既没有日志也没有快照时，<code>unstable</code>才无法得知<em>last index</em>的位置。</p>
<p><code>unstable</code>中另一处比较重要的方法是<code>truncateAndAppend</code>。当<code>raftLog</code>需要将新日志保存到<code>unstable</code>中时会调用该方法。该方法会根据给定的日志切片的范围和当前<code>unstable</code>中日志切片的范围对二者进行适当地裁剪，其逻辑如下。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">u</span> <span class="o">*</span><span class="nx">unstable</span><span class="p">)</span> <span class="nf">truncateAndAppend</span><span class="p">(</span><span class="nx">ents</span> <span class="p">[]</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">after</span> <span class="o">:=</span> <span class="nx">ents</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Index</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">after</span> <span class="o">==</span> <span class="nx">u</span><span class="p">.</span><span class="nx">offset</span><span class="o">+</span><span class="nb">uint64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">u</span><span class="p">.</span><span class="nx">entries</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// after is the next index in the u.entries
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// directly append
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">u</span><span class="p">.</span><span class="nx">entries</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">u</span><span class="p">.</span><span class="nx">entries</span><span class="p">,</span> <span class="nx">ents</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">after</span> <span class="o">&lt;=</span> <span class="nx">u</span><span class="p">.</span><span class="nx">offset</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">u</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;replace the unstable entries from index %d&#34;</span><span class="p">,</span> <span class="nx">after</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// The log is being truncated to before our current offset
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// portion, so set the offset and replace the entries
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">u</span><span class="p">.</span><span class="nx">offset</span> <span class="p">=</span> <span class="nx">after</span>
</span></span><span class="line"><span class="cl">		<span class="nx">u</span><span class="p">.</span><span class="nx">entries</span> <span class="p">=</span> <span class="nx">ents</span>
</span></span><span class="line"><span class="cl">	<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// truncate to after and copy to u.entries
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// then append
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">u</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;truncate the unstable entries before index %d&#34;</span><span class="p">,</span> <span class="nx">after</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">u</span><span class="p">.</span><span class="nx">entries</span> <span class="p">=</span> <span class="nb">append</span><span class="p">([]</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span><span class="p">{},</span> <span class="nx">u</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="nx">u</span><span class="p">.</span><span class="nx">offset</span><span class="p">,</span> <span class="nx">after</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">u</span><span class="p">.</span><span class="nx">entries</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">u</span><span class="p">.</span><span class="nx">entries</span><span class="p">,</span> <span class="nx">ents</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>该方法首先会获取给定日志切片中第一个日志条目的index（<code>after</code>），将其与<code>unstable</code>中已有日志的index进行比较，以确定处理方法：</p>
<ol>
<li>当<code>after</code>恰好是<code>unstable</code>的下一条日志时，直接将其追加到<code>unstable</code>当前保存的日志之后。</li>
<li>当<code>after</code>比<code>unstable</code>的第一条日志还早时，此时给定的日志切片与<code>unstable</code>中的日志可能有冲突的部分（如Raft算法中leader强制覆盖follower中的日志时），为了更简单地处理冲突，直接将<code>unstable</code>中保存的日志替换为给定日志。</li>
<li>当<code>after</code>在<code>offset</code>之后但与<code>unstable</code>中部分日志重叠时，重叠部分和之后部分可能会有冲突，因此裁剪掉<code>unstable</code>的日志中在<code>after</code>及其之后的部分，并将给定日志追加到其后。</li>
</ol>
<p>另外，在<code>unstable</code>的<code>stableTo</code>方法裁剪完日志后，会调用<code>shrinkEntriesArray</code>方法优化空间利用率。即如果剩余日志条目小于用来保存日志的切片容量的一半时，将剩余的日志拷贝到容量恰好为剩余日志长度的新切片中，并释放对原切片的引用。需要注意的是，这里不能直接释放原切片的空间或在原切片上进行修改，因为程序的其它部分可能还持有对原切片的引用。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// shrinkEntriesArray discards the underlying array used by the entries slice
</span></span></span><span class="line"><span class="cl"><span class="c1">// if most of it isn&#39;t being used. This avoids holding references to a bunch of
</span></span></span><span class="line"><span class="cl"><span class="c1">// potentially large entries that aren&#39;t needed anymore. Simply clearing the
</span></span></span><span class="line"><span class="cl"><span class="c1">// entries wouldn&#39;t be safe because clients might still be using them.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">u</span> <span class="o">*</span><span class="nx">unstable</span><span class="p">)</span> <span class="nf">shrinkEntriesArray</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// We replace the array if we&#39;re using less than half of the space in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// it. This number is fairly arbitrary, chosen as an attempt to balance
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// memory usage vs number of allocations. It could probably be improved
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// with some focused tuning.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">const</span> <span class="nx">lenMultiple</span> <span class="p">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">u</span><span class="p">.</span><span class="nx">entries</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">u</span><span class="p">.</span><span class="nx">entries</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">u</span><span class="p">.</span><span class="nx">entries</span><span class="p">)</span><span class="o">*</span><span class="nx">lenMultiple</span> <span class="p">&lt;</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">u</span><span class="p">.</span><span class="nx">entries</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">newEntries</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">u</span><span class="p">.</span><span class="nx">entries</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nb">copy</span><span class="p">(</span><span class="nx">newEntries</span><span class="p">,</span> <span class="nx">u</span><span class="p">.</span><span class="nx">entries</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">u</span><span class="p">.</span><span class="nx">entries</span> <span class="p">=</span> <span class="nx">newEntries</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="24-raftlog的实现">2.4 raftLog的实现</h3>
<p>在介绍了<code>Storage</code>接口和<code>unstable</code>结构体后，接下来继续看<code>raftLog</code>的具体实现。<code>raftLog</code>结构体源码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">raftLog</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// storage contains all stable entries since the last snapshot.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">storage</span> <span class="nx">Storage</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// unstable contains all unstable entries and snapshot.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// they will be saved into storage.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">unstable</span> <span class="nx">unstable</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// committed is the highest log position that is known to be in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// stable storage on a quorum of nodes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">committed</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// applied is the highest log position that the application has
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// been instructed to apply to its state machine.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Invariant: applied &lt;= committed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">applied</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">logger</span> <span class="nx">Logger</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// maxNextEntsSize is the maximum number aggregate byte size of the messages
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// returned from calls to nextEnts.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">maxNextEntsSize</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>可以看到，<code>raftLog</code>由<code>Storage</code>接口实例<code>storage</code>和<code>unstable</code>结构体实例<code>unstable</code>组成。在<a href="#21-raftlog%e7%9a%84%e8%ae%be%e8%ae%a1" rel="">2.1节</a>提到的4个常用索引中，<code>committed</code>和<code>applied</code>索引是通过<code>raftLog</code>的字段实现的，而<code>firstIndex</code>和<code>lastIndex</code>是通过<code>raftLog</code>的方法实现的：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">raftLog</span><span class="p">)</span> <span class="nf">firstIndex</span><span class="p">()</span> <span class="kt">uint64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">unstable</span><span class="p">.</span><span class="nf">maybeFirstIndex</span><span class="p">();</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">i</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">index</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">storage</span><span class="p">.</span><span class="nf">FirstIndex</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// TODO(bdarnell)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">index</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">raftLog</span><span class="p">)</span> <span class="nf">lastIndex</span><span class="p">()</span> <span class="kt">uint64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">unstable</span><span class="p">.</span><span class="nf">maybeLastIndex</span><span class="p">();</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">i</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">i</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">storage</span><span class="p">.</span><span class="nf">LastIndex</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// TODO(bdarnell)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">i</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>firstIndex</code>和<code>lastIndex</code>的实现方式在<a href="#23-unstable%e7%9a%84%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%ae%9e%e7%8e%b0" rel="">2.3节</a>中已经介绍过，这里不再赘述。<code>raftLog</code>在创建时，会将<code>unstable</code>的<code>offset</code>置为<code>storage</code>的<em>last index + 1</em>，并将<code>committed</code>和<code>applied</code>置为<code>storage</code>的<em>forst index - 1</em>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// newLog returns log using the given storage and default options. It
</span></span></span><span class="line"><span class="cl"><span class="c1">// recovers the log to the state that it just commits and applies the
</span></span></span><span class="line"><span class="cl"><span class="c1">// latest snapshot.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">newLog</span><span class="p">(</span><span class="nx">storage</span> <span class="nx">Storage</span><span class="p">,</span> <span class="nx">logger</span> <span class="nx">Logger</span><span class="p">)</span> <span class="o">*</span><span class="nx">raftLog</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">newLogWithSize</span><span class="p">(</span><span class="nx">storage</span><span class="p">,</span> <span class="nx">logger</span><span class="p">,</span> <span class="nx">noLimit</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// newLogWithSize returns a log using the given storage and max
</span></span></span><span class="line"><span class="cl"><span class="c1">// message size.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">newLogWithSize</span><span class="p">(</span><span class="nx">storage</span> <span class="nx">Storage</span><span class="p">,</span> <span class="nx">logger</span> <span class="nx">Logger</span><span class="p">,</span> <span class="nx">maxNextEntsSize</span> <span class="kt">uint64</span><span class="p">)</span> <span class="o">*</span><span class="nx">raftLog</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">storage</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Panic</span><span class="p">(</span><span class="s">&#34;storage must not be nil&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">log</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">raftLog</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">storage</span><span class="p">:</span>         <span class="nx">storage</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">logger</span><span class="p">:</span>          <span class="nx">logger</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">maxNextEntsSize</span><span class="p">:</span> <span class="nx">maxNextEntsSize</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">firstIndex</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">storage</span><span class="p">.</span><span class="nf">FirstIndex</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// TODO(bdarnell)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">lastIndex</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">storage</span><span class="p">.</span><span class="nf">LastIndex</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// TODO(bdarnell)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">log</span><span class="p">.</span><span class="nx">unstable</span><span class="p">.</span><span class="nx">offset</span> <span class="p">=</span> <span class="nx">lastIndex</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="nx">log</span><span class="p">.</span><span class="nx">unstable</span><span class="p">.</span><span class="nx">logger</span> <span class="p">=</span> <span class="nx">logger</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Initialize our committed and applied pointers to the time of the last compaction.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">log</span><span class="p">.</span><span class="nx">committed</span> <span class="p">=</span> <span class="nx">firstIndex</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="nx">log</span><span class="p">.</span><span class="nx">applied</span> <span class="p">=</span> <span class="nx">firstIndex</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">log</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>raftLog</code>提供了如下的较为重要的方法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法<div style="width: 16em"></div></th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>maybeAppend(index, logTerm, committed uint64, ents ...pb.Entry)</code></td>
<td>尝试追加新日志，并更新<em>committed</em>索引（详见下文分析）。</td>
</tr>
<tr>
<td style="text-align:center"><code>unstableEntries() []pb.Entry</code></td>
<td>返回全部<code>unstable</code>中的日志条目。</td>
</tr>
<tr>
<td style="text-align:center"><code>nextEnts() (ents []pb.Entry)</code></td>
<td>返回可被应用到状态机的日志条目（已提交但还未应用），返回的长度受创建<code>raftLog</code>时指定的<code>maxNextEntsSize</code>限制。</td>
</tr>
<tr>
<td style="text-align:center"><code>hasNextEnts() bool</code></td>
<td>返回是否存在可被应用到状态机的日志。该方法不会调用<code>slice</code>方法，性能更高。</td>
</tr>
<tr>
<td style="text-align:center"><code>hasPendingSnapshot() bool</code></td>
<td>返回是否有未应用到状态机的快照（即<code>unstable</code>中保存的快照）。</td>
</tr>
<tr>
<td style="text-align:center"><code>commitTo(tocommit uint64)</code></td>
<td>更新<code>committed</code>索引，该方法会检查参数合法性。</td>
</tr>
<tr>
<td style="text-align:center"><code>appliedTo(i uint64)</code></td>
<td>更新<code>applied</code>索引，该方法会检查参数合法性。</td>
</tr>
<tr>
<td style="text-align:center"><code>stableTo(i, t uint64)</code></td>
<td>通知<code>unstable</code>当前已保存到稳定存储中最后的日志的index与term，让其适当裁剪日志。</td>
</tr>
<tr>
<td style="text-align:center"><code>stableSnapTo(i uint64)</code></td>
<td>通知<code>unstable</code>当前已保存到稳定存储中最后的快照的index，让其释放快照。</td>
</tr>
<tr>
<td style="text-align:center"><code>lastTerm() uint64</code></td>
<td>获取最后一条日志的term。</td>
</tr>
<tr>
<td style="text-align:center"><code>term(i uint64) (uint64, error)</code></td>
<td>获取给定index的日志条目的term。</td>
</tr>
<tr>
<td style="text-align:center"><code>entries(i, maxsize uint64) ([]pb.Entry, error)</code></td>
<td>获取index从<code>i</code>开始的最多<code>maxsize</code>条日志。</td>
</tr>
<tr>
<td style="text-align:center"><code>allEntries() []pb.Entry</code></td>
<td>获取全部日志条目。</td>
</tr>
<tr>
<td style="text-align:center"><code>isUpToDate(lasti, term uint64) bool</code></td>
<td>判断给定的term和index对应的日志条目是否至少与当前最后一个日志条目一样新。</td>
</tr>
<tr>
<td style="text-align:center"><code>matchTerm(i, term uint64) bool</code></td>
<td>判断给定的index与term是否日志中相应index的条目的term匹配。</td>
</tr>
<tr>
<td style="text-align:center"><code>maybeCommit(maxIndex, term uint64) bool</code></td>
<td>如果给定的index和term对应的日志条目还未被提交，将日志提交到给日志条目处并返回<code>true</code>，否则返回<code>false</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>restore(s pb.Snapshot)</code></td>
<td>将给定快照应用到（unstable）日志中。</td>
</tr>
<tr>
<td style="text-align:center"><code>slice(lo, hi, maxSize uint64) ([]pb.Entry, error)</code></td>
<td>返回index从<code>lo</code>到<code>hi</code>的最多<code>maxSize</code>条日志，该方法会检查参数是否合法。</td>
</tr>
</tbody>
</table>
<p><code>append</code>与<code>maybeAppend</code>是向<code>raftLog</code>写入日志的方法。二者的区别在于<code>append</code>不会检查给定的日志切片是否与已有日志有冲突，因此leader向<code>raftLog</code>中追加日志时会调用该函数；而<code>maybeAppend</code>会检查是否有冲突并找到冲突位置，并试图通过覆盖本地日志的方式解决冲突。但是，二者都会检查给定的日志起点是否在<code>committed</code>索引位置之前，如果在其之前，这违背了Raft算法的<strong>Log Matching</strong>性质，因此会引起panic（其实follower不会将<code>committed</code>之前的日志传给该函数，因此永远不会进入该分支）。源码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// maybeAppend returns (0, false) if the entries cannot be appended. Otherwise,
</span></span></span><span class="line"><span class="cl"><span class="c1">// it returns (last index of new entries, true).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">raftLog</span><span class="p">)</span> <span class="nf">maybeAppend</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="nx">logTerm</span><span class="p">,</span> <span class="nx">committed</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">ents</span> <span class="o">...</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span><span class="p">)</span> <span class="p">(</span><span class="nx">lastnewi</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">l</span><span class="p">.</span><span class="nf">matchTerm</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="nx">logTerm</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">lastnewi</span> <span class="p">=</span> <span class="nx">index</span> <span class="o">+</span> <span class="nb">uint64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">ents</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ci</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">findConflict</span><span class="p">(</span><span class="nx">ents</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">switch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">ci</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">ci</span> <span class="o">&lt;=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">committed</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nx">l</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Panicf</span><span class="p">(</span><span class="s">&#34;entry %d conflict with committed entry [committed(%d)]&#34;</span><span class="p">,</span> <span class="nx">ci</span><span class="p">,</span> <span class="nx">l</span><span class="p">.</span><span class="nx">committed</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nx">offset</span> <span class="o">:=</span> <span class="nx">index</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">			<span class="nx">l</span><span class="p">.</span><span class="nb">append</span><span class="p">(</span><span class="nx">ents</span><span class="p">[</span><span class="nx">ci</span><span class="o">-</span><span class="nx">offset</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">l</span><span class="p">.</span><span class="nf">commitTo</span><span class="p">(</span><span class="nf">min</span><span class="p">(</span><span class="nx">committed</span><span class="p">,</span> <span class="nx">lastnewi</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">lastnewi</span><span class="p">,</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">raftLog</span><span class="p">)</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ents</span> <span class="o">...</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span><span class="p">)</span> <span class="kt">uint64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ents</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">l</span><span class="p">.</span><span class="nf">lastIndex</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">after</span> <span class="o">:=</span> <span class="nx">ents</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">Index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">after</span> <span class="p">&lt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">committed</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">l</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Panicf</span><span class="p">(</span><span class="s">&#34;after(%d) is out of range [committed(%d)]&#34;</span><span class="p">,</span> <span class="nx">after</span><span class="p">,</span> <span class="nx">l</span><span class="p">.</span><span class="nx">committed</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">l</span><span class="p">.</span><span class="nx">unstable</span><span class="p">.</span><span class="nf">truncateAndAppend</span><span class="p">(</span><span class="nx">ents</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">l</span><span class="p">.</span><span class="nf">lastIndex</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>maybeAppend</code>方法会检查参数的合法性，当可以追加时，其会返回追加的最后一条日志的index与true，否则返回0与false。其需要的参数有这批日志的前一个日志条目的index与term（用于校验匹配）、leader最新确认的<code>committed</code>索引、和待追加的日志<code>ents</code>。</p>
<p>首先，<code>maybeAppend</code>方法会检查这批日志的前一个条目的index和这批日志的term与<code>raftLog</code>对应条目的index与term是否匹配，如果不匹配则返回(0, false)。如果匹配无误，其会调用<code>findConflict</code>方法寻找待追加的日志与已有日志的第一个冲突条目的index或第一条新日志的index。在进一步分析前，先看一下<code>findConflict</code>的实现方式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// findConflict finds the index of the conflict.
</span></span></span><span class="line"><span class="cl"><span class="c1">// It returns the first pair of conflicting entries between the existing
</span></span></span><span class="line"><span class="cl"><span class="c1">// entries and the given entries, if there are any.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If there is no conflicting entries, and the existing entries contains
</span></span></span><span class="line"><span class="cl"><span class="c1">// all the given entries, zero will be returned.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If there is no conflicting entries, but the given entries contains new
</span></span></span><span class="line"><span class="cl"><span class="c1">// entries, the index of the first new entry will be returned.
</span></span></span><span class="line"><span class="cl"><span class="c1">// An entry is considered to be conflicting if it has the same index but
</span></span></span><span class="line"><span class="cl"><span class="c1">// a different term.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The first entry MUST have an index equal to the argument &#39;from&#39;.
</span></span></span><span class="line"><span class="cl"><span class="c1">// The index of the given entries MUST be continuously increasing.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">raftLog</span><span class="p">)</span> <span class="nf">findConflict</span><span class="p">(</span><span class="nx">ents</span> <span class="p">[]</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span><span class="p">)</span> <span class="kt">uint64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ne</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ents</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">!</span><span class="nx">l</span><span class="p">.</span><span class="nf">matchTerm</span><span class="p">(</span><span class="nx">ne</span><span class="p">.</span><span class="nx">Index</span><span class="p">,</span> <span class="nx">ne</span><span class="p">.</span><span class="nx">Term</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">ne</span><span class="p">.</span><span class="nx">Index</span> <span class="o">&lt;=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">lastIndex</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">l</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;found conflict at index %d [existing term: %d, conflicting term: %d]&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">					<span class="nx">ne</span><span class="p">.</span><span class="nx">Index</span><span class="p">,</span> <span class="nx">l</span><span class="p">.</span><span class="nf">zeroTermOnErrCompacted</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nf">term</span><span class="p">(</span><span class="nx">ne</span><span class="p">.</span><span class="nx">Index</span><span class="p">)),</span> <span class="nx">ne</span><span class="p">.</span><span class="nx">Term</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">ne</span><span class="p">.</span><span class="nx">Index</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>findConflict</code>返回的情况可以分为3种：</p>
<ol>
<li>如果给定的日志与已有的日志的index和term冲突，其会返回第一条冲突的日志条目的index。</li>
<li>如果没有冲突，且给定的日志的所有条目均已在已有日志中，返回0.</li>
<li>如果没有冲突，且给定的日志中包含已有日志中没有的新日志，返回第一条新日志的index。</li>
</ol>
<p><code>maybeAppend</code>会根据<code>findConflict</code>的返回值确定接下来的处理方式：</p>
<ol>
<li>如果返回0，说明既没有冲突又没有新日志，直接进行下一步处理。</li>
<li>如果返回值小于当前的<code>committed</code>索引，说明<code>committed</code>前的日志发生了冲突，这违背了Raft算法保证的<strong>Log Matching</strong>性质，因此会引起panic。</li>
<li>如果返回值大于<code>committed</code>，既可能是冲突发生在<code>committed</code>之后，也可能是有新日志，但二者的处理方式都是相同的，即从将从冲突处或新日志处开始的日志覆盖或追加到当前日志中即可。</li>
</ol>
<p>除了会引起panic的情况外，该方法接下来会调用<code>commitTo</code>方法，更新当前的<code>committed</code>索引为给定的新日志中最后一条日志的index（<code>lastnewi</code>）和传入的新的<code>committed</code>中较小的一个。<code>commitTo</code>方法保证了<code>committed</code>索引只会前进而不会回退，而使用<code>lastnewi</code>和传入的<code>committed</code>中的最小值则是因为传入的数据可能有如下两种情况：</p>
<ol>
<li>leader给follower复制日志时，如果复制的日志条目超过了单个消息的上限，则可能出现leader传给follower的<code>committed</code>值大于该follower复制完这条消息中的日志后的最大index。此时，该follower的新<code>committed</code>值为<code>lastnewi</code>。</li>
<li>follower能够跟上leader，leader传给follower的日志中有未确认被法定数量节点稳定存储的日志，此时传入的<code>committed</code>比<code>lastnewi</code>小，该follower的新<code>committed</code>值为传入的<code>committed</code>值。</li>
</ol>
<p><code>raftLog</code>的<code>slice</code>方法是会返回指定的日志片段，该方法会检查给定的范围是否可以访问。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// slice returns a slice of log entries from lo through hi-1, inclusive.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">raftLog</span><span class="p">)</span> <span class="nf">slice</span><span class="p">(</span><span class="nx">lo</span><span class="p">,</span> <span class="nx">hi</span><span class="p">,</span> <span class="nx">maxSize</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">([]</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">mustCheckOutOfBounds</span><span class="p">(</span><span class="nx">lo</span><span class="p">,</span> <span class="nx">hi</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">lo</span> <span class="o">==</span> <span class="nx">hi</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">ents</span> <span class="p">[]</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">lo</span> <span class="p">&lt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">unstable</span><span class="p">.</span><span class="nx">offset</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">storedEnts</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">storage</span><span class="p">.</span><span class="nf">Entries</span><span class="p">(</span><span class="nx">lo</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="nx">hi</span><span class="p">,</span> <span class="nx">l</span><span class="p">.</span><span class="nx">unstable</span><span class="p">.</span><span class="nx">offset</span><span class="p">),</span> <span class="nx">maxSize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">ErrCompacted</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">ErrUnavailable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">l</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Panicf</span><span class="p">(</span><span class="s">&#34;entries[%d:%d) is unavailable from storage&#34;</span><span class="p">,</span> <span class="nx">lo</span><span class="p">,</span> <span class="nf">min</span><span class="p">(</span><span class="nx">hi</span><span class="p">,</span> <span class="nx">l</span><span class="p">.</span><span class="nx">unstable</span><span class="p">.</span><span class="nx">offset</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// TODO(bdarnell)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// check if ents has reached the size limitation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nb">uint64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">storedEnts</span><span class="p">))</span> <span class="p">&lt;</span> <span class="nf">min</span><span class="p">(</span><span class="nx">hi</span><span class="p">,</span> <span class="nx">l</span><span class="p">.</span><span class="nx">unstable</span><span class="p">.</span><span class="nx">offset</span><span class="p">)</span><span class="o">-</span><span class="nx">lo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">storedEnts</span><span class="p">,</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">ents</span> <span class="p">=</span> <span class="nx">storedEnts</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">hi</span> <span class="p">&gt;</span> <span class="nx">l</span><span class="p">.</span><span class="nx">unstable</span><span class="p">.</span><span class="nx">offset</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">unstable</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nx">unstable</span><span class="p">.</span><span class="nf">slice</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="nx">lo</span><span class="p">,</span> <span class="nx">l</span><span class="p">.</span><span class="nx">unstable</span><span class="p">.</span><span class="nx">offset</span><span class="p">),</span> <span class="nx">hi</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ents</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">combined</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ents</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nx">unstable</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="nx">n</span> <span class="o">:=</span> <span class="nb">copy</span><span class="p">(</span><span class="nx">combined</span><span class="p">,</span> <span class="nx">ents</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nb">copy</span><span class="p">(</span><span class="nx">combined</span><span class="p">[</span><span class="nx">n</span><span class="p">:],</span> <span class="nx">unstable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">ents</span> <span class="p">=</span> <span class="nx">combined</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">ents</span> <span class="p">=</span> <span class="nx">unstable</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nf">limitSize</span><span class="p">(</span><span class="nx">ents</span><span class="p">,</span> <span class="nx">maxSize</span><span class="p">),</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在获取<code>raftLog</code>中的日志切片时，该方法首先会通过<code>mustCheckOutOfBounds</code>方法检查给定的范围是否越界。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// l.firstIndex &lt;= lo &lt;= hi &lt;= l.firstIndex + len(l.entries)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">raftLog</span><span class="p">)</span> <span class="nf">mustCheckOutOfBounds</span><span class="p">(</span><span class="nx">lo</span><span class="p">,</span> <span class="nx">hi</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">lo</span> <span class="p">&gt;</span> <span class="nx">hi</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">l</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Panicf</span><span class="p">(</span><span class="s">&#34;invalid slice %d &gt; %d&#34;</span><span class="p">,</span> <span class="nx">lo</span><span class="p">,</span> <span class="nx">hi</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fi</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">firstIndex</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">lo</span> <span class="p">&lt;</span> <span class="nx">fi</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">ErrCompacted</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">length</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">lastIndex</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="nx">fi</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">hi</span> <span class="p">&gt;</span> <span class="nx">fi</span><span class="o">+</span><span class="nx">length</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">l</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Panicf</span><span class="p">(</span><span class="s">&#34;slice[%d,%d) out of bound [%d,%d]&#34;</span><span class="p">,</span> <span class="nx">lo</span><span class="p">,</span> <span class="nx">hi</span><span class="p">,</span> <span class="nx">fi</span><span class="p">,</span> <span class="nx">l</span><span class="p">.</span><span class="nf">lastIndex</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>mustCheckOutOfBounds</code>检查了如下几个方面：</p>
<ol>
<li>是否满足$lo \le hi$。（<code>slice</code>获取的是左闭右开区间$[lo,hi)$的日志切片。）</li>
<li>是否满足$lo \ge firstIndex$，否则该范围中部分日志已被压缩，无法获取。</li>
<li>是否满足$hi \le lastIndex+1$，否则该范围中部分日志还没被追加到当前节点的日志中，无法获取。</li>
</ol>
<p>当<code>slice</code>确保给定范围没有越界后，如果这段范围跨了stable和unstable两部分，那么该方法会分别从<code>Storage</code>获取$[lo,\text{unstable.offset})$、从<code>unstable</code>获取$[\text{unstable.offset},hi)$；否则直接从其中一部分获取完整的切片。在返回切片前，<code>silce</code>还会按照<code>maxSize</code>参数限制返回的切片长度。</p>
<h2 id="3-复制进度跟踪">3. 复制进度跟踪</h2>
<p>在《In Search of an Understandable Consensus Algorithm (Extended Version)》中，leader只通过 <em>nextInext[]</em> 和 <em>matchIndex[]</em> 来跟踪follower的日志进度。而etcd/raft为了解耦不同情况下的日志复制逻辑并实现一些日志复制相关的优化，还需要记录一些其它信息。因此，etcd/raft中leader使用<code>Progress</code>结构体来跟踪每个follower（和learner）的日志复制进度。</p>
<h3 id="31-progress结构体">3.1 Progress结构体</h3>
<p><code>Progess</code>结构体是leader用来跟踪follower日志复制进度的结构，即“表示从leader视角看到的follower的进度”。leader会为每个follower（和learner）维护各自的<code>Progress</code>结构。官方提供了<code>Progress</code>的<a href="https://github.com/etcd-io/etcd/blob/master/raft/design.md" target="_blank" rel="noopener noreffer">设计文档</a>，该文档简单介绍了其设计与功能。</p>
<p><code>Progress</code>的结构如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Progress represents a follower’s progress in the view of the leader. Leader
</span></span></span><span class="line"><span class="cl"><span class="c1">// maintains progresses of all followers, and sends entries to the follower
</span></span></span><span class="line"><span class="cl"><span class="c1">// based on its progress.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// NB(tbg): Progress is basically a state machine whose transitions are mostly
</span></span></span><span class="line"><span class="cl"><span class="c1">// strewn around `*raft.raft`. Additionally, some fields are only used when in a
</span></span></span><span class="line"><span class="cl"><span class="c1">// certain State. All of this isn&#39;t ideal.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Progress</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Match</span><span class="p">,</span> <span class="nx">Next</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// State defines how the leader should interact with the follower.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// When in StateProbe, leader sends at most one replication message
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// per heartbeat interval. It also probes actual progress of the follower.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// When in StateReplicate, leader optimistically increases next
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// to the latest entry sent after sending replication message. This is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// an optimized state for fast replicating log entries to the follower.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// When in StateSnapshot, leader should have sent out snapshot
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// before and stops sending any replication message.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">State</span> <span class="nx">StateType</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// PendingSnapshot is used in StateSnapshot.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// If there is a pending snapshot, the pendingSnapshot will be set to the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// index of the snapshot. If pendingSnapshot is set, the replication process of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// this Progress will be paused. raft will not resend snapshot until the pending one
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// is reported to be failed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">PendingSnapshot</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// RecentActive is true if the progress is recently active. Receiving any messages
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// from the corresponding follower indicates the progress is active.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// RecentActive can be reset to false after an election timeout.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// TODO(tbg): the leader should always have this set to true.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">RecentActive</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// ProbeSent is used while this follower is in StateProbe. When ProbeSent is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// true, raft should pause sending replication message to this peer until
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ProbeSent is reset. See ProbeAcked() and IsPaused().
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">ProbeSent</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Inflights is a sliding window for the inflight messages.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Each inflight message contains one or more log entries.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// The max number of entries per message is defined in raft config as MaxSizePerMsg.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Thus inflight effectively limits both the number of inflight messages
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// and the bandwidth each Progress can use.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// When inflights is Full, no more message should be sent.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// When a leader sends out a message, the index of the last
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// entry should be added to inflights. The index MUST be added
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// into inflights in order.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// When a leader receives a reply, the previous inflights should
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// be freed by calling inflights.FreeLE with the index of the last
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// received entry.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Inflights</span> <span class="o">*</span><span class="nx">Inflights</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// IsLearner is true if this progress is tracked for a learner.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">IsLearner</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>Progress</code>中有两个重要的索引：<code>match</code>与<code>next</code>。<code>match</code>表示leader所知的该follower的日志中匹配的日志条目的最高index，如果leader不知道该follower的日志状态时，<code>match</code>为0；<code>next</code>表示leader接下来要给该follower发送的日志的第一个条目的index。根据Raft算法论文，<code>next</code>是可能因异常回退的，而<code>match</code>是单调递增的。<code>next</code>小于<code>match</code>的节点会被认为是落后的节点。</p>
<p><code>Progress</code>的一些常用的方法如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法<div style="width: 14em"></div></th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>ResetState(state StateType)</code></td>
<td>重置状态为目标状态，该方法会清空所有状态记录的数据。该方法由<code>BecomeXXX</code>方法调用。</td>
</tr>
<tr>
<td style="text-align:center"><code>BecomeProbe()</code></td>
<td>将follower转为Probe状态。</td>
</tr>
<tr>
<td style="text-align:center"><code>BecomeReplicate()</code></td>
<td>将follower转为Replicate状态。</td>
</tr>
<tr>
<td style="text-align:center"><code>BecomeSnapshot(snapshoti uint64)</code></td>
<td>将follower转为Snapshot状态，并指定需要为其发送的快照的index。</td>
</tr>
<tr>
<td style="text-align:center"><code>MaybeUpdate(n uint64) bool</code></td>
<td>用于更新follower的进度（<em>match index</em>），如果传入的进度比当前进度旧，则不会更新进度并返回false，该方法还会根据传入的进度更新<em>next index</em>。leader会在收到来自follower的<code>MsgAppResp</code>消息时调用该方法。</td>
</tr>
<tr>
<td style="text-align:center"><code>OptimisticUpdate(n uint64)</code></td>
<td>不做检查直接更新<em>next index</em>，用于<code>StateReplicate</code>状态下日志复制流水线优化。</td>
</tr>
<tr>
<td style="text-align:center"><code>MaybeDecrTo(rejected, last uint64) bool</code></td>
<td>用于回退<em>next index</em>，该方法会根据参数判断是否需要回退，如果参数是来自过期的消息，那么不会回退。如果回退，则会返回true。</td>
</tr>
<tr>
<td style="text-align:center"><code>IsPaused() bool</code></td>
<td>判断为该follower发送消息的发送窗口是否阻塞，发送窗口大小与该follower的状态和<code>Raft</code>的配置有关。</td>
</tr>
</tbody>
</table>
<p>以上的很多方法都与follower的状态有关，因此这里先介绍<code>Progress</code>中规定的3中follower状态。</p>
<h3 id="32-follower的3种状态">3.2 follower的3种状态</h3>
<p>为了更加清晰地处理leader为follower复制日志的各种情况，etcd/raft将leader向follower复制日志的行为分成三种，记录在<code>Progress</code>的<code>State</code>字段中：</p>
<ol>
<li><code>StateProbe</code>：当leader刚刚当选时，或当follower拒绝了leader复制的日志时，该follower的进度状态会变为<code>StateProbe</code>类型。在该状态下，leader每次心跳期间仅为follower发送一条<code>MsgApp</code>消息，且leader会根据follower发送的相应的<code>MsgAppResp</code>消息调整该follower的进度。</li>
<li><code>StateReplicate</code>：该状态下的follower处于稳定状态，leader会优化为其复制日志的速度，每次可能发送多条<code>MsgApp</code>消息（受<code>Progress</code>的流控限制，后文会详细介绍）。</li>
<li><code>StateSnapshot</code>：当follower所需的日志已被压缩无法访问时，leader会将该follower的进度置为<code>StateSnapshot</code>状态，并向该follower发送快照。leader不会为处于<code>StateSnapshot</code>状态的follower发送任何的<code>MsgApp</code>消息，直到其成功收到快照。</li>
</ol>
<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>提示<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">每条<code>MsgApp</code>消息可以包含多个日志条目。</div>
        </div>
    </div>
<p><code>Progress</code>中的<code>PendingSnapshot</code>、<code>ProbeSent</code>字段是<code>StateProebe</code>和<code>StateSnapshot</code>状态下需要记录的字段，后文会详细讲解。</p>
<p><code>Progress</code>中的<code>RecentActive</code>字段用来标识该follower最近是否是“活跃”的。该字段除了用于<strong>Check Quorum</strong>外（详见<a href="/posts/code-reading/etcdraft-made-simple/3-election/" rel="">深入浅出etcd/raft —— 0x03 Raft选举</a>），在日志复制时，leader不会将不活跃的follower转为<code>StateSnapshot</code>状态或发送快照。（这是为了修复<a href="https://github.com/etcd-io/etcd/issues/3778" target="_blank" rel="noopener noreffer">issue#3378</a>中提到的问题，感兴趣的读者可以查看该issue和<a href="https://github.com/etcd-io/etcd/issues/3778" target="_blank" rel="noopener noreffer">issue#3976</a>）。</p>
<p><code>Progress</code>的<code>Inflights</code>字段是对日志复制操作进行流控的字段。虽然<code>Config</code>的<code>MaxSizePerMsg</code>字段限制了每条<code>MsgApp</code>消息的字节数，但是在<code>StateReplicate</code>状态下优化日志复制时，每次可能会发送多条<code>MsgApp</code>消息。因此，<code>Config</code>中又加入了<code>MaxInflightMsgs</code>字段来限制每次发送的<code>MsgApp</code>消息数。<code>Inflights</code>实现了<code>MaxInflightMsgs</code>字段配置的流控。</p>
<p><code>Inflights</code>结构体实现了一个动态扩容的FIFO队列，其中记录了每条<code>MsgApp</code>的<code>Index</code>字段的值，以在收到<code>MsgAppResp</code>的ack时释放队列。<code>Inflights</code>的实现也比较简单，感兴趣的读者可以自行阅读源码学习其实现，这里不再赘述。</p>
<p><code>Progress</code>的三种状态看做是不同大小的<code>Inflights</code>下的行为（其实并不是这样实现的）:</p>
<ol>
<li><code>StateProbe</code> =&gt; <code>Inflight.size = 1</code></li>
<li><code>StateReplicate</code> =&gt; <code>Inflight.size = MaxInflightMsgs</code></li>
<li><code>StateSnapshot</code> =&gt; <code>Inflight.size = 0</code></li>
</ol>
<p>从<code>IsPaused</code>方法中看到类似的逻辑：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// IsPaused returns whether sending log entries to this node has been throttled.
</span></span></span><span class="line"><span class="cl"><span class="c1">// This is done when a node has rejected recent MsgApps, is currently waiting
</span></span></span><span class="line"><span class="cl"><span class="c1">// for a snapshot, or has reached the MaxInflightMsgs limit. In normal
</span></span></span><span class="line"><span class="cl"><span class="c1">// operation, this is false. A throttled node will be contacted less frequently
</span></span></span><span class="line"><span class="cl"><span class="c1">// until it has reached a state in which it&#39;s able to accept a steady stream of
</span></span></span><span class="line"><span class="cl"><span class="c1">// log entries again.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">pr</span> <span class="o">*</span><span class="nx">Progress</span><span class="p">)</span> <span class="nf">IsPaused</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">State</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">StateProbe</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">ProbeSent</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">StateReplicate</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">Inflights</span><span class="p">.</span><span class="nf">Full</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">StateSnapshot</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;unexpected state&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="33-状态转换与更新回退">3.3 状态转换与更新回退</h3>
<p>在进一步分析etcd/raft的日志复制实现时，需要先简单了解<code>BecomeXXX</code>在进行状态转换时的做的操作及更新进度、回退进度的操作。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// BecomeProbe transitions into StateProbe. Next is reset to Match+1 or,
</span></span></span><span class="line"><span class="cl"><span class="c1">// optionally and if larger, the index of the pending snapshot.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">pr</span> <span class="o">*</span><span class="nx">Progress</span><span class="p">)</span> <span class="nf">BecomeProbe</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// If the original state is StateSnapshot, progress knows that
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// the pending snapshot has been sent to this peer successfully, then
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// probes from pendingSnapshot + 1.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">State</span> <span class="o">==</span> <span class="nx">StateSnapshot</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">pendingSnapshot</span> <span class="o">:=</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">PendingSnapshot</span>
</span></span><span class="line"><span class="cl">		<span class="nx">pr</span><span class="p">.</span><span class="nf">ResetState</span><span class="p">(</span><span class="nx">StateProbe</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">pr</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">pr</span><span class="p">.</span><span class="nx">Match</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">pendingSnapshot</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">pr</span><span class="p">.</span><span class="nf">ResetState</span><span class="p">(</span><span class="nx">StateProbe</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">pr</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">Match</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>BecomeProbe</code>分为两种情况，一种是从<code>StateSnapshot</code>进入<code>StateProbe</code>状态，当leader得知follower成功应用了快照后，需要调用<code>Node</code>的<code>ReportSnapshot</code>方法，该方法会调用<code>BecomeProbe</code>将该follower的进度状态转为<code>StateProbe</code>。此时，可以将<em>next index</em>置为该快照的index的下一条。在一般情况下，则从<em>match index</em>处开始检测冲突（<code>Next</code>是下一条应为该follower发送的日志的index，因此应为当前认为的最后一条匹配日志的index+1）。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// BecomeReplicate transitions into StateReplicate, resetting Next to Match+1.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">pr</span> <span class="o">*</span><span class="nx">Progress</span><span class="p">)</span> <span class="nf">BecomeReplicate</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">pr</span><span class="p">.</span><span class="nf">ResetState</span><span class="p">(</span><span class="nx">StateReplicate</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">pr</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">Match</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// BecomeSnapshot moves the Progress to StateSnapshot with the specified pending
</span></span></span><span class="line"><span class="cl"><span class="c1">// snapshot index.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">pr</span> <span class="o">*</span><span class="nx">Progress</span><span class="p">)</span> <span class="nf">BecomeSnapshot</span><span class="p">(</span><span class="nx">snapshoti</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">pr</span><span class="p">.</span><span class="nf">ResetState</span><span class="p">(</span><span class="nx">StateSnapshot</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">pr</span><span class="p">.</span><span class="nx">PendingSnapshot</span> <span class="p">=</span> <span class="nx">snapshoti</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>BecomeReplicate</code>和<code>BecomeSnapshot</code>逻辑都很简单，在重置状态后，二者分别设置了相应的<em>next index</em>和正在发送的快照的index。</p>
<p>接下来分析更新<em>match index</em>和<em>next index</em>与回退<em>next index</em>的相关逻辑：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// MaybeUpdate is called when an MsgAppResp arrives from the follower, with the
</span></span></span><span class="line"><span class="cl"><span class="c1">// index acked by it. The method returns false if the given n index comes from
</span></span></span><span class="line"><span class="cl"><span class="c1">// an outdated message. Otherwise it updates the progress and returns true.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">pr</span> <span class="o">*</span><span class="nx">Progress</span><span class="p">)</span> <span class="nf">MaybeUpdate</span><span class="p">(</span><span class="nx">n</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">updated</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">Match</span> <span class="p">&lt;</span> <span class="nx">n</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">pr</span><span class="p">.</span><span class="nx">Match</span> <span class="p">=</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl">		<span class="nx">updated</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">		<span class="nx">pr</span><span class="p">.</span><span class="nf">ProbeAcked</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">pr</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nx">pr</span><span class="p">.</span><span class="nx">Next</span><span class="p">,</span> <span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">updated</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// OptimisticUpdate signals that appends all the way up to and including index n
</span></span></span><span class="line"><span class="cl"><span class="c1">// are in-flight. As a result, Next is increased to n+1.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">pr</span> <span class="o">*</span><span class="nx">Progress</span><span class="p">)</span> <span class="nf">OptimisticUpdate</span><span class="p">(</span><span class="nx">n</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">{</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
</span></span></code></pre></div><p><code>MaybeUpdate</code>会根据传入的index更新<code>Match</code>和<code>Next</code>到更高的值，如果<code>Match</code>更新，则会返回true，同时立刻对<code>StateProbe</code>状态的follower进行确认，否则返回false。其调用者会根据返回值判断该follower是否跟上了复制进度。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// MaybeDecrTo adjusts the Progress to the receipt of a MsgApp rejection. The
</span></span></span><span class="line"><span class="cl"><span class="c1">// arguments are the index the follower rejected to append to its log, and its
</span></span></span><span class="line"><span class="cl"><span class="c1">// last index.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Rejections can happen spuriously as messages are sent out of order or
</span></span></span><span class="line"><span class="cl"><span class="c1">// duplicated. In such cases, the rejection pertains to an index that the
</span></span></span><span class="line"><span class="cl"><span class="c1">// Progress already knows were previously acknowledged, and false is returned
</span></span></span><span class="line"><span class="cl"><span class="c1">// without changing the Progress.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// If the rejection is genuine, Next is lowered sensibly, and the Progress is
</span></span></span><span class="line"><span class="cl"><span class="c1">// cleared for sending log entries.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">pr</span> <span class="o">*</span><span class="nx">Progress</span><span class="p">)</span> <span class="nf">MaybeDecrTo</span><span class="p">(</span><span class="nx">rejected</span><span class="p">,</span> <span class="nx">last</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">State</span> <span class="o">==</span> <span class="nx">StateReplicate</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// The rejection must be stale if the progress has matched and &#34;rejected&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// is smaller than &#34;match&#34;.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">rejected</span> <span class="o">&lt;=</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">Match</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Directly decrease next to match + 1.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// TODO(tbg): why not use last if it&#39;s larger?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">pr</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">Match</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// The rejection must be stale if &#34;rejected&#34; does not match next - 1. This
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// is because non-replicating followers are probed one entry at a time.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">Next</span><span class="o">-</span><span class="mi">1</span> <span class="o">!=</span> <span class="nx">rejected</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">pr</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nf">max</span><span class="p">(</span><span class="nf">min</span><span class="p">(</span><span class="nx">rejected</span><span class="p">,</span> <span class="nx">last</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">pr</span><span class="p">.</span><span class="nx">ProbeSent</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>MaybeDecrTo</code>的参数有follower拒绝的<code>MsgApp</code>请求的index（<code>rejected</code>，即<code>MsgApp</code>或<code>MsgAppResp</code>的<code>Index</code>）和该follower最后一条日志的索引（<code>last</code>，即<code>MsgAppResp</code>的<code>RejectHint</code>）。其中，<code>rejected</code>参数是用来判断该消息是否是过期的消息的，其判断逻辑如下：</p>
<ul>
<li>如果follower的状态为<code>StateReplicate</code>，<code>Next</code>应该是跟上<code>Match</code>的进度的，那么如果<code>rejected</code>不大于<code>Match</code>，那么该消息过期。</li>
<li>在其它状态下，<code>Next</code>可能没有跟上<code>Match</code>的进度，因此不能通过<code>Match</code>判断。由于其它状态下至多只会为其发送一条日志复制请求，因此只要<code>rejected</code>不等于<code>Next-1</code>，该消息就是过期的。</li>
</ul>
<p><code>MaybeDecrTo</code>不会对过期的消息进行处理。否则，将回退<code>Next</code>。<code>Next</code>的回退有两种方案：</p>
<ul>
<li>回退一条日志。即新的<code>Next</code>为上一条<code>Next-1</code>，这里的<code>Next-1</code>即为发送<code>MsgApp</code>时用于日志匹配的<code>Index</code>字段的值，也是<code>rejected</code>的值。</li>
<li>快速回退，回退到该follower的最后一条日志。即新的<code>Next</code>为该follower最后一条日志的后一条日志的index，即<code>last+1</code>。</li>
</ul>
<h2 id="4-etcdraft中日志复制实现">4. etcd/raft中日志复制实现</h2>
<h3 id="41-节点启动时日志处理">4.1 节点启动时日志处理</h3>
<p>在节点启动时，日志的<em>last index</em>就是稳定存储<code>Storage</code>的<em>last index</em>。follower和candidate不需要对日志进行额外的处理，而leader需要获取每个follower（和learner）的进度，并以当前term提交一条空日志条目，以提交之前term的日志（详见《In Search of an Understandable Consensus Algorithm (Extended Version)》中<em>5.4.2 Committing entries from previous terms</em>）。同样，当新leader当选时，也需要做同样的操作。如下是<code>becomeLeader</code>与<code>reset</code>中与日志复制有关的源码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">raft</span><span class="p">)</span> <span class="nf">becomeLeader</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">r</span><span class="p">.</span><span class="nf">reset</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Term</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Followers enter replicate mode when they&#39;ve been successfully probed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// (perhaps after having received a snapshot as a result). The leader is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// trivially in this state. Note that r.reset() has initialized this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// progress with the last index already.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">r</span><span class="p">.</span><span class="nx">prs</span><span class="p">.</span><span class="nx">Progress</span><span class="p">[</span><span class="nx">r</span><span class="p">.</span><span class="nx">id</span><span class="p">].</span><span class="nf">BecomeReplicate</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">emptyEnt</span> <span class="o">:=</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span><span class="p">{</span><span class="nx">Data</span><span class="p">:</span> <span class="kc">nil</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">!</span><span class="nx">r</span><span class="p">.</span><span class="nf">appendEntry</span><span class="p">(</span><span class="nx">emptyEnt</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// This won&#39;t happen because we just called reset() above.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">r</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Panic</span><span class="p">(</span><span class="s">&#34;empty entry was dropped&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// As a special case, don&#39;t count the initial empty entry towards the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// uncommitted log quote. This is because we want to preserve the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// behavior of allowing one entry larger than quote if the current
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// usage is zero.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">r</span><span class="p">.</span><span class="nf">reduceUncommittedSize</span><span class="p">([]</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span><span class="p">{</span><span class="nx">emptyEnt</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;%x became leader at term %d&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Term</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">raft</span><span class="p">)</span> <span class="nf">reset</span><span class="p">(</span><span class="nx">term</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">r</span><span class="p">.</span><span class="nx">prs</span><span class="p">.</span><span class="nf">ResetVotes</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nx">prs</span><span class="p">.</span><span class="nf">Visit</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">id</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">pr</span> <span class="o">*</span><span class="nx">tracker</span><span class="p">.</span><span class="nx">Progress</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="o">*</span><span class="nx">pr</span> <span class="p">=</span> <span class="nx">tracker</span><span class="p">.</span><span class="nx">Progress</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">Match</span><span class="p">:</span>     <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">Next</span><span class="p">:</span>      <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">lastIndex</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">Inflights</span><span class="p">:</span> <span class="nx">tracker</span><span class="p">.</span><span class="nf">NewInflights</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">prs</span><span class="p">.</span><span class="nx">MaxInflight</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">			<span class="nx">IsLearner</span><span class="p">:</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">IsLearner</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">id</span> <span class="o">==</span> <span class="nx">r</span><span class="p">.</span><span class="nx">id</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">pr</span><span class="p">.</span><span class="nx">Match</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">lastIndex</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>在<code>becomeLeader</code>调用<code>reset</code>方法时，会初始化所有节点的<em>next index</em>为leader日志的<em>last index + 1</em>。因为leader刚当选时不知道除了自己之外的节点的复制进度，将除自己外的所有节点的<em>match index</em>置为0，而将自己的<em>match index</em>置为自己的<em>last index</em>。</p>
<p>随后，leader会在当前term为自己的日志追加一条空日志条目，以提交之前term的日志（详见《In Search of an Understandable Consensus Algorithm (Extended Version)》中<em>5.4.2 Committing entries from previous terms</em>）。</p>
<p>在将控日志条目加入到日志后，有一行<code>r.reduceUncommittedSize([]pb.Entry{emptyEnt})</code>代码。想了解这样代码的作用，需要先了解etcd/raft中避免新日志过多无法处理速度跟不上的机制。</p>
<p>在<code>Config</code>中，可以看到如下的一条配置：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// MaxUncommittedEntriesSize limits the aggregate byte size of the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// uncommitted entries that may be appended to a leader&#39;s log. Once this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// limit is exceeded, proposals will begin to return ErrProposalDropped
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// errors. Note: 0 for no limit.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">MaxUncommittedEntriesSize</span> <span class="kt">uint64</span>
</span></span></code></pre></div><p>该配置用于限制leader日志中未提交日志的最大字节数，如果超过该值则丢弃新提议，以避免新日志过多处理速度跟不上。当该值为0时，表示不设限制。etcd/raft是以如下方式实现该约束的：</p>
<ul>
<li>在leader调用<code>appendEntry</code>方法向日志追加新条目时，<code>appendEntry</code>方法会调用<code>increaseUncommittedSize(ents []pb.Entry) bool</code>方法，该方法会根据配置与<code>raft</code>结构体中的<code>uncommittedSize</code>字段判断追加后会不会超过<code>MaxUncommittedEntriesSize</code>的限制，如果超过了该限制，会返回false，<code>appendEntry</code>方法会拒绝这些提议，如果没有超过限制，则仅增大<code>uncommittedSize</code>字段字段并返回true。需要注意的是，当<code>uncommittedSize</code>字段为0时不会拒绝提议，以保证leader不会因单条较大的<code>MsgProp</code>消息阻塞；同样该方法也不会拒绝空日志条目，因为其常用于新当选的leader提交之前的term的日志或离开<em>joint configuration</em>。</li>
<li>在etcd/raft的使用者调用<code>Node</code>的<code>Advance</code>方法时，会调用<code>reduceUncommittedSize(ents []pb.Entry)</code>方法，以释放流控容量。</li>
</ul>
<p><code>increaseUncommittedSize</code>和<code>reduceUncommittedSize</code>的源码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// increaseUncommittedSize computes the size of the proposed entries and
</span></span></span><span class="line"><span class="cl"><span class="c1">// determines whether they would push leader over its maxUncommittedSize limit.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If the new entries would exceed the limit, the method returns false. If not,
</span></span></span><span class="line"><span class="cl"><span class="c1">// the increase in uncommitted entry size is recorded and the method returns
</span></span></span><span class="line"><span class="cl"><span class="c1">// true.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// Empty payloads are never refused. This is used both for appending an empty
</span></span></span><span class="line"><span class="cl"><span class="c1">// entry at a new leader&#39;s term, as well as leaving a joint configuration.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">raft</span><span class="p">)</span> <span class="nf">increaseUncommittedSize</span><span class="p">(</span><span class="nx">ents</span> <span class="p">[]</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">s</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ents</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nf">PayloadSize</span><span class="p">(</span><span class="nx">e</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">uncommittedSize</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">uncommittedSize</span><span class="o">+</span><span class="nx">s</span> <span class="p">&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">maxUncommittedSize</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// If the uncommitted tail of the Raft log is empty, allow any size
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// proposal. Otherwise, limit the size of the uncommitted tail of the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// log and drop any proposal that would push the size over the limit.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Note the added requirement s&gt;0 which is used to make sure that
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// appending single empty entries to the log always succeeds, used both
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// for replicating a new leader&#39;s initial empty entry, and for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// auto-leaving joint configurations.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nx">uncommittedSize</span> <span class="o">+=</span> <span class="nx">s</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// reduceUncommittedSize accounts for the newly committed entries by decreasing
</span></span></span><span class="line"><span class="cl"><span class="c1">// the uncommitted entry size limit.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">raft</span><span class="p">)</span> <span class="nf">reduceUncommittedSize</span><span class="p">(</span><span class="nx">ents</span> <span class="p">[]</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">uncommittedSize</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Fast-path for followers, who do not track or enforce the limit.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">s</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">e</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ents</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span> <span class="o">+=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nf">PayloadSize</span><span class="p">(</span><span class="nx">e</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">s</span> <span class="p">&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">uncommittedSize</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// uncommittedSize may underestimate the size of the uncommitted Raft
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// log tail but will never overestimate it. Saturate at 0 instead of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// allowing overflow.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">r</span><span class="p">.</span><span class="nx">uncommittedSize</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">r</span><span class="p">.</span><span class="nx">uncommittedSize</span> <span class="o">-=</span> <span class="nx">s</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>而在<code>becomeLeader</code>中，写入空日志条目后，空日志条目也可能会占用一部分容量（与计算日志大小的方式有关，之前etcd/raft中直接通过protobuf生成的<code>Size()</code>方法计算，其会受其它字段影响，详见<a href="https://github.com/etcd-io/etcd/pull/10199" target="_blank" rel="noopener noreffer">pull#10199</a>）。因此，为了不将空日志条目的大小记在其中，其调用了<code>reduceUncommittedSize</code>方法。</p>
<p>在<code>becomeLeader</code>执行完后，就会进入正常的处理逻辑。此时，所有follower的进度状态为默认状态<code>StateProbe</code>，以便leader获取follower的进度。</p>
<h3 id="42-leader中的日志提议">4.2 leader中的日志提议</h3>
<p>“提议”是新的日志条目的起点，因此这里从日志的提议开始分析。</p>
<p>日志的提议是通过<code>MsgProp</code>消息实现的。candidate或pre candidate直接丢弃<code>MsgProp</code>消息，follower会将<code>MsgProp</code>消息转发给leader，只有leader会对<code>MsgProp</code>消息做真正的处理：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="c1">// stepCandidate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">case</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">MsgProp</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">r</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;%x no leader at term %d; dropping proposal&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Term</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">ErrProposalDropped</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// stepFollower :
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">case</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">MsgProp</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">lead</span> <span class="o">==</span> <span class="nx">None</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">r</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;%x no leader at term %d; dropping proposal&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Term</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">ErrProposalDropped</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">disableProposalForwarding</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">r</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;%x not forwarding to leader %x at term %d; dropping proposal&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">lead</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Term</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">ErrProposalDropped</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">m</span><span class="p">.</span><span class="nx">To</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">lead</span>
</span></span><span class="line"><span class="cl">		<span class="nx">r</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// stepLeader :
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">case</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">MsgProp</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Entries</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">r</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Panicf</span><span class="p">(</span><span class="s">&#34;%x stepped empty MsgProp&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">prs</span><span class="p">.</span><span class="nx">Progress</span><span class="p">[</span><span class="nx">r</span><span class="p">.</span><span class="nx">id</span><span class="p">]</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// If we are not currently a member of the range (i.e. this node
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// was removed from the configuration while serving as leader),
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// drop any new proposals.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">return</span> <span class="nx">ErrProposalDropped</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">leadTransferee</span> <span class="o">!=</span> <span class="nx">None</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">r</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Debugf</span><span class="p">(</span><span class="s">&#34;%x [term %d] transfer leadership to %x is in progress; dropping proposal&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Term</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">leadTransferee</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">ErrProposalDropped</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Process ConfChange Msg
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">!</span><span class="nx">r</span><span class="p">.</span><span class="nf">appendEntry</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Entries</span><span class="o">...</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="nx">ErrProposalDropped</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">r</span><span class="p">.</span><span class="nf">bcastAppend</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span>
</span></span></code></pre></div><p>在leader将<code>MsgProp</code>中的提议追加到本地日志之前，还需要做一些判断与处理：</p>
<ol>
<li>首先leader会检查自己的<code>Progress</code>结构是否还存在，以判断自己是否已经被<code>ConfChange</code>操作移出了集群，如果该leader被移出了集群，则不会处理该提议。</li>
<li>接着，leader还会判断当前是否在进行<em>leader transfer</em>，如果该leader正在将领导权转移给其它节点，那么同样不会处理该提议。</li>
<li>如果提议中包含<code>ConfChange</code>消息，会做特殊处理，在后文介绍<code>ConfChange</code>时会分析这部分逻辑，这里暂时不做介绍。</li>
<li>如果在追加提议中的日志后会超过<code>MaxUncommittedSize</code>的限制，则不会追加该提议。这部分逻辑在<a href="#41-%e8%8a%82%e7%82%b9%e5%90%af%e5%8a%a8%e6%97%b6%e6%97%a5%e5%bf%97%e5%a4%84%e7%90%86" rel="">4.1 节点启动时日志处理</a>已经做过介绍，这里不再赘述。</li>
</ol>
<p>如果leader成功地将这些日志追加到了本地日志中，leade会调用<code>bcastAppend</code>方法，为所有follower（和learner）广播日志追加消息。</p>
<h3 id="43-leader为follower复制日志">4.3 leader为follower复制日志</h3>
<p>leader通过<code>bcastAppend</code>方法为follower（和learner）复制日志，该方法及其相关方法源码如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// bcastAppend sends RPC, with entries to all peers that are not up-to-date
</span></span></span><span class="line"><span class="cl"><span class="c1">// according to the progress recorded in r.prs.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">raft</span><span class="p">)</span> <span class="nf">bcastAppend</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nx">prs</span><span class="p">.</span><span class="nf">Visit</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">id</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">_</span> <span class="o">*</span><span class="nx">tracker</span><span class="p">.</span><span class="nx">Progress</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">id</span> <span class="o">==</span> <span class="nx">r</span><span class="p">.</span><span class="nx">id</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">r</span><span class="p">.</span><span class="nf">sendAppend</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// sendAppend sends an append RPC with new entries (if any) and the
</span></span></span><span class="line"><span class="cl"><span class="c1">// current commit index to the given peer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">raft</span><span class="p">)</span> <span class="nf">sendAppend</span><span class="p">(</span><span class="nx">to</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nf">maybeSendAppend</span><span class="p">(</span><span class="nx">to</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// maybeSendAppend sends an append RPC with new entries to the given peer,
</span></span></span><span class="line"><span class="cl"><span class="c1">// if necessary. Returns true if a message was sent. The sendIfEmpty
</span></span></span><span class="line"><span class="cl"><span class="c1">// argument controls whether messages with no entries will be sent
</span></span></span><span class="line"><span class="cl"><span class="c1">// (&#34;empty&#34; messages are useful to convey updated Commit indexes, but
</span></span></span><span class="line"><span class="cl"><span class="c1">// are undesirable when we&#39;re sending multiple messages in a batch).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">raft</span><span class="p">)</span> <span class="nf">maybeSendAppend</span><span class="p">(</span><span class="nx">to</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">sendIfEmpty</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">pr</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">prs</span><span class="p">.</span><span class="nx">Progress</span><span class="p">[</span><span class="nx">to</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">pr</span><span class="p">.</span><span class="nf">IsPaused</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">m</span> <span class="o">:=</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">Message</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">m</span><span class="p">.</span><span class="nx">To</span> <span class="p">=</span> <span class="nx">to</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">term</span><span class="p">,</span> <span class="nx">errt</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">term</span><span class="p">(</span><span class="nx">pr</span><span class="p">.</span><span class="nx">Next</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ents</span><span class="p">,</span> <span class="nx">erre</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">entries</span><span class="p">(</span><span class="nx">pr</span><span class="p">.</span><span class="nx">Next</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">maxMsgSize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ents</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">sendIfEmpty</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">errt</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">erre</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// send snapshot if we failed to get term or entries
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">		<span class="c1">// ... ... #1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// ... ... #2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>leader在调用<code>bcastAppend</code>方法时，会向所有其它节点广播<code>MsgApp</code>或<code>MsgSnap</code>消息，且即使是空消息也会广播。这里需要关注的是<code>maybeSendAppend</code>的实现，该函数是向一个节点发送<code>MsgApp</code>或<code>MsgSnap</code>消息的方法。</p>
<p>该方法的大致流程如下：</p>
<ol>
<li>首先通过<code>Prgoress</code>的<code>IsPaused</code>方法检查该节点进度，如果该节点进度阻塞了，那么不会向其发送消息。</li>
<li>获取用于日志匹配的日志条目（index为<code>next index - 1</code>的日志）的term。</li>
<li>获取该节点的<em>next index</em>之后的日志。</li>
<li>如果日志长度为0且不需要发送空日志，那么直接返回。</li>
<li>如果步骤2、3中任一步骤产生了错误，说明用于日志匹配的条目已被压缩，该节点落后了太多，因此需要为其发送<code>MsgSnap</code>消息；否则，发送<code>MsgApp</code>消息。</li>
<li>调用<code>send</code>方法，填充需要发送的消息中缺失的字段（如<code>Term</code>、<code>From</code>，具体逻辑见<code>send</code>方法的源码，这里不再赘述），并将消息放入该节点的信箱。由于etcd/raft不负责通信模块，因此这里不会真正发送，而是通过<code>Ready</code>结构体将需要发送的消息交给etcd/raft的使用者处理。</li>
</ol>
<p>接下来先来分析第5步中<code>MsgApp</code>消息的生成方式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// ... ... #2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">		<span class="nx">m</span><span class="p">.</span><span class="nx">Type</span> <span class="p">=</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">MsgApp</span>
</span></span><span class="line"><span class="cl">		<span class="nx">m</span><span class="p">.</span><span class="nx">Index</span> <span class="p">=</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">Next</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">		<span class="nx">m</span><span class="p">.</span><span class="nx">LogTerm</span> <span class="p">=</span> <span class="nx">term</span>
</span></span><span class="line"><span class="cl">		<span class="nx">m</span><span class="p">.</span><span class="nx">Entries</span> <span class="p">=</span> <span class="nx">ents</span>
</span></span><span class="line"><span class="cl">		<span class="nx">m</span><span class="p">.</span><span class="nx">Commit</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nx">committed</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Entries</span><span class="p">);</span> <span class="nx">n</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">switch</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">State</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// optimistically increase the next when in StateReplicate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">case</span> <span class="nx">tracker</span><span class="p">.</span><span class="nx">StateReplicate</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="nx">last</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Entries</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nx">Index</span>
</span></span><span class="line"><span class="cl">				<span class="nx">pr</span><span class="p">.</span><span class="nf">OptimisticUpdate</span><span class="p">(</span><span class="nx">last</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="nx">pr</span><span class="p">.</span><span class="nx">Inflights</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">last</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">case</span> <span class="nx">tracker</span><span class="p">.</span><span class="nx">StateProbe</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="nx">pr</span><span class="p">.</span><span class="nx">ProbeSent</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">			<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="nx">r</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Panicf</span><span class="p">(</span><span class="s">&#34;%x is sending append in unhandled state %s&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">State</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span></code></pre></div><p>这段逻辑配置了<code>MsgApp</code>消息的相关字段。<code>Index</code>和<code>LogTerm</code>字段是用于日志匹配的日志（即发送的日志的上一条日志）的index与term（用于日志匹配的term字段为<code>LogTerm</code>，消息的<code>Term</code>字段为该节点当前的term，部分消息需要自己指定，部分消息由<code>send</code>方法填充）。<code>Entries</code>字段保存了需要复制的日志条目。<code>Commit</code>字段为leader提交的最后一条日志的索引。</p>
<p>如果该消息携带的日志非空，该方法还会更新该follower的进度状态：</p>
<ul>
<li>如果节点处于<code>StateReplicate</code>状态，此时通过流水线的方式优化日志复制速度，直接更新其<code>Next</code>索引（详见<a href="#13-%e6%89%b9%e5%a4%84%e7%90%86%e4%b8%8e%e6%b5%81%e6%b0%b4%e7%ba%bf" rel="">1.3节</a>），并通过<code>Inflights</code>进行流控（详见<a href="#32-follower%e7%9a%843%e7%a7%8d%e7%8a%b6%e6%80%81" rel="">3.2节</a>）。</li>
<li>如果节点处于<code>StateProbe</code>状态，此时将<code>ProbeSent</code>置为true，阻塞后续的消息，直到收到确认。</li>
</ul>
<p>在分析了<code>MsgApp</code>消息的生成方式后，接下来分析<code>MsgSnap</code>消息的生成：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// ... ... #1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">!</span><span class="nx">pr</span><span class="p">.</span><span class="nx">RecentActive</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">r</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Debugf</span><span class="p">(</span><span class="s">&#34;ignore sending snapshot to %x since it is not recently active&#34;</span><span class="p">,</span> <span class="nx">to</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">m</span><span class="p">.</span><span class="nx">Type</span> <span class="p">=</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">MsgSnap</span>
</span></span><span class="line"><span class="cl">		<span class="nx">snapshot</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">snapshot</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">ErrSnapshotTemporarilyUnavailable</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">r</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Debugf</span><span class="p">(</span><span class="s">&#34;%x failed to send snapshot to %x because snapshot is temporarily unavailable&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">to</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="c1">// TODO(bdarnell)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nf">IsEmptySnap</span><span class="p">(</span><span class="nx">snapshot</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;need non-empty snapshot&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">m</span><span class="p">.</span><span class="nx">Snapshot</span> <span class="p">=</span> <span class="nx">snapshot</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sindex</span><span class="p">,</span> <span class="nx">sterm</span> <span class="o">:=</span> <span class="nx">snapshot</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">.</span><span class="nx">Index</span><span class="p">,</span> <span class="nx">snapshot</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">.</span><span class="nx">Term</span>
</span></span><span class="line"><span class="cl">		<span class="nx">r</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Debugf</span><span class="p">(</span><span class="s">&#34;%x [firstindex: %d, commit: %d] sent snapshot[index: %d, term: %d] to %x [%s]&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">r</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">firstIndex</span><span class="p">(),</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nx">committed</span><span class="p">,</span> <span class="nx">sindex</span><span class="p">,</span> <span class="nx">sterm</span><span class="p">,</span> <span class="nx">to</span><span class="p">,</span> <span class="nx">pr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">pr</span><span class="p">.</span><span class="nf">BecomeSnapshot</span><span class="p">(</span><span class="nx">sindex</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">r</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Debugf</span><span class="p">(</span><span class="s">&#34;%x paused sending replication messages to %x [%s]&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">to</span><span class="p">,</span> <span class="nx">pr</span><span class="p">)</span>
</span></span></code></pre></div><p>在准备快照之前，这段逻辑线判断了该follower节点最近是否是活跃的，如果不活跃则不会为其发送快照（详见<a href="#32-follower%e7%9a%843%e7%a7%8d%e7%8a%b6%e6%80%81" rel="">3.2节</a>）。</p>
<p>在生成快照并检测快照无误后，需要通过<code>BecomeSnapshot</code>方法将该follower的状态转为<code>StateSnapshot</code>，以阻塞该节点后续的<code>MsgApp</code>消息。</p>
<p>在follower转为<code>StateSnapshot</code>后，只有两种跳出<code>StateSnapshot</code>的方法：</p>
<ol>
<li>follower节点应用快照后会发送<code>MsgAppResp</code>消息，该消息会报告当前follower的<em>last index</em>。如果follower应用了快照后<em>last index</em>就追赶上了其<em>match index</em>，那么leader会直接将follower的状态转移到<code>StateRelicate</code>状态，为其继续复制日志。</li>
<li>leader节点的使用者还需要主动调用<code>Node</code>的<code>ReportSnapshot</code>方法告知leader节点快照的应用状态，leader会将该follower的状态转移到<code>StateProbe</code>状态（与方法1重复的消息会被忽略）。</li>
</ol>
<p>方法1的逻辑会在后文介绍leader对<code>MsgAppResp</code>消息的处理时介绍，这里仅介绍方法2。</p>
<p>在<code>Ready</code>的<code>Entries</code>字段的注释中可以看到，如果需要发送的日志中包含<code>MsgSnap</code>消息，那么当前节点（一定是leader节点）必须在目标节点应用完该消息后调用<code>Node</code>的<code>ReportSnapshot</code>方法上报快照状态。该方法在<code>rawnode</code>中的实现方式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ReportSnapshot reports the status of the sent snapshot.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">rn</span> <span class="o">*</span><span class="nx">RawNode</span><span class="p">)</span> <span class="nf">ReportSnapshot</span><span class="p">(</span><span class="nx">id</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">status</span> <span class="nx">SnapshotStatus</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rej</span> <span class="o">:=</span> <span class="nx">status</span> <span class="o">==</span> <span class="nx">SnapshotFailure</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">_</span> <span class="p">=</span> <span class="nx">rn</span><span class="p">.</span><span class="nx">raft</span><span class="p">.</span><span class="nf">Step</span><span class="p">(</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Message</span><span class="p">{</span><span class="nx">Type</span><span class="p">:</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">MsgSnapStatus</span><span class="p">,</span> <span class="nx">From</span><span class="p">:</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">Reject</span><span class="p">:</span> <span class="nx">rej</span><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>ReportSnapshot</code>方法会将一条<code>MsgSnapStatus</code>消息应用给leader状态机。如果快照应用失败，该消息的<code>Reject</code>字段会被置为true。只有leader需要处理<code>MsgSnapStatus</code>消息，其处理方式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// stepLeader
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">MsgSnapStatus</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">State</span> <span class="o">!=</span> <span class="nx">tracker</span><span class="p">.</span><span class="nx">StateSnapshot</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// TODO(tbg): this code is very similar to the snapshot handling in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// MsgAppResp above. In fact, the code there is more correct than the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// code here and should likely be updated to match (or even better, the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// logic pulled into a newly created Progress state machine handler).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="p">!</span><span class="nx">m</span><span class="p">.</span><span class="nx">Reject</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">pr</span><span class="p">.</span><span class="nf">BecomeProbe</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nx">r</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Debugf</span><span class="p">(</span><span class="s">&#34;%x snapshot succeeded, resumed sending replication messages to %x [%s]&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">From</span><span class="p">,</span> <span class="nx">pr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// NB: the order here matters or we&#39;ll be probing erroneously from
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// the snapshot index, but the snapshot never applied.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">pr</span><span class="p">.</span><span class="nx">PendingSnapshot</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">			<span class="nx">pr</span><span class="p">.</span><span class="nf">BecomeProbe</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="nx">r</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Debugf</span><span class="p">(</span><span class="s">&#34;%x snapshot failed, resumed sending replication messages to %x [%s]&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">From</span><span class="p">,</span> <span class="nx">pr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// If snapshot finish, wait for the MsgAppResp from the remote node before sending
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// out the next MsgApp.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// If snapshot failure, wait for a heartbeat interval before next try
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">pr</span><span class="p">.</span><span class="nx">ProbeSent</span> <span class="p">=</span> <span class="kc">true</span>
</span></span></code></pre></div><p>从这段逻辑中可以看到，无论快照应用是否成功，leader都会将该follower的进度状态转为<code>StateProbe</code>状态。不同之处仅在于在调用<code>BecomeProbe</code>方法之前是否将<code>PendingSnapshot</code>的值置为0。读者可以回顾<code>ResetState(StateProbe)</code>的实现（详见<a href="#33-%e7%8a%b6%e6%80%81%e8%bd%ac%e6%8d%a2%e4%b8%8e%e6%9b%b4%e6%96%b0%e5%9b%9e%e9%80%80" rel="">3.3节</a>），在没有将其置为0时，下一次检测日志匹配时会从该follower的<em>match index + 1</em>和该快照的index+1二者中较大者开始检测；而将其置为0后，只会从该follower的<em>match index + 1</em>开始检测。</p>
<h3 id="44-follower处理来自leader的日志">4.4 follower处理来自leader的日志</h3>
<p>follower处理来自leader的日志复制消息时，同样分为对<code>MsgApp</code>和对<code>MsgSnap</code>的处理，<code>handleAppendEntries</code>方法用来处理<code>MsgApp</code>消息、<code>handleSnapshot</code>用来处理<code>MsgSnap</code>消息。在处理这两种消息时，都会使用<code>MsgAppResp</code>方法对其进行相应。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">raft</span><span class="p">)</span> <span class="nf">handleAppendEntries</span><span class="p">(</span><span class="nx">m</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Index</span> <span class="p">&lt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nx">committed</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">r</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Message</span><span class="p">{</span><span class="nx">To</span><span class="p">:</span> <span class="nx">m</span><span class="p">.</span><span class="nx">From</span><span class="p">,</span> <span class="nx">Type</span><span class="p">:</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">MsgAppResp</span><span class="p">,</span> <span class="nx">Index</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nx">committed</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">mlastIndex</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">maybeAppend</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Index</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">LogTerm</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Commit</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Entries</span><span class="o">...</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">r</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Message</span><span class="p">{</span><span class="nx">To</span><span class="p">:</span> <span class="nx">m</span><span class="p">.</span><span class="nx">From</span><span class="p">,</span> <span class="nx">Type</span><span class="p">:</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">MsgAppResp</span><span class="p">,</span> <span class="nx">Index</span><span class="p">:</span> <span class="nx">mlastIndex</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">r</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Debugf</span><span class="p">(</span><span class="s">&#34;%x [logterm: %d, index: %d] rejected MsgApp [logterm: %d, index: %d] from %x&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">r</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">zeroTermOnErrCompacted</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">term</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Index</span><span class="p">)),</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Index</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">LogTerm</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Index</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">From</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">r</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Message</span><span class="p">{</span><span class="nx">To</span><span class="p">:</span> <span class="nx">m</span><span class="p">.</span><span class="nx">From</span><span class="p">,</span> <span class="nx">Type</span><span class="p">:</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">MsgAppResp</span><span class="p">,</span> <span class="nx">Index</span><span class="p">:</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Index</span><span class="p">,</span> <span class="nx">Reject</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">RejectHint</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">lastIndex</span><span class="p">()})</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>follower对<code>MsgApp</code>消息的处理可分为如下情况：</p>
<ol>
<li>如果用于日志匹配的条目在<code>committed</code>之前，说明这是一条过期的消息，因此直接返回<code>MsgAppResp</code>消息，并将消息的<code>Index</code>字段置为<code>committed</code>的值，以让leader快速更新该follower的<em>next index</em>。</li>
<li>接下来，验证用于日志匹配的字段<code>Term</code>与<code>Index</code>是否与本地的日志匹配。如果匹配并保存了日志，则返回<code>MsgAppResp</code>消息，并将消息的<code>Index</code>字段置为本地最后一条日志的index，以让leader发送后续的日志。</li>
<li>如果日志不匹配，返回的<code>MsgAppResp</code>的<code>Reject</code>字段会被置为true，且<code>RejectHint</code>字段值为本地最后一条日志的索引，以便leader快速回退其<em>next index</em>。同时，<code>MsgApp</code>的<code>Index</code>字段会透传给<code>MsgAppResp</code>，以便leader校验该消息是否为过期的消息。</li>
</ol>
<p>关于<code>RejectHint</code>的使用在<a href="#11-%e5%bf%ab%e9%80%9f%e5%9b%9e%e9%80%80" rel="">1.1节</a>和<a href="#33-%e7%8a%b6%e6%80%81%e8%bd%ac%e6%8d%a2%e4%b8%8e%e6%9b%b4%e6%96%b0%e5%9b%9e%e9%80%80" rel="">3.3节</a>中已经介绍过，这里不再赘述。需要注意的是，这里的“返回”，指的同样是将消息存入相应节点的信箱中，等待etcd/raft模块的使用者处理<code>Ready</code>结构体时发送给相应的节点。</p>
<p>而<code>handleSnapshot</code>的处理方式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">raft</span><span class="p">)</span> <span class="nf">handleSnapshot</span><span class="p">(</span><span class="nx">m</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sindex</span><span class="p">,</span> <span class="nx">sterm</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Snapshot</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">.</span><span class="nx">Index</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Snapshot</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">.</span><span class="nx">Term</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nf">restore</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Snapshot</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">r</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;%x [commit: %d] restored snapshot [index: %d, term: %d]&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">r</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nx">committed</span><span class="p">,</span> <span class="nx">sindex</span><span class="p">,</span> <span class="nx">sterm</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">r</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Message</span><span class="p">{</span><span class="nx">To</span><span class="p">:</span> <span class="nx">m</span><span class="p">.</span><span class="nx">From</span><span class="p">,</span> <span class="nx">Type</span><span class="p">:</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">MsgAppResp</span><span class="p">,</span> <span class="nx">Index</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">lastIndex</span><span class="p">()})</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">r</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;%x [commit: %d] ignored snapshot [index: %d, term: %d]&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">r</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nx">committed</span><span class="p">,</span> <span class="nx">sindex</span><span class="p">,</span> <span class="nx">sterm</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">r</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Message</span><span class="p">{</span><span class="nx">To</span><span class="p">:</span> <span class="nx">m</span><span class="p">.</span><span class="nx">From</span><span class="p">,</span> <span class="nx">Type</span><span class="p">:</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">MsgAppResp</span><span class="p">,</span> <span class="nx">Index</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nx">committed</span><span class="p">})</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>处理<code>MsgSnap</code>消息时，<code>handleSnapshot</code>方法会调用<code>restore</code>方法尝试应用快照。如果快照应用功能成功，则返回一条<code>MsgAppResp</code>消息，该消息的<code>Index</code>字段为本地最后一条日志的index；而如果快照没有被应用，那么返回的<code>MsgAppResp</code>消息的<code>Index</code>字段会被置为本地的<code>committed</code>索引。</p>
<p>可以看出，对<code>MsgSnap</code>消息的处理，重点在<code>restore</code>方法的实现。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// restore recovers the state machine from a snapshot. It restores the log and the
</span></span></span><span class="line"><span class="cl"><span class="c1">// configuration of state machine. If this method returns false, the snapshot was
</span></span></span><span class="line"><span class="cl"><span class="c1">// ignored, either because it was obsolete or because of an error.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">raft</span><span class="p">)</span> <span class="nf">restore</span><span class="p">(</span><span class="nx">s</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">Snapshot</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">.</span><span class="nx">Index</span> <span class="o">&lt;=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nx">committed</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Now go ahead and actually restore.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">matchTerm</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">.</span><span class="nx">Index</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">.</span><span class="nx">Term</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">r</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;%x [commit: %d, lastindex: %d, lastterm: %d] fast-forwarded commit to snapshot [index: %d, term: %d]&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">r</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nx">committed</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">lastIndex</span><span class="p">(),</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">lastTerm</span><span class="p">(),</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">.</span><span class="nx">Index</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">.</span><span class="nx">Term</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">commitTo</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">.</span><span class="nx">Index</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">restore</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;%x [commit: %d, lastindex: %d, lastterm: %d] restored snapshot [index: %d, term: %d]&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">r</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nx">committed</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">lastIndex</span><span class="p">(),</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">lastTerm</span><span class="p">(),</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">.</span><span class="nx">Index</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Metadata</span><span class="p">.</span><span class="nx">Term</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>restore</code>方法中有一些对<code>ConfChange</code>的处理，这部分会在本系列后续的文章中介绍，这里暂时略过。除此之外，<code>restore</code>中还有一些防止不应发生的情况的“Defense in depth”代码，这里也不做介绍，感兴趣的读者可以自行结合注释了解。</p>
<p><code>restore</code>对快照做了如下处理：</p>
<ol>
<li>如果快照的index没超过本地的<code>committed</code>索引，这说明快照过旧，因此不做处理直接返回false。</li>
<li>将快照的index和term与本地日志匹配，如果成功匹配，说明本地日志已经包含了快照覆盖的日志，因此不要应用该快照。同时，因为快照覆盖的日志都应是已被提交的日志，这也说明了本地的<code>committed</code>索引落后了，因此调用<code>raftLog</code>的<code>commitTo</code>方法，让本地<code>committed</code>索引快速前进到该快照的index，然后直接返回false。</li>
<li>如果到这里方法仍没返回，则可以将快照应用到本地。调用<code>raftLog</code>的<code>restore</code>方法，并返回true。</li>
</ol>
<p>无论是处理<code>MsgApp</code>消息还是处理<code>MsgSnap</code>消息，返回的消息都是<code>MsgAppResp</code>。下一节中将分析leader对<code>MsgAppResp</code>消息的处理方式。</p>
<h3 id="45-leader处理来自follower的日志复制响应">4.5 leader处理来自follower的日志复制响应</h3>
<p><code>stepLeader</code>方法在处理<code>MsgAppResp</code>消息时，会根据该消息和发送该消息的follower的状态来进行不同的处理：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="c1">// stepLeader
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">MsgAppResp</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">pr</span><span class="p">.</span><span class="nx">RecentActive</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Reject</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">r</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Debugf</span><span class="p">(</span><span class="s">&#34;%x received MsgAppResp(MsgApp was rejected, lastindex: %d) from %x for index %d&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">				<span class="nx">r</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">RejectHint</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">From</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Index</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">pr</span><span class="p">.</span><span class="nf">MaybeDecrTo</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Index</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">RejectHint</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">r</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Debugf</span><span class="p">(</span><span class="s">&#34;%x decreased progress of %x to [%s]&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">From</span><span class="p">,</span> <span class="nx">pr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">State</span> <span class="o">==</span> <span class="nx">tracker</span><span class="p">.</span><span class="nx">StateReplicate</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">pr</span><span class="p">.</span><span class="nf">BecomeProbe</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="nx">r</span><span class="p">.</span><span class="nf">sendAppend</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">From</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">oldPaused</span> <span class="o">:=</span> <span class="nx">pr</span><span class="p">.</span><span class="nf">IsPaused</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">pr</span><span class="p">.</span><span class="nf">MaybeUpdate</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Index</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">switch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">case</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">State</span> <span class="o">==</span> <span class="nx">tracker</span><span class="p">.</span><span class="nx">StateProbe</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">					<span class="nx">pr</span><span class="p">.</span><span class="nf">BecomeReplicate</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">				<span class="k">case</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">State</span> <span class="o">==</span> <span class="nx">tracker</span><span class="p">.</span><span class="nx">StateSnapshot</span> <span class="o">&amp;&amp;</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">Match</span> <span class="o">&gt;=</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">PendingSnapshot</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">					<span class="c1">// TODO(tbg): we should also enter this branch if a snapshot is
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// received that is below pr.PendingSnapshot but which makes it
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// possible to use the log again.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="nx">r</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Debugf</span><span class="p">(</span><span class="s">&#34;%x recovered from needing snapshot, resumed sending replication messages to %x [%s]&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">From</span><span class="p">,</span> <span class="nx">pr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="c1">// Transition back to replicating state via probing state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// (which takes the snapshot into account). If we didn&#39;t
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// move to replicating state, that would only happen with
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// the next round of appends (but there may not be a next
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// round for a while, exposing an inconsistent RaftStatus).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="nx">pr</span><span class="p">.</span><span class="nf">BecomeProbe</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">					<span class="nx">pr</span><span class="p">.</span><span class="nf">BecomeReplicate</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">				<span class="k">case</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">State</span> <span class="o">==</span> <span class="nx">tracker</span><span class="p">.</span><span class="nx">StateReplicate</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">					<span class="nx">pr</span><span class="p">.</span><span class="nx">Inflights</span><span class="p">.</span><span class="nf">FreeLE</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Index</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nf">maybeCommit</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="nx">r</span><span class="p">.</span><span class="nf">bcastAppend</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">oldPaused</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="c1">// If we were paused before, this node may be missing the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// latest commit index, so send it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="nx">r</span><span class="p">.</span><span class="nf">sendAppend</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">From</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// We&#39;ve updated flow control information above, which may
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="c1">// allow us to send multiple (size-limited) in-flight messages
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="c1">// at once (such as when transitioning from probe to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="c1">// replicate, or when freeTo() covers multiple messages). If
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="c1">// we have more entries to send, send as many messages as we
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="c1">// can (without sending empty messages for the commit index)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>				<span class="k">for</span> <span class="nx">r</span><span class="p">.</span><span class="nf">maybeSendAppend</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">From</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				
</span></span><span class="line"><span class="cl">				<span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span></code></pre></div><p>这段逻辑首先处理了<code>MsgAppResp</code>的<code>Reject</code>字段为true的情况，这只会在follower处理<code>MsgApp</code>消息时发现日志条目不匹配时发生。因此，处理这种消息时，调用了<code>MaybeDecrTo</code>方法回退其<code>Next</code>索引。如果回退失败，说明这是一条过期的消息，不做处理；如果回退成功，且该节点为<code>StateReplicate</code>状态，则调用<code>BecomeProbe</code>使其转为<code>StateProbe</code>状态来查找最后一条匹配日志的位置。回退成功时，还会再次为该节点调用<code>sendAppend</code>方法，以为其发送<code>MsgApp</code>消息。</p>
<p>在处理<code>MsgAppResp</code>的<code>Reject</code>为false的消息时，其会调用<code>MaybeUpdate</code>方法来判断该消息的<code>Index</code>字段是否跟上了该follower的<em>match index</em>，并在需要时更新其<em>next index</em>。如果该消息没有跟上<em>match index</em>，那么不会对该消息做其它处理。其原因有三：</p>
<ol>
<li>这条消息是过期的消息，不需要处理。</li>
<li>这条消息可能是follower应用快照发来的响应，且此时该follower仍未跟上其<em>match index</em>（可能是follower重启恢复后导致的）。此处后续处理逻辑即为在<a href="#43-leader%e4%b8%bafollower%e5%a4%8d%e5%88%b6%e6%97%a5%e5%bf%97" rel="">4.3节</a>中提到的跳出<code>StateSnapshot</code>的第1中情况；如果这里因没跟上<em>match index</em>而没有跳出<code>StateSnapshot</code>状态，也会在etcd/raft模块使用者主动调用<code>ReportSnapshot</code>方法时跳出该状态。因此不会阻塞。</li>
<li>这条消息可能是StateProbe状态的follower发来的确认相应，但此时该follower仍未跟上其<em>match index</em>（可能是follower重启恢复后导致的）。因在一次心跳周期内，leader仅应向处于<code>StateProbe</code>状态的follower发送1条<code>MsgApp</code>消息，因此其释放应在心跳相关的逻辑中，该逻辑会在后文分析。因此也不会阻塞。</li>
</ol>
<p>在分析完为什么这里仅处理跟上<em>match index</em>的<code>MsgAppResp</code>消息后，接下来其处理方式。</p>
<p>首先，该方法会根据发送该消息的follower的状态进行处理：</p>
<ol>
<li>如果该follower处于<code>StateProbe</code>状态且现在跟上了进度，则将其转为<code>StateReplica</code>状态。</li>
<li>如果该follower处于<code>StateSnapshot</code>状态且现在跟上了进度，且从该follower发送该消息后到leader处理这条消息时，leader没有为其发送新快照（通过比较<code>Match</code>与<code>PendingSnapshot</code>判断），则将其转为<code>StateReplica</code>状态。</li>
<li>如果该follower处于<code>StateReplicate</code>状态，那么释放<code>Inflights</code>中该消息的<code>Index</code>字段值之前的所有消息。因为收到的<code>MsgAppResp</code>可能是乱序的，因此需要释放之前的所有消息（过期消息不会被处理）。</li>
</ol>
<p>接下来，该方法调用了<code>maybeCommit</code>方法，该方法会根据所有节点的进度更新leader的<em>commit index</em>，在<em>commit index</em>有更新时返回true，否则返回false（该方法中有与成员变更相关的逻辑，这里暂时不对其进行分析，而是将其留给后续的文章，这里只需要知道其功能即可）。如果<em>commit index</em>有更新，那么调用<code>bcastAppend</code>方法广播新的<code>committed</code>索引。如果<em>commit index</em>没有更新，还需要进一步判断该follower之前是否是阻塞的，如果是那么为该follower发送一条日志复制消息以更新其<code>committed</code>索引，因为在该节点阻塞时可能错过了<code>committed</code>索引的更新消息。</p>
<p>接着，通过for循环继续为该节点发送新的日志复制消息。因为日志复制部分有流控逻辑，因此这里的循环不会成为死循环。这样做可以尽可能多地为节点复制日志，以提高日志复制效率。</p>
<p>最后这里还有一处<em>leader transfer</em>的逻辑，此处在本系列介绍Raft选举时有提到过，这里不再赘述。</p>
<h3 id="46-心跳消息中日志复制相关操作">4.6 心跳消息中日志复制相关操作</h3>
<p>除了<code>MsgApp</code>、<code>MsgSnap</code>、<code>MsgAppResp</code>消息外，心跳消息<code>MsgHeartbeat</code>即其相应的相应消息<code>MsgHeartbeatResp</code>中也有一些与日志复制相关的逻辑（如<code>StateProbe</code>状态下释放阻塞状态的逻辑）。虽然这部分逻辑不多但同样重要，本节分析这部分逻辑。</p>
<p>首先是leader为follower发送心跳消息时的相关逻辑：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// stepLeader
</span></span></span><span class="line"><span class="cl"><span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">case</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">MsgBeat</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nf">bcastHeartbeat</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// sendHeartbeat sends a heartbeat RPC to the given peer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">raft</span><span class="p">)</span> <span class="nf">sendHeartbeat</span><span class="p">(</span><span class="nx">to</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">ctx</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Attach the commit as min(to.matched, r.committed).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// When the leader sends out heartbeat message,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// the receiver(follower) might not be matched with the leader
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// or it might not have all the committed entries.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// The leader MUST NOT forward the follower&#39;s commit to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// an unmatched index.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">commit</span> <span class="o">:=</span> <span class="nf">min</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">prs</span><span class="p">.</span><span class="nx">Progress</span><span class="p">[</span><span class="nx">to</span><span class="p">].</span><span class="nx">Match</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nx">committed</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">m</span> <span class="o">:=</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">Message</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">To</span><span class="p">:</span>      <span class="nx">to</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Type</span><span class="p">:</span>    <span class="nx">pb</span><span class="p">.</span><span class="nx">MsgHeartbeat</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Commit</span><span class="p">:</span>  <span class="nx">commit</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Context</span><span class="p">:</span> <span class="nx">ctx</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在<code>tickHeartbeat</code>方法中，每次心跳会将一条<code>MsgBeat</code>应用到状态机。该消息会触发<code>bcastHeartbeat</code>方法，为其它节点广播心跳消息。<code>bcastHeartbeat</code>方法中有一些与实现线性一致性读相关的逻辑，这里将其留给本系列的后续文章。这里只需要看该方法最后调用的<code>sendHeartbeat</code>方法，方法生成的<code>MsgHeartbeat</code>消息中的<code>Index</code>字段为leader的<code>committed</code>索引。而在follower处理<code>MsgHeartbeat</code>消息时，会根据该字段更新自己的<code>committed</code>索引，以避免空闲集群没有新提议无法更新follower的<code>committed</code>状态的问题。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">raft</span><span class="p">)</span> <span class="nf">handleHeartbeat</span><span class="p">(</span><span class="nx">m</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">commitTo</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Commit</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Message</span><span class="p">{</span><span class="nx">To</span><span class="p">:</span> <span class="nx">m</span><span class="p">.</span><span class="nx">From</span><span class="p">,</span> <span class="nx">Type</span><span class="p">:</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">MsgHeartbeatResp</span><span class="p">,</span> <span class="nx">Context</span><span class="p">:</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Context</span><span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>随后，follower会向leader发送<code>MsgHeartbeatResp</code>消息作为响应。leader在处理该消息时，主要做的也是线性一致性读相关的处理，但也有部分与日志复制相关的逻辑：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">MsgHeartbeatResp</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">pr</span><span class="p">.</span><span class="nx">RecentActive</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">		<span class="nx">pr</span><span class="p">.</span><span class="nx">ProbeSent</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// free one slot for the full inflights window to allow progress.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">State</span> <span class="o">==</span> <span class="nx">tracker</span><span class="p">.</span><span class="nx">StateReplicate</span> <span class="o">&amp;&amp;</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">Inflights</span><span class="p">.</span><span class="nf">Full</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">pr</span><span class="p">.</span><span class="nx">Inflights</span><span class="p">.</span><span class="nf">FreeFirstOne</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">pr</span><span class="p">.</span><span class="nx">Match</span> <span class="p">&lt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">lastIndex</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">r</span><span class="p">.</span><span class="nf">sendAppend</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">From</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		
</span></span><span class="line"><span class="cl">		<span class="c1">// ... ...
</span></span></span></code></pre></div><p>在leader收到新条例响应时，会重置<code>ProbeSent</code>为false，以在下一个心跳周期继续为处于<code>StateProbe</code>的follower复制日志。</p>
<p>同时，如果该follower处于<code>StateReplicate</code>状态且其用于流控的<code>Inflights</code>已满，leader会为其释放一个<code>Inflights</code>的槽位，以保证在每个心跳周期处于<code>StateReplicate</code>状态的follower都至少能收到一条<code>MsgApp</code>消息。</p>
<p>最后，如果该节点的<em>match index</em>小于leader当前最后一条日志，则为其调用<code>sendAppend</code>方法来复制新日志。</p>
<h2 id="5-q--a">5. Q &amp; A</h2>
<h3 id="51-为什么raftlog使用了unstable也能保证安全性">5.1 为什么raftLog使用了unstable也能保证安全性？</h3>
<p>etcd/raft为了能够批处理网络与磁盘I/O，在<code>raftLog</code>中设计了一段还未保存到稳定存储的<code>unstable</code>段。在阅读日志复制部分代码时，有些读者可能会有这一疑惑：</p>
<ul>
<li>follower回复<code>MsgAppResp</code>请求时<code>Index</code>字段为整个<code>raftLog</code>的<em>last index</em>，其中包括了<code>unstable</code>段。而leader会根据<code>MsgAppResp</code>的<code>Index</code>字段更新follower的<em>match index</em>，且leader会根据quorum的<em>match index</em>计算<em>committed index</em>。那么会不会出现被commit的日志其实还没有被quorum的节点保存到稳定存储从而无法保证安全性的情况？</li>
</ul>
<p>显然，如果日志在commit之前没有被quorum的节点保存到稳定存储，那么的确存在日志丢失的情况。在《Consensus: Bridging theory and practice》的<em>11.7.3 Avoiding persistent storage writes</em>中确实提到了这种设计<sup>引用1</sup>。但是etcd/raft中，其实并不会出现没有被quorum节点保存到稳定存储就commit的情况。这与<code>Ready</code>要求的字段处理顺序有关。</p>
<p>首先，正如上文提到，因为etcd/raft中的网络操作也是批处理设计，因此<code>send</code>方法只是将消息放入信箱，而不是立刻将其发出（etcd/raft也没有通信模块）。因此，当follower收到<code>MsgApp</code>请求时，执行的操作实际上是（不考虑特殊情况）：</p>
<ol>
<li>将新日志追加到<code>unstable</code>中。</li>
<li>将包含<code>unstable</code>的<em>last index</em>的<code>MsgAppResp</code>消息放入信箱，等待发送。</li>
</ol>
<p>当用户收到下一个<code>Ready</code>结构体时，其收到的其实是如下内容：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// node.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">newReady</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">raft</span><span class="p">,</span> <span class="nx">prevSoftSt</span> <span class="o">*</span><span class="nx">SoftState</span><span class="p">,</span> <span class="nx">prevHardSt</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">HardState</span><span class="p">)</span> <span class="nx">Ready</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rd</span> <span class="o">:=</span> <span class="nx">Ready</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Entries</span><span class="p">:</span>          <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">unstableEntries</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">CommittedEntries</span><span class="p">:</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">nextEnts</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Messages</span><span class="p">:</span>         <span class="nx">r</span><span class="p">.</span><span class="nx">msgs</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">softSt</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">softState</span><span class="p">();</span> <span class="p">!</span><span class="nx">softSt</span><span class="p">.</span><span class="nf">equal</span><span class="p">(</span><span class="nx">prevSoftSt</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rd</span><span class="p">.</span><span class="nx">SoftState</span> <span class="p">=</span> <span class="nx">softSt</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">hardSt</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">hardState</span><span class="p">();</span> <span class="p">!</span><span class="nf">isHardStateEqual</span><span class="p">(</span><span class="nx">hardSt</span><span class="p">,</span> <span class="nx">prevHardSt</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rd</span><span class="p">.</span><span class="nx">HardState</span> <span class="p">=</span> <span class="nx">hardSt</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nx">unstable</span><span class="p">.</span><span class="nx">snapshot</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rd</span><span class="p">.</span><span class="nx">Snapshot</span> <span class="p">=</span> <span class="o">*</span><span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nx">unstable</span><span class="p">.</span><span class="nx">snapshot</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">readStates</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">rd</span><span class="p">.</span><span class="nx">ReadStates</span> <span class="p">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">readStates</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rd</span><span class="p">.</span><span class="nx">MustSync</span> <span class="p">=</span> <span class="nf">MustSync</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nf">hardState</span><span class="p">(),</span> <span class="nx">prevHardSt</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">rd</span><span class="p">.</span><span class="nx">Entries</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">rd</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// log.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">l</span> <span class="o">*</span><span class="nx">raftLog</span><span class="p">)</span> <span class="nf">unstableEntries</span><span class="p">()</span> <span class="p">[]</span><span class="nx">pb</span><span class="p">.</span><span class="nx">Entry</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">l</span><span class="p">.</span><span class="nx">unstable</span><span class="p">.</span><span class="nx">entries</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">l</span><span class="p">.</span><span class="nx">unstable</span><span class="p">.</span><span class="nx">entries</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>可以看到，<code>Ready</code>结构体的<code>Entries</code>字段是全量的<code>unstable</code>段的日志，<code>Messages</code>字段是全量的信箱中的消息。而<code>Ready</code>结构体的处理顺序必须满足如下顺序：</p>
<ol>
<li>先将<code>Ready</code>的<code>Entries</code>、<code>HardState</code>、<code>Snapshot</code>保存到稳定存储（如果值非空）。</li>
<li>再发送<code>Ready</code>的<code>Messages</code>字段中的消息。</li>
</ol>
<p>因此，在etcd/raft模块的使用者将含有<code>unstable</code>的<em>last index</em>的<code>MsgAppResp</code>消息发出之前，<code>unstable</code>中的所有日志已经被保存到了稳定存储中。所以，当leader收到该<code>MsgAppResp</code>并根据其<code>Index</code>字段更新该follower的<em>match index</em>时，<em>match index</em>之前的消息确实被保存到了该follower的稳定存储中。</p>
<p>关于稳定存储与安全性，《Consensus: Bridging theory and practice》给出了更详细的描述与形式化的证明，这里<sup>引用2</sup>再摘录部分与本问题相关的段落，便于读者参考。</p>
<div class="details admonition quote open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-quote-right fa-fw"></i>引用1<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p><em>11.7.3 Avoiding persistent storage writes</em></p>
<p>Many papers suggest using replication rather than stable storage for durability. For example, in Viewstamped Replication Revisited, servers do not write log entries to stable storage. When a server restarts, its log is not used for voting until it learns the current information (its disk is only used as an optimization to avoid network transfers). The trade-off is that data loss is possible in catastrophic events. For example, if a majority of the cluster were to restart simultaneously, the cluster would have potentially lost entries and would not be able to form a new view. Raft could be extended in similar ways to support disk-less operation, but we think the risk of availability or data loss usually outweighs the benefits.</p>
</div>
        </div>
    </div>
<div class="details admonition quote open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-quote-right fa-fw"></i>引用2<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p><em>3.8 Persisted state and server restarts</em></p>
<p>&hellip; &hellip;</p>
<p>Each server also persists new log entries before they are counted towards the entries’ commitment; this prevents committed entries from being lost or “uncommitted” when servers restart.</p>
<p>&hellip; &hellip;</p>
<p>The state machine can either be volatile or persistent. A volatile state machine must be recovered after restarts by reapplying log entries (after applying the latest snapshot; see Chapter 5). A persistent state machine, however, has already applied most entries after a restart; to avoid reapplying them, its last applied index must also be persistent.</p>
<p>&hellip; &hellip;</p>
<p>If a server loses any of its persistent state, it cannot safely rejoin the cluster with its prior identity. Such a server can usually be added back into the cluster with a new identity by invoking a cluster membership change (see Chapter 4). If a majority of the cluster loses its persistent state, however, log entries may be lost and progress on cluster membership changes will not be possible; to proceed, a system administrator would need to admit the possibility of data loss.</p>
</div>
        </div>
    </div>
<h3 id="52-entrieshardstatesnapshot持久化顺序有要求吗">5.2 Entries、HardState、Snapshot持久化顺序有要求吗？</h3>
<p>在处理<code>Ready</code>结构体时，除了要保证先持久化再发送消息的顺序，需要持久化的字段的保存顺序也值得关注。官方的建议是按照<code>Entries</code>、<code>HardState</code>、<code>Snapshot</code>的顺序持久化。因为在<code>raft</code>初始化加载<code>HardState</code>时，会检查<em>commit index</em>是否在[<em>snapshot last index</em>, <em>log last index</em>)范围内，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// raft.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">raft</span><span class="p">)</span> <span class="nf">loadState</span><span class="p">(</span><span class="nx">state</span> <span class="nx">pb</span><span class="p">.</span><span class="nx">HardState</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">state</span><span class="p">.</span><span class="nx">Commit</span> <span class="p">&lt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nx">committed</span> <span class="o">||</span> <span class="nx">state</span><span class="p">.</span><span class="nx">Commit</span> <span class="p">&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">lastIndex</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">r</span><span class="p">.</span><span class="nx">logger</span><span class="p">.</span><span class="nf">Panicf</span><span class="p">(</span><span class="s">&#34;%x state.commit %d is out of range [%d, %d]&#34;</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span> <span class="nx">state</span><span class="p">.</span><span class="nx">Commit</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nx">committed</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nf">lastIndex</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nx">raftLog</span><span class="p">.</span><span class="nx">committed</span> <span class="p">=</span> <span class="nx">state</span><span class="p">.</span><span class="nx">Commit</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nx">Term</span> <span class="p">=</span> <span class="nx">state</span><span class="p">.</span><span class="nx">Term</span>
</span></span><span class="line"><span class="cl">	<span class="nx">r</span><span class="p">.</span><span class="nx">Vote</span> <span class="p">=</span> <span class="nx">state</span><span class="p">.</span><span class="nx">Vote</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>在etcd的预写日志<code>wal</code>的实现中，<code>Entries</code>和<code>HardState</code>时同步落盘的，以避免重启时不一致的问题。</p>
<h2 id="6-总结">6. 总结</h2>
<p>本文会对etcd/raft中Raft日志复制算法的实现与优化进行分析。由于etcd/raft中对日志复制的优化大部分属于实现上的优化，因此本文讲解优化理论的部分较少，而讲解etcd/raft中日志复制实现的部分较多。</p>
<p>因为日志复制的逻辑涉及到的方面多、逻辑复杂、经过数年的版本演进部分逻辑难以理解，因此本文详细地分析了etcd/raft中与日志复制相关的几乎所有逻辑，以供读者参考。这里不建议读者通读本文讲解实现的部分，而是按照自己的节奏阅读源码，在遇到难以理解的部分时可以将本文作为补充参考。</p>
<h2 id="参考文献">参考文献</h2>
<div class="reference">
<p>[1] Ongaro D, Ousterhout J. In search of an understandable consensus algorithm[C]//2014 {USENIX} Annual Technical Conference ({USENIX}{ATC} 14). 2014: 305-319.</p>
<p>[2] Ongaro D, Ousterhout J. In search of an understandable consensus algorithm (extended version)[J]. Retrieved July, 2016, 20: 2018.</p>
<p>[3] Ongaro D. Consensus: Bridging theory and practice[D]. Stanford University, 2014.</p>
<p>[4] <a href="https://youjiali1995.github.io/raft/etcd-raft-log-replication/" target="_blank" rel="noopener noreffer">Raft 笔记(五) – Log replication. 我叫尤加利（技术博客）</a></p>
<p>[5] <a href="https://liqul.github.io/blog/etcd_raft_3" target="_blank" rel="noopener noreffer">Raft协议实现学习之—初始化和Leader Election过程. BUCKET &amp; HAMMER（技术博客）</a>（其中对<code>unstable</code>的讨论存在问题，但该文仍提出了一些很好的问题）</p>
</div></div>

        <div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2020-12-23</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/etcd/">etcd</a>,&nbsp;<a href="/tags/raft/">Raft</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/code-reading/etcdraft-made-simple/3-election/" class="prev" rel="prev" title="深入浅出etcd/raft —— 0x03 Raft选举"><i class="fas fa-angle-left fa-fw"></i>深入浅出etcd/raft —— 0x03 Raft选举</a>
            <a href="/posts/code-reading/etcdraft-made-simple/5-confchange/" class="next" rel="next" title="深入浅出etcd/raft —— 0x05 Raft成员变更">深入浅出etcd/raft —— 0x05 Raft成员变更<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
</article></div>
        </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.104.3">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/HEIGE-PCloud/DoIt" target="_blank" rel="noopener noreffer" title="DoIt 0.2.13"><i class="far fa-edit fa-fw"></i> DoIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2019 - 2023</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="about" target="_blank" rel="noopener noreferrer">叉鸽</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a></span></div>
        </div></footer></div>

    <div id="fixed-buttons"><a href="#back-to-top" id="back-to-top-button" class="fixed-button" title="回到顶部">
            <i class="fas fa-arrow-up fa-fw"></i>
        </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
            <i class="fas fa-comment fa-fw"></i>
        </a>
    </div><div class="assets"><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.stemmer.support.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.zh.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/topbar/topbar.min.js"></script><script type="text/javascript" src="/lib/pjax/pjax.min.js"></script><script type="text/javascript" src="/js/theme.min.js"></script></div>

<div class="pjax-assets"><script type="text/javascript" src="/lib/twemoji/twemoji.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lightgallery.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-thumbnail.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-zoom.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/typeit/typeit.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js"></script><script type="text/javascript" src="/lib/katex/auto-render.min.js"></script><script type="text/javascript" src="/lib/katex/copy-tex.min.js"></script><script type="text/javascript" src="/lib/katex/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10000},"comment":{},"data":{"desktop-header-typeit":"叉鸽 | MrCroxx","mobile-header-typeit":"叉鸽 | MrCroxx"},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"},"twemoji":true,"typeit":{"cursorChar":null,"cursorSpeed":null,"data":{"desktop-header-typeit":["desktop-header-typeit"],"mobile-header-typeit":["mobile-header-typeit"]},"duration":null,"speed":null}};</script><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/lightgallery/lightgallery.min.css">
    <noscript><link rel="stylesheet" href="/lib/lightgallery/lightgallery.min.css"></noscript><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/katex/katex.min.css">
    <noscript><link rel="stylesheet" href="/lib/katex/katex.min.css"></noscript><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/katex/copy-tex.min.css">
    <noscript><link rel="stylesheet" href="/lib/katex/copy-tex.min.css"></noscript></div>
</body>

</html>