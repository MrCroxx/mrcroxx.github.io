<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="noodp" />
    <title class="pjax-title">深入浅出LevelDB —— 09 Compaction - 叉鸽 MrCroxx 的博客</title><meta name="Description" content="Welcome to MrCroxx&#39;s Blog."><meta property="og:title" content="深入浅出LevelDB —— 09 Compaction" />
<meta property="og:description" content="本文为原创文章，转载请严格遵守CC BY-NC-SA协议。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mrcroxx.github.io/posts/code-reading/leveldb-made-simple/9-compaction/" /><meta property="og:image" content="https://mrcroxx.github.io/posts/code-reading/leveldb-made-simple/9-compaction/leveldb.jpg"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-11T14:16:25+08:00" />
<meta property="article:modified_time" content="2021-03-15T23:26:52+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://mrcroxx.github.io/posts/code-reading/leveldb-made-simple/9-compaction/leveldb.jpg"/>
<meta name="twitter:title" content="深入浅出LevelDB —— 09 Compaction"/>
<meta name="twitter:description" content="本文为原创文章，转载请严格遵守CC BY-NC-SA协议。"/>
<meta name="application-name" content="叉鸽 MrCroxx 的博客">
<meta name="apple-mobile-web-app-title" content="叉鸽 MrCroxx 的博客">

<meta name="theme-color" content="#f8f8f8"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="canonical" href="https://mrcroxx.github.io/posts/code-reading/leveldb-made-simple/9-compaction/" /><link rel="prev" href="https://mrcroxx.github.io/posts/code-reading/leveldb-made-simple/8-iterator/" /><link rel="next" href="https://mrcroxx.github.io/posts/code-reading/leveldb-made-simple/10-read-write/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/fontawesome-free/all.min.css">
    <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/animate/animate.min.css">
    <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "深入浅出LevelDB —— 09 Compaction",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/mrcroxx.github.io\/posts\/code-reading\/leveldb-made-simple\/9-compaction\/"
        },"image": [{
                            "@type": "ImageObject",
                            "url": "https:\/\/mrcroxx.github.io\/posts\/code-reading\/leveldb-made-simple\/9-compaction\/leveldb.jpg",
                            "width":  1200 ,
                            "height":  360 
                        }],"genre": "posts","keywords": "LevelDB, LSM-Tree","wordcount":  19249 ,
        "url": "https:\/\/mrcroxx.github.io\/posts\/code-reading\/leveldb-made-simple\/9-compaction\/","datePublished": "2021-03-11T14:16:25+08:00","dateModified": "2021-03-15T23:26:52+08:00","publisher": {
            "@type": "Organization",
            "name": "叉鸽"},"author": {
                "@type": "Person",
                "name": "叉鸽"
            },"description": ""
    }
    </script></head>

<body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">
        function setTheme(theme) {document.body.setAttribute('theme', theme);}
        function saveTheme(theme) {window.localStorage && localStorage.setItem('theme', theme);}
        function getMeta(metaName) {const metas = document.getElementsByTagName('meta'); for (let i = 0; i < metas.length; i++) if (metas[i].getAttribute('name') === metaName) return metas[i]; return '';}
        if (window.localStorage && localStorage.getItem('theme')) {let theme = localStorage.getItem('theme');theme === 'light' || theme === 'dark' || theme === 'black' ? setTheme(theme) : (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light')); } else { if ('' === 'light' || '' === 'dark' || '' === 'black') setTheme(''), saveTheme(''); else saveTheme('auto'), window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light');}
        let metaColors = {'light': '#f8f8f8','dark': '#252627','black': '#000000'}
        getMeta('theme-color').content = metaColors[document.body.getAttribute('theme')];
    </script>
    <div id="back-to-top"></div>
    <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="叉鸽 MrCroxx 的博客"><span id="desktop-header-typeit" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/posts/about-me"> 关于我 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="#" onclick="return false;" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" onclick="return false;" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="#" onclick="return false;" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="叉鸽 MrCroxx 的博客"><span id="mobile-header-typeit" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="#" onclick="return false;" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" onclick="return false;" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="#" onclick="return false;" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/posts/about-me" title="">关于我</a><a href="#" onclick="return false;" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
            <div class="container"><div class="toc" id="toc-auto">
        <h2 class="toc-title">目录</h2>
        <div class="toc-content" id="toc-content-auto"></div>
    </div><script>document.getElementsByTagName("main")[0].setAttribute("pageStyle", "normal")</script><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC", "true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">深入浅出LevelDB —— 09 Compaction</h1><div class="post-meta">
            <div class="post-meta-line">
                <span class="post-author"><i class="author fas fa-user-circle fa-fw"></i><a href="about" title="Author" rel=" author" class="author">叉鸽</a>
                </span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAleveldb/"><i class="far fa-folder fa-fw"></i>深入浅出LevelDB</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-03-11">2021-03-11</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime="2021-03-15">2021-03-15</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 19249 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 39 分钟&nbsp;</div>
        </div><div class="featured-image"><img
        class="lazyload"
        data-src="/posts/code-reading/leveldb-made-simple/9-compaction/leveldb.jpg"
        data-srcset="/posts/code-reading/leveldb-made-simple/9-compaction/leveldb.jpg, /posts/code-reading/leveldb-made-simple/9-compaction/leveldb.jpg 1.5x, /posts/code-reading/leveldb-made-simple/9-compaction/leveldb.jpg 2x"
        data-sizes="auto"
        alt="/posts/code-reading/leveldb-made-simple/9-compaction/leveldb.jpg"
        title="/posts/code-reading/leveldb-made-simple/9-compaction/leveldb.jpg" height="360" width="1200"
    /></div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#0-引言">0. 引言</a></li>
    <li><a href="#1-compaction的类型">1. Compaction的类型</a></li>
    <li><a href="#2-compaction的触发">2. Compaction的触发</a>
      <ul>
        <li><a href="#21-后台线程">2.1 后台线程</a></li>
        <li><a href="#22-compaction优先级">2.2 Compaction优先级</a></li>
        <li><a href="#23-minor-compaction的触发">2.3 Minor Compaction的触发</a></li>
        <li><a href="#24-size-compaction的触发">2.4 Size Compaction的触发</a></li>
        <li><a href="#25-seek-compaction的触发">2.5 Seek Compaction的触发</a></li>
        <li><a href="#26-manual-compaction的触发">2.6 Manual Compaction的触发</a></li>
      </ul>
    </li>
    <li><a href="#3-compaction的范围">3. Compaction的范围</a>
      <ul>
        <li><a href="#31-minor-compaction范围的确定">3.1 Minor Compaction范围的确定</a></li>
        <li><a href="#32-major-compaction">3.2 Major Compaction</a>
          <ul>
            <li><a href="#321-major-compaction的范围">3.2.1 Major Compaction的范围</a></li>
            <li><a href="#322-size-compaction与seek-compaction的范围">3.2.2 Size Compaction与Seek Compaction的范围</a></li>
            <li><a href="#323-manual-compaction的范围">3.2.3 Manual Compaction的范围</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#4-compaction的执行">4. Compaction的执行</a>
      <ul>
        <li><a href="#41-后台线程compaction入口">4.1 后台线程Compaction入口</a></li>
        <li><a href="#42-minor-compaction">4.2 Minor Compaction</a></li>
        <li><a href="#43-major-compaction">4.3 Major Compaction</a></li>
        <li><a href="#44-compaction清理">4.4 Compaction清理</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><p><em>本文为原创文章，转载请严格遵守<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener noreffer">CC BY-NC-SA协议</a>。</em></p>
<h2 id="0-引言">0. 引言</h2>
<p>正如Rebalance与Spill之于B+Tree，Compaction操作是LSM-Tree的核心。</p>
<p>本节将介绍并分析LevelDB中LSM-Tree的Compaction操作的实现。</p>
<h2 id="1-compaction的类型">1. Compaction的类型</h2>
<p>LevelDB中LSM-Tree的Compaction操作分为两类，分别是Minor Compaction与Major Compaction。</p>
<ul>
<li>Minor Compaction（Immutable MemTable -&gt; SSTable）：将Immutable MemTable转储为level-0 SSTable写入。</li>
<li>Major Compaction（Low-level SSTable -&gt; High-level SSTable）：合并压缩第i层的SSTable，生成第i+1层的SSTable。</li>
</ul>
<p>在LevelDB中，Major Compaction还可以按照触发条件分为三类：</p>
<ul>
<li>Size Compaction：根据每层总SSTable大小触发（level-0根据SSTable数）的Major Compaction。</li>
<li>Seek Compaction：根据SSTable的seek miss触发的Major Compaction。</li>
<li>Manual Compaction：LevelDB使用者通过接口<code>void CompactRange(const Slice* begin, const Slice* end)</code>手动触发。</li>
</ul>
<p>下面我们具体分析各种Compaction的触发时机。</p>
<h2 id="2-compaction的触发">2. Compaction的触发</h2>
<p>在介绍LevelDB中Compaction的触发时机前，我们先来了解一下LevelDB的后台线程。</p>
<h3 id="21-后台线程">2.1 后台线程</h3>
<p>为了防止Compaction执行时阻塞LevelDB的正常读写，LevelDB的所有Compaction都通过一个后台线程执行。LevelDB的后台线程的实现依赖系统环境，因此其接口定义在了<code>include/leveldb/env.h</code>中，在不同环境中的实现分别位于<code>util/env_windows.cc</code>与<code>env_posix.cc</code>中。本文只考虑其在POSIX环境下的实现。</p>
<p>如果需要Compaction，LevelDB会通过如下代码调度后台线程：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">DBImpl</span><span class="o">::</span><span class="n">MaybeScheduleCompaction</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">//... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">env_</span><span class="o">-&gt;</span><span class="n">Schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">DBImpl</span><span class="o">::</span><span class="n">BGWork</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">DBImpl</span><span class="o">::</span><span class="n">BGWork</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">db</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">DBImpl</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">db</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">BackgroundCall</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>该方法调用了<code>include/leveldb/env.h</code>中定义的<code>Schedule</code>接口，我们先来看看其接口定义上的注释：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Arrange to run &#34;(*function)(arg)&#34; once in a background thread.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// &#34;function&#34; may run in an unspecified thread.  Multiple functions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// added to the same Env may run concurrently in different threads.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// I.e., the caller may not assume that background work items are
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// serialized.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">Schedule</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">),</span> <span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span></code></pre></div><p>从该接口上的注释可以看出，该接口会安排后台线程执行一次传入的方法。且该接口既不保证后台线程仅单线程执行，也不传入的方法保序执行。</p>
<p>下面我们来分析<code>Schedule</code>及其相关方法在POSIX环境下的实现。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">PosixEnv</span><span class="o">::</span><span class="n">Schedule</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">background_work_function</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span> <span class="n">background_work_arg</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span><span class="o">*</span> <span class="n">background_work_arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">background_work_mutex_</span><span class="p">.</span><span class="n">Lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Start the background thread, if we haven&#39;t done so already.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">started_background_thread_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">started_background_thread_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">background_thread</span><span class="p">(</span><span class="n">PosixEnv</span><span class="o">::</span><span class="n">BackgroundThreadEntryPoint</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">background_thread</span><span class="p">.</span><span class="n">detach</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// If the queue is empty, the background thread may be waiting for work.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">background_work_queue_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">background_work_cv_</span><span class="p">.</span><span class="n">Signal</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">background_work_queue_</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">background_work_function</span><span class="p">,</span> <span class="n">background_work_arg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">background_work_mutex_</span><span class="p">.</span><span class="n">Unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>该方法首先检测后台线程是否创建，如果没有创建创建后台线程。接下来会将任务放入后台线程的任务队列中，并通过信号量唤醒后台线程执行。创建后台线程与操作任务队列都需要通过锁来保护，因此该方法全程加锁。</p>
<p>下面是后台线程的逻辑：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="kt">void</span> <span class="nf">BackgroundThreadEntryPoint</span><span class="p">(</span><span class="n">PosixEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">env</span><span class="o">-&gt;</span><span class="n">BackgroundThreadMain</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">PosixEnv</span><span class="o">::</span><span class="n">BackgroundThreadMain</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">background_work_mutex_</span><span class="p">.</span><span class="n">Lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Wait until there is work to be done.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">background_work_queue_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">background_work_cv_</span><span class="p">.</span><span class="n">Wait</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">background_work_queue_</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="k">auto</span> <span class="n">background_work_function</span> <span class="o">=</span> <span class="n">background_work_queue_</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">function</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span><span class="o">*</span> <span class="n">background_work_arg</span> <span class="o">=</span> <span class="n">background_work_queue_</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">arg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">background_work_queue_</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">background_work_mutex_</span><span class="p">.</span><span class="n">Unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">background_work_function</span><span class="p">(</span><span class="n">background_work_arg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>后台线程会循环获取任务丢列中的任务，为了避免线程空转，在队列为空时通过信号量等待唤醒。如果队列中有任务，则获取该任务并将任务出队，然后执行任务。后台线程中操作队列的部分需要通过锁来保护，而执行任务时没有上锁，可以并行执行（但是LevelDB只使用了1个后台线程，因此Compaction仍是串行而不是并行的）。</p>
<h3 id="22-compaction优先级">2.2 Compaction优先级</h3>
<p>LevelDB中Compaction具有优先级，其顺序为：Minor Compaction &gt; Manual Compaction &gt; Size Compaction &gt; Seek Compaction。本节将根据源码来分析这一优先级的体现。</p>
<p>无论是Minor Compaction还是Major Compaction，在设置了相应的参数后，都会通过<code>DBImpl::MaybeScheduleCompaction</code>方法来判断是否需要执行Compaction。该方法实现如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">DBImpl</span><span class="o">::</span><span class="n">MaybeScheduleCompaction</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">mutex_</span><span class="p">.</span><span class="n">AssertHeld</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">background_compaction_scheduled_</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Already scheduled
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">shutting_down_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// DB is being deleted; no more background compactions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bg_error_</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Already got an error; no more changes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">imm_</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">manual_compaction_</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">             <span class="o">!</span><span class="n">versions_</span><span class="o">-&gt;</span><span class="n">NeedsCompaction</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// No work to be done
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">background_compaction_scheduled_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">env_</span><span class="o">-&gt;</span><span class="n">Schedule</span><span class="p">(</span><span class="o">&amp;</span><span class="n">DBImpl</span><span class="o">::</span><span class="n">BGWork</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>MaybeScheduleCompaction</code>方法是需要在上锁时被调用的，因此其首先断言当前正持有着锁。接下来，其按照顺序做了如下判断：</p>
<ol>
<li>当前是否正在进行Compaction的调度，如果正在调度则不再调度。这里的“调度”开始于<code>Schedule</code>调度后台线程前，结束于后台线程中<code>BackgroundCompaction</code>方法中完成Compaction操作后。</li>
<li>数据库是否正在关闭，如果数据库已被关闭，则不再调度。</li>
<li>如果后台线程报告了错误，则不再调度。</li>
<li>如果此时还没有Immutable MemTable产生，也没有Major Compaction被触发，则不需要调度。</li>
<li>否则，通过<code>Schedule</code>方法开始新Compaction任务调度。</li>
</ol>
<p><code>MaybeScheduleCompaction</code>方法通过<code>imm_</code>是否为空判断是否需要Minor Compaction，通过<code>manual_compaction</code>判断是否需要Manual Compaction；而是否需要Size Compaction或Seek Compaction，则需要通过当前的VersionSet的<code>NeedsCompaction</code>方法来判断。该方法的实现如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Returns true iff some level needs a compaction.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="nf">NeedsCompaction</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Version</span><span class="o">*</span> <span class="n">v</span> <span class="o">=</span> <span class="n">current_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">compaction_score_</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">file_to_compact_</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><p>该方法只检查了当前Version的两个字段：<code>compaction_score_</code>是否大于1或<code>file_to_compact_</code>是否不为空。其中<code>compaction_score_</code>字段用来计算是否需要触发Size Compaction，<code>file_to_compact_</code>用来计算是否需要触发Seek Compaction。关于这两个字段的计算会在下文介绍。</p>
<p>在了解LevelDB中Compaction整体的触发条件后，下面我们来分析每种Compaction具体的触发方式。</p>
<h3 id="23-minor-compaction的触发">2.3 Minor Compaction的触发</h3>
<p>Minor Compaction在MemTable大小超过限制时（默认为4MB）触发，LevelDB在写入变更前，首先会通过<code>DBImpl::MakeRoomForWrite</code>方法来在MemTable过大时将其转为Immutable MemTable，在该方法中，我们也能够找到尝试触发Compcation调度的调用。这里我们完整地看一下<code>DBImpl::MakeRoomForWrite</code>的实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// REQUIRES: mutex_ is held
</span></span></span><span class="line"><span class="cl"><span class="c1">// REQUIRES: this thread is currently at the front of the writer queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Status</span> <span class="n">DBImpl</span><span class="o">::</span><span class="n">MakeRoomForWrite</span><span class="p">(</span><span class="kt">bool</span> <span class="n">force</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">mutex_</span><span class="p">.</span><span class="n">AssertHeld</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">writers_</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">allow_delay</span> <span class="o">=</span> <span class="o">!</span><span class="n">force</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Status</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bg_error_</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Yield previous error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">s</span> <span class="o">=</span> <span class="n">bg_error_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">allow_delay</span> <span class="o">&amp;&amp;</span> <span class="n">versions_</span><span class="o">-&gt;</span><span class="n">NumLevelFiles</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;=</span>
</span></span><span class="line"><span class="cl">                                  <span class="n">config</span><span class="o">::</span><span class="n">kL0_SlowdownWritesTrigger</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// We are getting close to hitting a hard limit on the number of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// L0 files.  Rather than delaying a single write by several
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// seconds when we hit the hard limit, start delaying each
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// individual write by 1ms to reduce latency variance.  Also,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// this delay hands over some CPU to the compaction thread in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// case it is sharing the same core as the writer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">mutex_</span><span class="p">.</span><span class="n">Unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">env_</span><span class="o">-&gt;</span><span class="n">SleepForMicroseconds</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">allow_delay</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>  <span class="c1">// Do not delay a single write more than once
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">mutex_</span><span class="p">.</span><span class="n">Lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">force</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">               <span class="p">(</span><span class="n">mem_</span><span class="o">-&gt;</span><span class="n">ApproximateMemoryUsage</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">options_</span><span class="p">.</span><span class="n">write_buffer_size</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// There is room in current memtable
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">imm_</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// We have filled up the current memtable, but the previous
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// one is still being compacted, so we wait.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">Log</span><span class="p">(</span><span class="n">options_</span><span class="p">.</span><span class="n">info_log</span><span class="p">,</span> <span class="s">&#34;Current memtable full; waiting...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">background_work_finished_signal_</span><span class="p">.</span><span class="n">Wait</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">versions_</span><span class="o">-&gt;</span><span class="n">NumLevelFiles</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">config</span><span class="o">::</span><span class="n">kL0_StopWritesTrigger</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// There are too many level-0 files.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">Log</span><span class="p">(</span><span class="n">options_</span><span class="p">.</span><span class="n">info_log</span><span class="p">,</span> <span class="s">&#34;Too many L0 files; waiting...</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">background_work_finished_signal_</span><span class="p">.</span><span class="n">Wait</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Attempt to switch to a new memtable and trigger compaction of old
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">assert</span><span class="p">(</span><span class="n">versions_</span><span class="o">-&gt;</span><span class="n">PrevLogNumber</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="kt">uint64_t</span> <span class="n">new_log_number</span> <span class="o">=</span> <span class="n">versions_</span><span class="o">-&gt;</span><span class="n">NewFileNumber</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">WritableFile</span><span class="o">*</span> <span class="n">lfile</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">s</span> <span class="o">=</span> <span class="n">env_</span><span class="o">-&gt;</span><span class="n">NewWritableFile</span><span class="p">(</span><span class="n">LogFileName</span><span class="p">(</span><span class="n">dbname_</span><span class="p">,</span> <span class="n">new_log_number</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">lfile</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Avoid chewing through file number space in a tight loop.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">versions_</span><span class="o">-&gt;</span><span class="n">ReuseFileNumber</span><span class="p">(</span><span class="n">new_log_number</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">delete</span> <span class="n">log_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">delete</span> <span class="n">logfile_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">logfile_</span> <span class="o">=</span> <span class="n">lfile</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">logfile_number_</span> <span class="o">=</span> <span class="n">new_log_number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">log_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">log</span><span class="o">::</span><span class="n">Writer</span><span class="p">(</span><span class="n">lfile</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">imm_</span> <span class="o">=</span> <span class="n">mem_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">has_imm_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">mem_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MemTable</span><span class="p">(</span><span class="n">internal_comparator_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">mem_</span><span class="o">-&gt;</span><span class="n">Ref</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">force</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>  <span class="c1">// Do not force another compaction if have room
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">MaybeScheduleCompaction</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>DBImpl::MakeRoomForWrite</code>方法执行了以下功能：</p>
<ol>
<li>通过断言确保当前持有着锁。</li>
<li>如果后台线程报错，退出执行。</li>
<li>如果当前level-0中的SSTable数即将超过最大限制（默认为8，而当level-0的SSTable数达到4时即可触发Minor Compaction），这可能是写入过快导致的。此时会开启流控，将每条写入都推迟1ms，以给Minor Compaction留出时间。如果调用该方法时参数<code>force</code>为true，则不会触发流控。</li>
<li>如果<code>force</code>为false且MemTable估算的大小没有超过限制（默认为4MB），则直接退出，不需要进行Minor Compaction。</li>
<li>如果此时有未完成Minor Compaction的Immutable MemTable，此时循环等待Minor Compaction执行完成再执行。</li>
<li>如果当前level-0层的SSTable数过多（默认为8），此时循环等待level-0层SSTable数低于该上限，以避免level-0层SSTable过多</li>
<li>否则，首先打开新的WAL文件用来记录后续操作，并释放旧的WAL文件。然后将当前的MemTable转为Immutable，调用<code>MaybeScheduleCompaction</code>方法尝试通过后台线程调度Compcation执行（此时<code>imm_</code>会引用旧的MemTable，以让<code>MaybeScheduleCompaction</code>得知当前需要Minor Compaction）。</li>
</ol>
<p><code>DBImpl::MakeRoomForWrite</code>方法在判断是否需要进行Minor Compaction时，LevelDB通过流控与等待的方式，避免level-0层SSTable数过多。这是因为level-0层的key之间是有重叠的，因此当查询level-0层SSTable时，需要查找level-0层的所有SSTable。如果level-0层SSTable太多，会严重拖慢查询效率。</p>
<p>从步骤7可以看出，在LevelDB触发Minor Compaction前，其就切换到新的WAL写入。如果Minor Compaction失败，此时可能需要从该Minor Compaction前的WAL恢复。在<a href="/posts/code-reading/leveldb-made-simple/6-version/" rel="">深入浅出LevelDB —— 06 Version</a>介绍LevelDB的恢复中可知，当前版本的LevelDB会查找所有仍存在的WAL文件并恢复；而如果Minor Comapction未完成，LevelDB不会删除旧的WAL。因此，这里不会出现数据丢失问题。LevelDB这样做是为了在保证安全地情况下，避免Minor Compaction操作阻塞对LevelDB的正常读写，详见本系列<a href="/posts/code-reading/leveldb-made-simple/3-log/#2-log%e7%9a%84%e5%ae%9e%e7%8e%b0" rel="">深入浅出LevelDB —— 03 Log</a>的2.4节。</p>
<h3 id="24-size-compaction的触发">2.4 Size Compaction的触发</h3>
<p>Size Compaction在非level-0层是根据该层的总SSTable大小触发的，而在level-0层是根据该层SSTable数触发的。也就是说，只有发生了Compaction，才有可能触发Size Compaction。因为Compaction的执行会导致Version的更新，因此LevelDB在<code>VersionSet::LogAndApply</code>方法更新Version后，让其调用<code>VersionSet::Finalize</code>方法来计算每层SSTable是否需要Size Compaction，并选出最需要进行Size Compaction的层作为下次Size Compaction的目标。</p>
<p><code>VersionSet::Finalize</code>方法实现如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">VersionSet</span><span class="o">::</span><span class="n">Finalize</span><span class="p">(</span><span class="n">Version</span><span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Precomputed best level for next compaction
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">best_level</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">double</span> <span class="n">best_score</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="n">config</span><span class="o">::</span><span class="n">kNumLevels</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">level</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">score</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// We treat level-0 specially by bounding the number of files
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// instead of number of bytes for two reasons:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// (1) With larger write-buffer sizes, it is nice not to do too
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// many level-0 compactions.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// (2) The files in level-0 are merged on every read and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// therefore we wish to avoid too many files when the individual
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// file size is small (perhaps because of a small write-buffer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// setting, or very high compression ratios, or lots of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// overwrites/deletions).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">score</span> <span class="o">=</span> <span class="n">v</span><span class="o">-&gt;</span><span class="n">files_</span><span class="p">[</span><span class="n">level</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span>
</span></span><span class="line"><span class="cl">              <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">config</span><span class="o">::</span><span class="n">kL0_CompactionTrigger</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Compute the ratio of current size to size limit.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">level_bytes</span> <span class="o">=</span> <span class="n">TotalFileSize</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">files_</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">      <span class="n">score</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">          <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">level_bytes</span><span class="p">)</span> <span class="o">/</span> <span class="n">MaxBytesForLevel</span><span class="p">(</span><span class="n">options_</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">score</span> <span class="o">&gt;</span> <span class="n">best_score</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">best_level</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">best_score</span> <span class="o">=</span> <span class="n">score</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">v</span><span class="o">-&gt;</span><span class="n">compaction_level_</span> <span class="o">=</span> <span class="n">best_level</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">v</span><span class="o">-&gt;</span><span class="n">compaction_score_</span> <span class="o">=</span> <span class="n">best_score</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>该方法计算了每层需要Size Compaction的<code>score</code>，并选出<code>score</code>最大的层作为下次Size Compaction的目标（如果<code>score</code>小于1，会被<code>MaybeScheduleCompaction</code>方法忽略）。其计算依据为：</p>
<ol>
<li>对于level-0，计算该层SSTable数与应触发level-0 Compaction的SSTable数的比值（默认为4）作为score。</li>
<li>对于非level-0，计算该层SSTable总大小与该层预设大小的比值作为score。level-1层的预设大小为10MB，之后每层依次*10。</li>
</ol>
<p>计算完score后，需要等待Size Compaction的触发。Size Compaction的触发发生在后台线程调用的<code>DBImpl::BackgroundCall</code>方法中。该方法在完成Compaction操作后，会再次调用<code>MaybeScheduleCompaction</code>方法，来触发因上次Compaction而需要的Size Compaction操作。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">DBImpl</span><span class="o">::</span><span class="n">BackgroundCall</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Previous compaction may have produced too many files in a level,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// so reschedule another compaction if needed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">MaybeScheduleCompaction</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">background_work_finished_signal_</span><span class="p">.</span><span class="n">SignalAll</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="25-seek-compaction的触发">2.5 Seek Compaction的触发</h3>
<p>在介绍Seek Compaction触发条件前，我们先来看为什么需要Seek Compaction。</p>
<p>在LSM-Tree中，除了level-0外，虽然每个level的SSTable间相互没有overlap，但是level与level间的SSTable是可以有overlap的，如下图中的实例所示。</p>
<p><figure><a class="lightgallery" href="/posts/code-reading/leveldb-made-simple/9-compaction/assets/overlap.svg" title="overlap" data-thumbnail="/posts/code-reading/leveldb-made-simple/9-compaction/assets/overlap.svg" data-sub-html="<h2>overlap</h2><p>overlap</p>">
        <img
            class="lazyload"
            data-src="assets/overlap.svg"
            data-srcset="/posts/code-reading/leveldb-made-simple/9-compaction/assets/overlap.svg, assets/overlap.svg 1.5x, /posts/code-reading/leveldb-made-simple/9-compaction/assets/overlap.svg 2x"
            data-sizes="auto"
            alt="/posts/code-reading/leveldb-made-simple/9-compaction/assets/overlap.svg"
        />
    </a><figcaption class="image-caption">overlap</figcaption>
    </figure></p>
<p>在本例中，如果查找键<code>18</code>时在level-k前都没有命中，则查询会下推到level-k。在level-k层中，因为SSTable(k, i)的key范围覆盖了<code>18</code>，LevelDB会在该SSTable中查找是否存在要查找的key <code>18</code>（实际上查找的是该SSTable在TableCache中的filter），该操作被称为“seek”。当LevelDB在level-k中没有找到要查找的key时，才会继续在level-(k+1)中查找。</p>
<p><figure><a class="lightgallery" href="/posts/code-reading/leveldb-made-simple/9-compaction/assets/seek-miss.svg" title="seek miss" data-thumbnail="/posts/code-reading/leveldb-made-simple/9-compaction/assets/seek-miss.svg" data-sub-html="<h2>seek miss</h2><p>seek miss</p>">
        <img
            class="lazyload"
            data-src="assets/seek-miss.svg"
            data-srcset="/posts/code-reading/leveldb-made-simple/9-compaction/assets/seek-miss.svg, assets/seek-miss.svg 1.5x, /posts/code-reading/leveldb-made-simple/9-compaction/assets/seek-miss.svg 2x"
            data-sizes="auto"
            alt="/posts/code-reading/leveldb-made-simple/9-compaction/assets/seek-miss.svg"
        />
    </a><figcaption class="image-caption">seek miss</figcaption>
    </figure></p>
<p>在上图的示例中，每当LevelDB要查找key <code>18</code>时，因为SSTable(k, i)的key范围覆盖了<code>18</code>，所以其每次都必须在该SSTable中seek，这一不必要的seek操作会导致性能下降。因此，在FileMetaData结构体中引入了<code>allowed_seeks</code>字段，该字段初始为文件大小与16KB的比值，不足100则取100；每次无效seek发生时LevelDB都会将该字段值减1。当某SSTable的<code>allowed_seeks</code>减为0时，会触发seek compaction，该SSTable会与下层部分SSTable合并。合并后的SSTable如下图所示。</p>
<p><figure><a class="lightgallery" href="/posts/code-reading/leveldb-made-simple/9-compaction/assets/match.svg" title="match" data-thumbnail="/posts/code-reading/leveldb-made-simple/9-compaction/assets/match.svg" data-sub-html="<h2>match</h2><p>match</p>">
        <img
            class="lazyload"
            data-src="assets/match.svg"
            data-srcset="/posts/code-reading/leveldb-made-simple/9-compaction/assets/match.svg, assets/match.svg 1.5x, /posts/code-reading/leveldb-made-simple/9-compaction/assets/match.svg 2x"
            data-sizes="auto"
            alt="/posts/code-reading/leveldb-made-simple/9-compaction/assets/match.svg"
        />
    </a><figcaption class="image-caption">match</figcaption>
    </figure></p>
<div class="details admonition quote open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-quote-right fa-fw"></i>引文<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p><code>allow_seeks</code>字段初始值取值原因：</p>
<pre><code>  // We arrange to automatically compact this file after
  // a certain number of seeks.  Let's assume:
  //   (1) One seek costs 10ms
  //   (2) Writing or reading 1MB costs 10ms (100MB/s)
  //   (3) A compaction of 1MB does 25MB of IO:
  //         1MB read from this level
  //         10-12MB read from next level (boundaries may be misaligned)
  //         10-12MB written to next level
  // This implies that 25 seeks cost the same as the compaction
  // of 1MB of data.  I.e., one seek costs approximately the
  // same as the compaction of 40KB of data.  We are a little
  // conservative and allow approximately one seek for every 16KB
  // of data before triggering a compaction.
</code></pre>
</div>
        </div>
    </div>
<p>合并后，当LevelDB需要查找key <code>18</code>时，在level-k中便没有了覆盖key <code>18</code>的SSTable，因此会直接在level-(k+1)中找到该key所在的SSTable。这样便避免这次无效的seek。</p>
<p>因为Seek Compcation的触发需要在SSTable上seek，因此我们从<code>DBImpl::Get</code>方法查找SSTable时开始分析。由于LevelDB的查找操作涉及到多层，笔者将在本系列的后续文章中详细介绍其流程，本文尽可能屏蔽目前不需要的细节。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Status</span> <span class="n">DBImpl</span><span class="o">::</span><span class="n">Get</span><span class="p">(</span><span class="k">const</span> <span class="n">ReadOptions</span><span class="o">&amp;</span> <span class="n">options</span><span class="p">,</span> <span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                   <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  
</span></span><span class="line"><span class="cl">  <span class="n">Version</span><span class="o">::</span><span class="n">GetStats</span> <span class="n">stats</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Unlock while reading from files and memtables
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">mutex_</span><span class="p">.</span><span class="n">Unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// First look in the memtable, then in the immutable memtable (if any).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">LookupKey</span> <span class="nf">lkey</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">snapshot</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">Get</span><span class="p">(</span><span class="n">lkey</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Done
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">imm</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">imm</span><span class="o">-&gt;</span><span class="n">Get</span><span class="p">(</span><span class="n">lkey</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Done
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">s</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">Get</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">lkey</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stats</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">have_stat_update</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">mutex_</span><span class="p">.</span><span class="n">Lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">have_stat_update</span> <span class="o">&amp;&amp;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">UpdateStats</span><span class="p">(</span><span class="n">stats</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">MaybeScheduleCompaction</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>当LevelDB查找key时，会记录一些统计信息。当在SSTable上发生查找时，会记录发生seek miss的 SSTable，这样会更新Version中其相应的FileMetaData中的<code>allowed_seeks</code>字段，并通过<code>MaybeScheduleCompaction</code>检查是否需要触发Seek Compaction。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Lookup the value for key.  If found, store it in *val and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// return OK.  Else return a non-OK status.  Fills *stats.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// REQUIRES: lock is not held
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="nc">GetStats</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">FileMetaData</span><span class="o">*</span> <span class="n">seek_file</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">seek_file_level</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">Status</span> <span class="n">Version</span><span class="o">::</span><span class="n">Get</span><span class="p">(</span><span class="k">const</span> <span class="n">ReadOptions</span><span class="o">&amp;</span> <span class="n">options</span><span class="p">,</span> <span class="k">const</span> <span class="n">LookupKey</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">value</span><span class="p">,</span> <span class="n">GetStats</span><span class="o">*</span> <span class="n">stats</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">stats</span><span class="o">-&gt;</span><span class="n">seek_file</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">stats</span><span class="o">-&gt;</span><span class="n">seek_file_level</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">struct</span> <span class="nc">State</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Saver</span> <span class="n">saver</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">GetStats</span><span class="o">*</span> <span class="n">stats</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">ReadOptions</span><span class="o">*</span> <span class="n">options</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Slice</span> <span class="n">ikey</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">FileMetaData</span><span class="o">*</span> <span class="n">last_file_read</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">last_file_read_level</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">VersionSet</span><span class="o">*</span> <span class="n">vset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Status</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">found</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">bool</span> <span class="nf">Match</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="n">FileMetaData</span><span class="o">*</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">State</span><span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">State</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">seek_file</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">          <span class="n">state</span><span class="o">-&gt;</span><span class="n">last_file_read</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// We have had more than one seek for this read.  Charge the 1st file.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">state</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">seek_file</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">last_file_read</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="o">-&gt;</span><span class="n">stats</span><span class="o">-&gt;</span><span class="n">seek_file_level</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">last_file_read_level</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">state</span><span class="o">-&gt;</span><span class="n">last_file_read</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">state</span><span class="o">-&gt;</span><span class="n">last_file_read_level</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">state</span><span class="o">-&gt;</span><span class="n">s</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">vset</span><span class="o">-&gt;</span><span class="n">table_cache_</span><span class="o">-&gt;</span><span class="n">Get</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">options</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                                <span class="n">f</span><span class="o">-&gt;</span><span class="n">file_size</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">ikey</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                                <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">saver</span><span class="p">,</span> <span class="n">SaveValue</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">state</span><span class="o">-&gt;</span><span class="n">found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">saver</span><span class="p">.</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">kNotFound</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>  <span class="c1">// Keep searching in other files
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">case</span> <span class="nl">kFound</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="n">state</span><span class="o">-&gt;</span><span class="n">found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">kDeleted</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">case</span> <span class="nl">kCorrupt</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">          <span class="n">state</span><span class="o">-&gt;</span><span class="n">s</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">              <span class="n">Status</span><span class="o">::</span><span class="n">Corruption</span><span class="p">(</span><span class="s">&#34;corrupted key for &#34;</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">saver</span><span class="p">.</span><span class="n">user_key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="n">state</span><span class="o">-&gt;</span><span class="n">found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// Not reached. Added to avoid false compilation warnings of
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// &#34;control reaches end of non-void function&#34;.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">State</span> <span class="n">state</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="p">.</span><span class="n">found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="p">.</span><span class="n">stats</span> <span class="o">=</span> <span class="n">stats</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="p">.</span><span class="n">last_file_read</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="p">.</span><span class="n">last_file_read_level</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="p">.</span><span class="n">options</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">options</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="p">.</span><span class="n">ikey</span> <span class="o">=</span> <span class="n">k</span><span class="p">.</span><span class="n">internal_key</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="p">.</span><span class="n">vset</span> <span class="o">=</span> <span class="n">vset_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="p">.</span><span class="n">saver</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">kNotFound</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="p">.</span><span class="n">saver</span><span class="p">.</span><span class="n">ucmp</span> <span class="o">=</span> <span class="n">vset_</span><span class="o">-&gt;</span><span class="n">icmp_</span><span class="p">.</span><span class="n">user_comparator</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="p">.</span><span class="n">saver</span><span class="p">.</span><span class="n">user_key</span> <span class="o">=</span> <span class="n">k</span><span class="p">.</span><span class="n">user_key</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">state</span><span class="p">.</span><span class="n">saver</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">ForEachOverlapping</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">saver</span><span class="p">.</span><span class="n">user_key</span><span class="p">,</span> <span class="n">state</span><span class="p">.</span><span class="n">ikey</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">State</span><span class="o">::</span><span class="n">Match</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">state</span><span class="p">.</span><span class="n">found</span> <span class="o">?</span> <span class="n">state</span><span class="p">.</span><span class="nl">s</span> <span class="p">:</span> <span class="n">Status</span><span class="o">::</span><span class="n">NotFound</span><span class="p">(</span><span class="n">Slice</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>这里笔者给出<code>Version::Get</code>方法的实现，但本文我们只需要关注其中<code>State</code>结构体及其<code>Match</code>方法的实现，其它部分笔者会在本系列后续文章中介绍。<code>Version::Get</code>方法会通过<code> Version::ForEachOverlapping</code>方法来逐层遍历覆盖了给定LookUpKey的SSTable，并在该SSTable上调用<code>State::Match</code>判断其中是否有我们想要查找的InternalKey，即只要发生了seek就会调用<code>State::Match</code>方法。如果在该SSTable中没有找到需要的key，该方法会返回true表示需要继续查找；如果找到了需要查找的key，则返回false表示不再需要继续查找。<code>State::Match</code>方法还会记录<strong>第一次</strong>发生seek miss的SSTable。随后<code>DBImpl::Get</code>会将该SSTable的<code>allowed_seeks</code>减一,并通过<code>MaybeScheduleCompaction</code>检查是否需要触发Seek Compaction。</p>
<h3 id="26-manual-compaction的触发">2.6 Manual Compaction的触发</h3>
<p>Manual Comapction的触发时机比较简单，当LevelDB的用户调用<code>DB::CompactRange</code>接口时，LevelDB会检查用户给定的Compact范围与当前状态，判断是否需要执行Manual Compaction。如果确定执行Manual Compaction，则设置<code>manual_compaction_</code>，再调用<code> MaybeScheduleCompaction</code>方法以尝试触发Manual Compaction。</p>
<h2 id="3-compaction的范围">3. Compaction的范围</h2>
<p>Compaction在触发后，首先要确定Compact的范围。本节，笔者将介绍并分析LevelDB中Comapction范围的确定。</p>
<p>LevelDB在确定Minor Compaction范围与Major Compaction范围的方法区别很大，因此这里分别介绍。</p>
<h3 id="31-minor-compaction范围的确定">3.1 Minor Compaction范围的确定</h3>
<p>在LST-Tree的基本概念中，Minor Compaction只需要将Immutable MemTable全量转储为SSTable，并将其推至level-0即可。而LevelDB对这一步骤进行了优化，其会将Minor Comapction生成的SSTable推至更高的层级。该优化的依据如下：</p>
<ul>
<li>由于level 0中SSTable间可能存在overlap，发生在level 0=&gt;1的Major Compaction开销相对较大。为了尽可能避免level 0=&gt;1的Major Compaction开销并避免一些开销较大的Manifest文件操作，LevelDB会将Minor Comapction产生的MemTable尽可能推至更高level。</li>
<li>LevelDB也不会将Minor Compaction产生的SSTable的level推得过高。SSTable的level越高越难被Compaction，因此如果该SSTable中很多Record是override操作，如果不被Compaction会造成很大的空间浪费。</li>
<li>该优化不能破坏LSM-Tree结构。</li>
</ul>
<p>因此计算Minor Compaction范围时需要且只需要确定其生成的SSTable所在的level。其通过<code>Version::PickLevelForMemTableOutput</code>方法实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">Version</span><span class="o">::</span><span class="n">PickLevelForMemTableOutput</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">smallest_user_key</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                        <span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">largest_user_key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OverlapInLevel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smallest_user_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">largest_user_key</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Push to next level if there is no overlap in next level,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// and the #bytes overlapping in the level after that are limited.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">InternalKey</span> <span class="nf">start</span><span class="p">(</span><span class="n">smallest_user_key</span><span class="p">,</span> <span class="n">kMaxSequenceNumber</span><span class="p">,</span> <span class="n">kValueTypeForSeek</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">InternalKey</span> <span class="nf">limit</span><span class="p">(</span><span class="n">largest_user_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">FileMetaData</span><span class="o">*&gt;</span> <span class="n">overlaps</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">level</span> <span class="o">&lt;</span> <span class="n">config</span><span class="o">::</span><span class="n">kMaxMemCompactLevel</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">OverlapInLevel</span><span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smallest_user_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">largest_user_key</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">config</span><span class="o">::</span><span class="n">kNumLevels</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Check that file does not overlap too many grandparent bytes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">GetOverlappingInputs</span><span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">limit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">overlaps</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">TotalFileSize</span><span class="p">(</span><span class="n">overlaps</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="n">MaxGrandParentOverlapBytes</span><span class="p">(</span><span class="n">vset_</span><span class="o">-&gt;</span><span class="n">options_</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="n">level</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">level</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>PickLevelForMemTableOutput</code>方法最初将目标level置为0，并循环判断是否可以将该level推高一层至目标level。其判断条件如下：</p>
<ol>
<li>目标level不能超过配置<code>config::kMaxMemCompactLevel</code>中限制的最大高度（默认为2）。</li>
<li>目标level不能与该level的其它SSTable有overlap。</li>
<li>目标level与其下一层level的overlap不能过多，其计算规则为：首先根据Immutable MemTable的key范围找出目标level的下一层level中与其存在overlap的所有文件；所有与之存在overlap的文件总大小不能超过LevelDB配置中<code>max_file_size</code>大小的10倍（默认为2MB）。</li>
<li>如果满足以上所有条件，则将目标level推至下一层并继续循环。</li>
</ol>
<h3 id="32-major-compaction">3.2 Major Compaction</h3>
<p>LevelDB在进行Major Compaction时，至少需要确定以下参数：</p>
<ol>
<li>确定Compaction起始层级i。</li>
<li>确定level-i层SSTable input。</li>
<li>确定level-(i+1)层中与待Compact的SSTable有overlap的SSTable input。</li>
</ol>
<p>Major Compation生成的SSTable的level即为level-(i+1)。</p>
<p>由于三种Major Compaction的起始条件与目标都不同，其确定这三个参数的方式稍有不同。本节笔者将介绍并分析各种Major Compaction确定Compaction范围的方法与实现。</p>
<h4 id="321-major-compaction的范围">3.2.1 Major Compaction的范围</h4>
<p>LevelDB通过<code>Compaction</code>类（位于<code>db/version_set.h</code>）记录Major Compaction所需元数据：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// A Compaction encapsulates information about a compaction.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Compaction</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"> <span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"> <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="k">friend</span> <span class="k">class</span> <span class="nc">Version</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">friend</span> <span class="k">class</span> <span class="nc">VersionSet</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Compaction</span><span class="p">(</span><span class="k">const</span> <span class="n">Options</span><span class="o">*</span> <span class="n">options</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">level_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint64_t</span> <span class="n">max_output_file_size_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Version</span><span class="o">*</span> <span class="n">input_version_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">VersionEdit</span> <span class="n">edit_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Each compaction reads inputs from &#34;level_&#34; and &#34;level_+1&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">FileMetaData</span><span class="o">*&gt;</span> <span class="n">inputs_</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>  <span class="c1">// The two sets of inputs
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// State used to check for number of overlapping grandparent files
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// (parent == level_ + 1, grandparent == level_ + 2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">FileMetaData</span><span class="o">*&gt;</span> <span class="n">grandparents_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">size_t</span> <span class="n">grandparent_index_</span><span class="p">;</span>  <span class="c1">// Index in grandparent_starts_
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">bool</span> <span class="n">seen_key_</span><span class="p">;</span>             <span class="c1">// Some output key has been seen
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int64_t</span> <span class="n">overlapped_bytes_</span><span class="p">;</span>  <span class="c1">// Bytes of overlap between current output
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                              <span class="c1">// and grandparent files
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// State for implementing IsBaseLevelForKey
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// level_ptrs_ holds indices into input_version_-&gt;levels_: our state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// is that we are positioned at one of the file ranges for each
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// higher level than the ones involved in this compaction (i.e. for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// all L &gt;= level_ + 2).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">size_t</span> <span class="n">level_ptrs_</span><span class="p">[</span><span class="n">config</span><span class="o">::</span><span class="n">kNumLevels</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>本节中我们主要关注以下字段：</p>
<ul>
<li><code>level</code>：Major Compaction的起始level（即上述level-i）。</li>
<li><code>input[0]</code>：level-i层需要Compact的SSTable编号。</li>
<li><code>input[1]</code>：level-(i+1)层需要Compact的SSTable编号。</li>
</ul>
<h4 id="322-size-compaction与seek-compaction的范围">3.2.2 Size Compaction与Seek Compaction的范围</h4>
<p>LevelDB在触发Size Compaction时，已知Compaction的起始层级i；而LevelDB在触发Seek Compaction时，已知Compaction的起始层级i和level-i层的输入SSTable。LevelDB通过<code>VersionSet::PickCompaction</code>方法来计算其它参数：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Compaction</span><span class="o">*</span> <span class="n">VersionSet</span><span class="o">::</span><span class="n">PickCompaction</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Compaction</span><span class="o">*</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// We prefer compactions triggered by too much data in a level over
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// the compactions triggered by seeks.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="kt">bool</span> <span class="n">size_compaction</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_</span><span class="o">-&gt;</span><span class="n">compaction_score_</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">bool</span> <span class="n">seek_compaction</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_</span><span class="o">-&gt;</span><span class="n">file_to_compact_</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">size_compaction</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">level</span> <span class="o">=</span> <span class="n">current_</span><span class="o">-&gt;</span><span class="n">compaction_level_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">level</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">config</span><span class="o">::</span><span class="n">kNumLevels</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Compaction</span><span class="p">(</span><span class="n">options_</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Pick the first file that comes after compact_pointer_[level]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">current_</span><span class="o">-&gt;</span><span class="n">files_</span><span class="p">[</span><span class="n">level</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">FileMetaData</span><span class="o">*</span> <span class="n">f</span> <span class="o">=</span> <span class="n">current_</span><span class="o">-&gt;</span><span class="n">files_</span><span class="p">[</span><span class="n">level</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">compact_pointer_</span><span class="p">[</span><span class="n">level</span><span class="p">].</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">          <span class="n">icmp_</span><span class="p">.</span><span class="n">Compare</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">largest</span><span class="p">.</span><span class="n">Encode</span><span class="p">(),</span> <span class="n">compact_pointer_</span><span class="p">[</span><span class="n">level</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="o">-&gt;</span><span class="n">inputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Wrap-around to the beginning of the key space
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">c</span><span class="o">-&gt;</span><span class="n">inputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">current_</span><span class="o">-&gt;</span><span class="n">files_</span><span class="p">[</span><span class="n">level</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">seek_compaction</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">level</span> <span class="o">=</span> <span class="n">current_</span><span class="o">-&gt;</span><span class="n">file_to_compact_level_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Compaction</span><span class="p">(</span><span class="n">options_</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">inputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">current_</span><span class="o">-&gt;</span><span class="n">file_to_compact_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">c</span><span class="o">-&gt;</span><span class="n">input_version_</span> <span class="o">=</span> <span class="n">current_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">c</span><span class="o">-&gt;</span><span class="n">input_version_</span><span class="o">-&gt;</span><span class="n">Ref</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Files in level 0 may overlap each other, so pick up all overlapping ones
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">InternalKey</span> <span class="n">smallest</span><span class="p">,</span> <span class="n">largest</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">GetRange</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">smallest</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">largest</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Note that the next call will discard the file we placed in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// c-&gt;inputs_[0] earlier and replace it with an overlapping set
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// which will include the picked file.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">current_</span><span class="o">-&gt;</span><span class="n">GetOverlappingInputs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smallest</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">largest</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">empty</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">SetupOtherInputs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>对于Size Compaction，level-i层的SSTable输入根据该level的Compaction Pointer（记录在Version中），选取上次Compaction后的第一个SSTable（如果该层还没发生过Compaction）。这是为了尽可能公平地为Size Compaction选取SSTable，避免某些SSTable永远不会被Compact。</p>
<p>对于Seek Compaction，该方法直接将触发Seek Compaction的SSTable加入到level-i层的输入中。</p>
<p>如果触发Compact的SSTable在level-0，<code>PickCompaction</code>方法会将level-0层中所有与该SSTable有overlap的SSTable加入level-0层的输入中。</p>
<p>在确定了<code>input[0]</code>后，<code>PickCompcation</code>方法会调用<code>VersionSet::SetupOtherInputs</code>方法。该方法首先扩展<code>input[0]</code>范围，然后确定<code>input[1]</code>，即参与Major Compaction的level-(i+1)层的SSTable。扩展<code>input</code>范围的目的是避免Compaction后无法正确查找key版本的问题。这里我们先来看一下这一问题的成因：</p>
<p>在Major Compaction发生前，UserKey <code>cat</code>在level-i层的SSTable中有两个版本，分别为<code>(cat, 101)</code>与<code>(cat, 100)</code>（这里仅关注UserKey与SequenceNumber）。此时，如果LevelDB查找UserKey <code>cat</code>的最新版本，其会首先查找到<code>(cat, 101)</code>，能够得到正常值。</p>
<p><figure><a class="lightgallery" href="/posts/code-reading/leveldb-made-simple/9-compaction/assets/boundary-before.svg" title="Major Compaction发生前" data-thumbnail="/posts/code-reading/leveldb-made-simple/9-compaction/assets/boundary-before.svg" data-sub-html="<h2>Major Compaction发生前</h2><p>Major Compaction发生前</p>">
        <img
            class="lazyload"
            data-src="assets/boundary-before.svg"
            data-srcset="/posts/code-reading/leveldb-made-simple/9-compaction/assets/boundary-before.svg, assets/boundary-before.svg 1.5x, /posts/code-reading/leveldb-made-simple/9-compaction/assets/boundary-before.svg 2x"
            data-sizes="auto"
            alt="/posts/code-reading/leveldb-made-simple/9-compaction/assets/boundary-before.svg"
        />
    </a><figcaption class="image-caption">Major Compaction发生前</figcaption>
    </figure></p>
<p>此时，如果SSTable (i,x)在Major Compaction中与下一层SSTable合并，会导致<code>(cat, 101)</code>位于level-(i+1)，而<code>(cat, 100)</code>位于level-0。</p>
<p><figure><a class="lightgallery" href="/posts/code-reading/leveldb-made-simple/9-compaction/assets/boundary-after.svg" title="Major Compaction发生后" data-thumbnail="/posts/code-reading/leveldb-made-simple/9-compaction/assets/boundary-after.svg" data-sub-html="<h2>Major Compaction发生后</h2><p>Major Compaction发生后</p>">
        <img
            class="lazyload"
            data-src="assets/boundary-after.svg"
            data-srcset="/posts/code-reading/leveldb-made-simple/9-compaction/assets/boundary-after.svg, assets/boundary-after.svg 1.5x, /posts/code-reading/leveldb-made-simple/9-compaction/assets/boundary-after.svg 2x"
            data-sizes="auto"
            alt="/posts/code-reading/leveldb-made-simple/9-compaction/assets/boundary-after.svg"
        />
    </a><figcaption class="image-caption">Major Compaction发生后</figcaption>
    </figure></p>
<p>此时，如果LevelDB再次查找UserKey <code>cat</code>的最新版本，其首先会在level-i中查找到<code>(cat, 100)</code>，因此不会再继续查询level-(i+1)，此时返回了陈旧的值。</p>
<p>为了避免这一问题，LevelDB在进行Major Compaction时，需要Compaction的范围。LevelDB中扩展Compaction输入范围的方法是<code>AddBoundaryInputs</code>，<code>SetupOtherInputs</code>中就是通过调用<code>AddBoundaryInputs</code>方法实现的输入扩展。</p>
<p><code>AddBoundaryInputs</code>方法首先找到当前SSTable中最大的InternalKey记为<code>largest_key</code>，然后在这一level中查找满足其最小UserKey与<code>largest_key</code>相同且最小InternalKey大于<code>largest_key</code>的最小SSTable，将其加入到输入集中，并循环此过程，直到不再有新的SSTable被加入。<code>AddBoundaryInputs</code>方法依赖<code>FindLargestKey</code>与<code>FindSmallestBoundaryFile</code>方法实现了以上逻辑，这里不再赘述。</p>
<p>在介绍了扩展<code>input</code>的原因与方法后，我们来分段分析<code>SetupOtherInputs</code>的实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">VersionSet</span><span class="o">::</span><span class="n">SetupOtherInputs</span><span class="p">(</span><span class="n">Compaction</span><span class="o">*</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// (1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">InternalKey</span> <span class="n">smallest</span><span class="p">,</span> <span class="n">largest</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">AddBoundaryInputs</span><span class="p">(</span><span class="n">icmp_</span><span class="p">,</span> <span class="n">current_</span><span class="o">-&gt;</span><span class="n">files_</span><span class="p">[</span><span class="n">level</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="n">GetRange</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">smallest</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">largest</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">current_</span><span class="o">-&gt;</span><span class="n">GetOverlappingInputs</span><span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">smallest</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">largest</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                 <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inputs_</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// (2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// (3)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// (4)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>首先我们来看(1)段。这部分通过<code>AddBoundaryInputs</code>方法扩展了level-i层参与Compaction的SSTable（即<code>input[0]</code>），然后在level-(i+1)中找到所有与level-i层参与Compaction的SSTable有overlap的SSTable，将其加入到<code>intput[1]</code>中。</p>
<p>初次确定的<code>input</code>范围可能出现下图示例中的情况（注：图中SSTable的宽度表示其key范围，而非文件大小）：</p>
<p><figure><a class="lightgallery" href="/posts/code-reading/leveldb-made-simple/9-compaction/assets/reextend.svg" title="初次确定的input范围" data-thumbnail="/posts/code-reading/leveldb-made-simple/9-compaction/assets/reextend.svg" data-sub-html="<h2>初次确定的input范围</h2><p>初次确定的input范围</p>">
        <img
            class="lazyload"
            data-src="assets/reextend.svg"
            data-srcset="/posts/code-reading/leveldb-made-simple/9-compaction/assets/reextend.svg, assets/reextend.svg 1.5x, /posts/code-reading/leveldb-made-simple/9-compaction/assets/reextend.svg 2x"
            data-sizes="auto"
            alt="/posts/code-reading/leveldb-made-simple/9-compaction/assets/reextend.svg"
        />
    </a><figcaption class="image-caption">初次确定的input范围</figcaption>
    </figure></p>
<p>图中<em>黄色</em>的SSTable是初次选取的input。如图的示例中，由于level-(i+1)层SSTable中的key较为分散，其input范围能够容纳level-i中更多的SSTable（即图中level-i层<em>蓝色</em>的SSTable）。显然，将这些SSTable加入到<code>input[0]</code>中，不需要扩展<code>input[1]</code>的范围。因此，LevelDB会将这部分SSTable一同合并，以减少未来需要的Compaction。</p>
<p><code>SetupOtherInputs</code>的段(2)实现了这一逻辑：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// (2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Get entire range covered by compaction
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">InternalKey</span> <span class="n">all_start</span><span class="p">,</span> <span class="n">all_limit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">GetRange2</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">inputs_</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">all_start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">all_limit</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// See if we can grow the number of inputs in &#34;level&#34; without
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// changing the number of &#34;level+1&#34; files we pick up.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inputs_</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">FileMetaData</span><span class="o">*&gt;</span> <span class="n">expanded0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">current_</span><span class="o">-&gt;</span><span class="n">GetOverlappingInputs</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">all_start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">all_limit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">expanded0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">AddBoundaryInputs</span><span class="p">(</span><span class="n">icmp_</span><span class="p">,</span> <span class="n">current_</span><span class="o">-&gt;</span><span class="n">files_</span><span class="p">[</span><span class="n">level</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">expanded0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">inputs0_size</span> <span class="o">=</span> <span class="n">TotalFileSize</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">inputs1_size</span> <span class="o">=</span> <span class="n">TotalFileSize</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inputs_</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">int64_t</span> <span class="n">expanded0_size</span> <span class="o">=</span> <span class="n">TotalFileSize</span><span class="p">(</span><span class="n">expanded0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">expanded0</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">inputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="n">inputs1_size</span> <span class="o">+</span> <span class="n">expanded0_size</span> <span class="o">&lt;</span>
</span></span><span class="line"><span class="cl">            <span class="n">ExpandedCompactionByteSizeLimit</span><span class="p">(</span><span class="n">options_</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">InternalKey</span> <span class="n">new_start</span><span class="p">,</span> <span class="n">new_limit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">GetRange</span><span class="p">(</span><span class="n">expanded0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_limit</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">FileMetaData</span><span class="o">*&gt;</span> <span class="n">expanded1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">current_</span><span class="o">-&gt;</span><span class="n">GetOverlappingInputs</span><span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_limit</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                     <span class="o">&amp;</span><span class="n">expanded1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">expanded1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">inputs_</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Log</span><span class="p">(</span><span class="n">options_</span><span class="o">-&gt;</span><span class="n">info_log</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="s">&#34;Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">level</span><span class="p">,</span> <span class="kt">int</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">()),</span> <span class="kt">int</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inputs_</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">            <span class="kt">long</span><span class="p">(</span><span class="n">inputs0_size</span><span class="p">),</span> <span class="kt">long</span><span class="p">(</span><span class="n">inputs1_size</span><span class="p">),</span> <span class="kt">int</span><span class="p">(</span><span class="n">expanded0</span><span class="p">.</span><span class="n">size</span><span class="p">()),</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span><span class="p">(</span><span class="n">expanded1</span><span class="p">.</span><span class="n">size</span><span class="p">()),</span> <span class="kt">long</span><span class="p">(</span><span class="n">expanded0_size</span><span class="p">),</span> <span class="kt">long</span><span class="p">(</span><span class="n">inputs1_size</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">smallest</span> <span class="o">=</span> <span class="n">new_start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">largest</span> <span class="o">=</span> <span class="n">new_limit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="o">-&gt;</span><span class="n">inputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">expanded0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="o">-&gt;</span><span class="n">inputs_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">expanded1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">GetRange2</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">inputs_</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">all_start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">all_limit</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><p>从段(2)可以看出，在再次扩展<code>input[0]</code>的范围时，除了需要保证不能引起<code>input[1]</code>的范围变化外，还需要扩展后的<code>input[0]</code>总的大小不超过扩展的限制（默认为25个<code>max_file_size</code>，即50MB）。</p>
<p><code>SetupOtherInputs</code>其余部分的逻辑比较简单：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// (3)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Compute the set of grandparent files that overlap this compaction
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// (parent == level+1; grandparent == level+2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">config</span><span class="o">::</span><span class="n">kNumLevels</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">current_</span><span class="o">-&gt;</span><span class="n">GetOverlappingInputs</span><span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">all_start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">all_limit</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                   <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">grandparents_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// (4)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Update the place where we will do the next compaction for this level.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// We update this immediately instead of waiting for the VersionEdit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// to be applied so that if the compaction fails, we will try a different
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// key range next time.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">compact_pointer_</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">largest</span><span class="p">.</span><span class="n">Encode</span><span class="p">().</span><span class="n">ToString</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">c</span><span class="o">-&gt;</span><span class="n">edit_</span><span class="p">.</span><span class="n">SetCompactPointer</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">largest</span><span class="p">);</span>
</span></span></code></pre></div><p>段(3)计算了level-(i+1)层中与Compaction的范围有overlap的SSTable，以便后续操作使用。段(4)用来设置VersionEdit中记录的Compact Pointer，在Compcation前更新Compact Pointer的好处是：如果本次Compaction失败，则下次Size Compaction发生时，可以跳过这一部分，从下一个位置Compact。</p>
<h4 id="323-manual-compaction的范围">3.2.3 Manual Compaction的范围</h4>
<p>Manual Compaction通过LevelDB提供的接口<code>void CompactRange(const Slice* begin, const Slice* end)</code>触发，其所知Compaction的范围信息最少，只知道需要Compact的起始与终止key，甚至不知道发生Compaction的level。这也意味着，需要Compact的key范围，既可能在MemTable或Immutable Table中，也可能在不同level的SSTable中，甚至二者都有。因此，在Compact的时候需要考虑所有情形。</p>
<p>LevelDB为了确保用户给出的key范围都能够被Compact，其首先强制触发Minor Compaction，然后按照给定的key范围进行Major Compaction。</p>
<p>我们从<code>DB::CompactRange</code>的实现<code>DBImpl::CompactRange</code>开始分析：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">DBImpl</span><span class="o">::</span><span class="n">CompactRange</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">*</span> <span class="n">begin</span><span class="p">,</span> <span class="k">const</span> <span class="n">Slice</span><span class="o">*</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">max_level_with_files</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">MutexLock</span> <span class="nf">l</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">Version</span><span class="o">*</span> <span class="n">base</span> <span class="o">=</span> <span class="n">versions_</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="n">config</span><span class="o">::</span><span class="n">kNumLevels</span><span class="p">;</span> <span class="n">level</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">OverlapInLevel</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">max_level_with_files</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">TEST_CompactMemTable</span><span class="p">();</span>  <span class="c1">// TODO(sanjay): Skip if memtable does not overlap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="n">max_level_with_files</span><span class="p">;</span> <span class="n">level</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">TEST_CompactRange</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>DBImpl::CompactRange</code>方法首先根据给定key范围与每个level是否有overlap，得到需要Compact的最高level，然后通过<code>TEST_CompactMemTable</code>方法强制触发并等待Minor Compaction完成（当前版本因MemTable与给定key范围没有overlap而跳过Minor Compaction）。随后遍历从0到需要Compact的最高level，并按需对该层进行Major Compaction。</p>
<p>接下来我们来分析<code>TEST_CompactMemTable</code>与<code>TEST_CompactRange</code>的实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Status</span> <span class="n">DBImpl</span><span class="o">::</span><span class="n">TEST_CompactMemTable</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// nullptr batch means just wait for earlier writes to be done
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Status</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Write</span><span class="p">(</span><span class="n">WriteOptions</span><span class="p">(),</span> <span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Wait until the compaction completes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">MutexLock</span> <span class="nf">l</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">imm_</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">bg_error_</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">background_work_finished_signal_</span><span class="p">.</span><span class="n">Wait</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">imm_</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">s</span> <span class="o">=</span> <span class="n">bg_error_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>TEST_CompactMemTable</code>方法会通过一次“null write batch”来触发<code>force</code>参数为true的<code>MakeRoomForWrite</code>调用，<code>force</code>为true的调用会强制触发Minor Compaction（详见<a href="/posts/code-reading/leveldb-made-simple/8-compaction/#23-minor-compaction%e7%9a%84%e8%a7%a6%e5%8f%91" rel="">2.3 Minor Compaction的触发</a>）。随后该方法等待Minor Compaction完成后返回。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">DBImpl</span><span class="o">::</span><span class="n">TEST_CompactRange</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="n">Slice</span><span class="o">*</span> <span class="n">begin</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                               <span class="k">const</span> <span class="n">Slice</span><span class="o">*</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">level</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">config</span><span class="o">::</span><span class="n">kNumLevels</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">InternalKey</span> <span class="n">begin_storage</span><span class="p">,</span> <span class="n">end_storage</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">ManualCompaction</span> <span class="n">manual</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual</span><span class="p">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">manual</span><span class="p">.</span><span class="n">done</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">begin</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">manual</span><span class="p">.</span><span class="n">begin</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">begin_storage</span> <span class="o">=</span> <span class="n">InternalKey</span><span class="p">(</span><span class="o">*</span><span class="n">begin</span><span class="p">,</span> <span class="n">kMaxSequenceNumber</span><span class="p">,</span> <span class="n">kValueTypeForSeek</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">manual</span><span class="p">.</span><span class="n">begin</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">begin_storage</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">manual</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">end_storage</span> <span class="o">=</span> <span class="n">InternalKey</span><span class="p">(</span><span class="o">*</span><span class="n">end</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">manual</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">end_storage</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">MutexLock</span> <span class="nf">l</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">manual</span><span class="p">.</span><span class="n">done</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">shutting_down_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">         <span class="n">bg_error_</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">manual_compaction_</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Idle
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">manual_compaction_</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">manual</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">MaybeScheduleCompaction</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="c1">// Running either my compaction or another compaction.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">background_work_finished_signal_</span><span class="p">.</span><span class="n">Wait</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">manual_compaction_</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">manual</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Cancel my manual compaction since we aborted early for some reason.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">manual_compaction_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>该方法的工作也很简单，其生成了需要Compact的InternalKey范围，并配置了<code>manual_compaction_</code>字段，然后通过<code>MaybeScheduleCompaction</code>方法触发Manual Compaction，并等待期执行结束后返回。随后，Manual Compaction的执行交由后台线程来触发。后台线程在执行Manual Compaction时，会通过<code>VersionSet::CompactRange</code>方法计算其具体范围：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Compaction</span><span class="o">*</span> <span class="n">VersionSet</span><span class="o">::</span><span class="n">CompactRange</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="n">InternalKey</span><span class="o">*</span> <span class="n">begin</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                     <span class="k">const</span> <span class="n">InternalKey</span><span class="o">*</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">FileMetaData</span><span class="o">*&gt;</span> <span class="n">inputs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">current_</span><span class="o">-&gt;</span><span class="n">GetOverlappingInputs</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inputs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">inputs</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Avoid compacting too much in one shot in case the range is large.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// But we cannot do this for level-0 since level-0 files can overlap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// and we must not pick one file and drop another older file if the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// two files overlap.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">MaxFileSizeForLevel</span><span class="p">(</span><span class="n">options_</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint64_t</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">inputs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kt">uint64_t</span> <span class="n">s</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">file_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">total</span> <span class="o">+=</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">total</span> <span class="o">&gt;=</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">inputs</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Compaction</span><span class="o">*</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Compaction</span><span class="p">(</span><span class="n">options_</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">c</span><span class="o">-&gt;</span><span class="n">input_version_</span> <span class="o">=</span> <span class="n">current_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">c</span><span class="o">-&gt;</span><span class="n">input_version_</span><span class="o">-&gt;</span><span class="n">Ref</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">c</span><span class="o">-&gt;</span><span class="n">inputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">SetupOtherInputs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>该方法会在给定level中查找与给定key范围有overlap的所有SSTable。对于非level-0的层级，该方法会限制参与Compaciton的大小不超过配置中每层最大文件大小（如果需要Compact的范围超过了每层最大文件大小，说明之前还有Size Compcation任务）；而对于level-0，由于其SSTable间可能存在overlap，因此不能舍弃参与Compaction的SSTable。在<code>input[0]</code>确定后，同样通过<code>SetupOtherInputs</code>方法，配置其它输入参数（详见<a href="/posts/code-reading/leveldb-made-simple/8-compaction/#322-size-compaction%e4%b8%8eseek-compaction%e7%9a%84%e8%8c%83%e5%9b%b4" rel="">3.2.2 Size Compaction与Seek Compaction的范围</a>）。</p>
<h2 id="4-compaction的执行">4. Compaction的执行</h2>
<p>从本节开始，笔者将介绍并分析LevelDB中Compaction执行的过程。</p>
<p>LevelDB将Compaction任务放入后台线程的Compaction任务队列后，由后台线程调度执行。其执行Compaction的行为可分为执行Minor Compaciton与Major Compaction两种。在介绍这两种Compaction的执行方法前，我们先从后台线程执行Comapciton的入口方法开始，分析Compaction的启动过程。</p>
<h3 id="41-后台线程compaction入口">4.1 后台线程Compaction入口</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">DBImpl</span><span class="o">::</span><span class="n">BGWork</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">db</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">DBImpl</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">db</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">BackgroundCall</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">DBImpl</span><span class="o">::</span><span class="n">BackgroundCall</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">MutexLock</span> <span class="nf">l</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">background_compaction_scheduled_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">shutting_down_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// No more background work when shutting down.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bg_error_</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// No more background work after a background error.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">BackgroundCompaction</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">background_compaction_scheduled_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Previous compaction may have produced too many files in a level,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// so reschedule another compaction if needed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">MaybeScheduleCompaction</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">background_work_finished_signal_</span><span class="p">.</span><span class="n">SignalAll</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>DBImpl::BGWork</code>方法是后台线程的执行入口，该方法直接调用了<code>DBImpl::BackgroundCall</code>方法。<code>DBImpl::BackgroundCall</code>方法通过<code>MutexLock</code>对该方法整体上锁，<code>MutexLock</code>在构造时会对传入的互斥锁上锁，析构时会对传入的互斥锁解锁，因此只需要实例化MutexLock即可在其声明周期内加锁。该方法会判断LevelDB此时既没有被关闭，也没有发生后台线程错误，然后调用<code>DBImpl::BackgroundCompaction</code>方法正式开始Compaction执行。最后，在本次Compaction执行结束后，会再次调用<code>MaybeScheduleCompaction</code>方法以免本次Compaction导致某一层文件过大超出限制（这也是Size Compaction的触发代码，上文曾介绍过这段代码）。</p>
<p>接着我们来分析<code>DBImpl::BackgroundCompaction</code>的实现。由于该方法较长，我们继续分段分析：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">DBImpl</span><span class="o">::</span><span class="n">BackgroundCompaction</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// (1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mutex_</span><span class="p">.</span><span class="n">AssertHeld</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">imm_</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">CompactMemTable</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>BackgroundCompaction</code>首先通过断言的方式确保当前持有锁，然后按照优先级来执行Compaction。首先其判断<code>imm_</code>是否存在，如果存在则通过<code>DBImpl::CompactionMemTable</code>方法来执行Minor Comapction并返回。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// (2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Compaction</span><span class="o">*</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">is_manual</span> <span class="o">=</span> <span class="p">(</span><span class="n">manual_compaction_</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">InternalKey</span> <span class="n">manual_end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">is_manual</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ManualCompaction</span><span class="o">*</span> <span class="n">m</span> <span class="o">=</span> <span class="n">manual_compaction_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span> <span class="o">=</span> <span class="n">versions_</span><span class="o">-&gt;</span><span class="n">CompactRange</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">m</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">manual_end</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">input</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">num_input_files</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">largest</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">Log</span><span class="p">(</span><span class="n">options_</span><span class="p">.</span><span class="n">info_log</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s">&#34;Manual compaction at level-%d from %s .. %s; will stop at %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">m</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">begin</span> <span class="o">?</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">begin</span><span class="o">-&gt;</span><span class="n">DebugString</span><span class="p">().</span><span class="n">c_str</span><span class="p">()</span> <span class="o">:</span> <span class="s">&#34;(begin)&#34;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">?</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">end</span><span class="o">-&gt;</span><span class="n">DebugString</span><span class="p">().</span><span class="n">c_str</span><span class="p">()</span> <span class="o">:</span> <span class="s">&#34;(end)&#34;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">?</span> <span class="s">&#34;(end)&#34;</span> <span class="o">:</span> <span class="n">manual_end</span><span class="p">.</span><span class="n">DebugString</span><span class="p">().</span><span class="n">c_str</span><span class="p">()));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span> <span class="o">=</span> <span class="n">versions_</span><span class="o">-&gt;</span><span class="n">PickCompaction</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><p>接着，<code>BackgroundCompaction</code>方法计算Compaction的具体范围。这段代码我们在上一节中介绍过，这里不再赘述。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// (3)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">Status</span> <span class="n">status</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Nothing to do
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_manual</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">IsTrivialMove</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Move file to next level
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">assert</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">num_input_files</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">FileMetaData</span><span class="o">*</span> <span class="n">f</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">input</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">edit</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">RemoveFile</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">(),</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">edit</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">AddFile</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">file_size</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">smallest</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                       <span class="n">f</span><span class="o">-&gt;</span><span class="n">largest</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">status</span> <span class="o">=</span> <span class="n">versions_</span><span class="o">-&gt;</span><span class="n">LogAndApply</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">edit</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">RecordBackgroundError</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">VersionSet</span><span class="o">::</span><span class="n">LevelSummaryStorage</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Log</span><span class="p">(</span><span class="n">options_</span><span class="p">.</span><span class="n">info_log</span><span class="p">,</span> <span class="s">&#34;Moved #%lld to level-%d %lld bytes %s: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">),</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">file_size</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">        <span class="n">status</span><span class="p">.</span><span class="n">ToString</span><span class="p">().</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">versions_</span><span class="o">-&gt;</span><span class="n">LevelSummary</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">CompactionState</span><span class="o">*</span> <span class="n">compact</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CompactionState</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">status</span> <span class="o">=</span> <span class="n">DoCompactionWork</span><span class="p">(</span><span class="n">compact</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">RecordBackgroundError</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">CleanupCompaction</span><span class="p">(</span><span class="n">compact</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">ReleaseInputs</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">RemoveObsoleteFiles</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">delete</span> <span class="n">c</span><span class="p">;</span>
</span></span></code></pre></div><p>接下来，<code>BackgroundCompaction</code>方法会根据上一步中准备好的记录了Major Compaction所需数据的<code>Compaction</code>类型的实例<code>c</code>，执行相应的方法：</p>
<ol>
<li>如果<code>c</code>为空，则无需执行，直接跳过这一步。</li>
<li>如果当前任务不是Manual Compaction，则判断Compaction任务<code>c</code>是否只需要SSTable从一层移动到下一层即可（被称为“trivial move”），即既不需要合并SSTable也不需要拆分SSTable。Manual Compaction不使用“trivial move”，以为用户提供显式回收不再需要的文件的接口。</li>
<li>否则，执行Compaction操作，依次调用<code>DoCompactionWork</code>、<code>CleanupCompaction</code>、<code>RemoveObsoleteFiles</code>。后文将详细分析每个方法的实现。</li>
</ol>
<p>该方法的步骤2会通过<code>Compaction::IsTrivialMove</code>方法来判断当前Comapction任务是否不需要合并或删除SSTable，而只需要将SSTable移到下一层。如果可以“trivial move”，则LevelDB只需要通过VersionEdit来修改Version中记录的每个level的文件编号即可，而不需要读写SSTable。<code>Compaction::IsTrivialMove</code>的实现如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">Compaction</span><span class="o">::</span><span class="n">IsTrivialMove</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">VersionSet</span><span class="o">*</span> <span class="n">vset</span> <span class="o">=</span> <span class="n">input_version_</span><span class="o">-&gt;</span><span class="n">vset_</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Avoid a move if there is lots of overlapping grandparent data.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Otherwise, the move could create a parent file that will require
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// a very expensive merge later on.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="p">(</span><span class="n">num_input_files</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">num_input_files</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">          <span class="n">TotalFileSize</span><span class="p">(</span><span class="n">grandparents_</span><span class="p">)</span> <span class="o">&lt;=</span>
</span></span><span class="line"><span class="cl">              <span class="n">MaxGrandParentOverlapBytes</span><span class="p">(</span><span class="n">vset</span><span class="o">-&gt;</span><span class="n">options_</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>Compaction::IsTrivialMove</code>方法判断规则如下：</p>
<ol>
<li>如果input[0]只有1个SSTable，input[1]中没有SSTable才可以“trivial move”，因为此时不需要合并多个SSTable。</li>
<li>检查level-(i+2)层中与将移动到level-(i+1)层的SSTable有overlap的文件总大小，不能超过一定上限（默认为10倍<code>max_file_size</code>，即20MB）。否则，该trivial move的SSTable下一次参与Major Compaction时其合并开销会非常大。</li>
</ol>
<p>下面，笔者将分别介绍Minor Compaction与Major Comapction的执行。</p>
<h3 id="42-minor-compaction">4.2 Minor Compaction</h3>
<p>Minor Compaction主要通过<code>DBImpl::CompactionMemTable</code>方法实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">DBImpl</span><span class="o">::</span><span class="n">CompactMemTable</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">mutex_</span><span class="p">.</span><span class="n">AssertHeld</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">imm_</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Save the contents of the memtable as a new Table
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">VersionEdit</span> <span class="n">edit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Version</span><span class="o">*</span> <span class="n">base</span> <span class="o">=</span> <span class="n">versions_</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">base</span><span class="o">-&gt;</span><span class="n">Ref</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">Status</span> <span class="n">s</span> <span class="o">=</span> <span class="n">WriteLevel0Table</span><span class="p">(</span><span class="n">imm_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">edit</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">base</span><span class="o">-&gt;</span><span class="n">Unref</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">shutting_down_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">=</span> <span class="n">Status</span><span class="o">::</span><span class="n">IOError</span><span class="p">(</span><span class="s">&#34;Deleting DB during memtable compaction&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Replace immutable memtable with the generated Table
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">edit</span><span class="p">.</span><span class="n">SetPrevLogNumber</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">edit</span><span class="p">.</span><span class="n">SetLogNumber</span><span class="p">(</span><span class="n">logfile_number_</span><span class="p">);</span>  <span class="c1">// Earlier logs no longer needed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">s</span> <span class="o">=</span> <span class="n">versions_</span><span class="o">-&gt;</span><span class="n">LogAndApply</span><span class="p">(</span><span class="o">&amp;</span><span class="n">edit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex_</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Commit to the new state
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">imm_</span><span class="o">-&gt;</span><span class="n">Unref</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">imm_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">has_imm_</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_release</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">RemoveObsoleteFiles</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">RecordBackgroundError</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>CompactionMemTable</code>方法首先调用<code>DBImpl::WriteLevel0Table</code>方法将Immutable MemTable转储为SSTable，由于该方法需要使用当前的Version信息，因此在调用前后增减了当前Version的引用计数以避免其被回收。接着，通过<code>VersionSet::LogAndApply</code>方法将增量的版本更新VersionEdit写入Manifest（其中prev log number已被弃用，不需要再关注）。如果上述操作都成功完成，则可以释放对Immutable MemTable的引用，并通过<code>RemoveObsoleteFiles</code>方法回收不再需要保留的文件（该方法放在后续的章节中介绍）。</p>
<p>接下来我们分析其中转储Immutable MemTable的方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Status</span> <span class="n">DBImpl</span><span class="o">::</span><span class="n">WriteLevel0Table</span><span class="p">(</span><span class="n">MemTable</span><span class="o">*</span> <span class="n">mem</span><span class="p">,</span> <span class="n">VersionEdit</span><span class="o">*</span> <span class="n">edit</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                                <span class="n">Version</span><span class="o">*</span> <span class="n">base</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">mutex_</span><span class="p">.</span><span class="n">AssertHeld</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">start_micros</span> <span class="o">=</span> <span class="n">env_</span><span class="o">-&gt;</span><span class="n">NowMicros</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">FileMetaData</span> <span class="n">meta</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">meta</span><span class="p">.</span><span class="n">number</span> <span class="o">=</span> <span class="n">versions_</span><span class="o">-&gt;</span><span class="n">NewFileNumber</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">pending_outputs_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">meta</span><span class="p">.</span><span class="n">number</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">Iterator</span><span class="o">*</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">mem</span><span class="o">-&gt;</span><span class="n">NewIterator</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">Log</span><span class="p">(</span><span class="n">options_</span><span class="p">.</span><span class="n">info_log</span><span class="p">,</span> <span class="s">&#34;Level-0 table #%llu: started&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">meta</span><span class="p">.</span><span class="n">number</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Status</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">mutex_</span><span class="p">.</span><span class="n">Unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">=</span> <span class="n">BuildTable</span><span class="p">(</span><span class="n">dbname_</span><span class="p">,</span> <span class="n">env_</span><span class="p">,</span> <span class="n">options_</span><span class="p">,</span> <span class="n">table_cache_</span><span class="p">,</span> <span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">meta</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">mutex_</span><span class="p">.</span><span class="n">Lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Log</span><span class="p">(</span><span class="n">options_</span><span class="p">.</span><span class="n">info_log</span><span class="p">,</span> <span class="s">&#34;Level-0 table #%llu: %lld bytes %s&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">meta</span><span class="p">.</span><span class="n">number</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">meta</span><span class="p">.</span><span class="n">file_size</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">s</span><span class="p">.</span><span class="n">ToString</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="k">delete</span> <span class="n">iter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">pending_outputs_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">meta</span><span class="p">.</span><span class="n">number</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Note that if file_size is zero, the file has been deleted and
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// should not be added to the manifest.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">meta</span><span class="p">.</span><span class="n">file_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">Slice</span> <span class="n">min_user_key</span> <span class="o">=</span> <span class="n">meta</span><span class="p">.</span><span class="n">smallest</span><span class="p">.</span><span class="n">user_key</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="n">Slice</span> <span class="n">max_user_key</span> <span class="o">=</span> <span class="n">meta</span><span class="p">.</span><span class="n">largest</span><span class="p">.</span><span class="n">user_key</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">level</span> <span class="o">=</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">PickLevelForMemTableOutput</span><span class="p">(</span><span class="n">min_user_key</span><span class="p">,</span> <span class="n">max_user_key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">edit</span><span class="o">-&gt;</span><span class="n">AddFile</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">meta</span><span class="p">.</span><span class="n">number</span><span class="p">,</span> <span class="n">meta</span><span class="p">.</span><span class="n">file_size</span><span class="p">,</span> <span class="n">meta</span><span class="p">.</span><span class="n">smallest</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="n">meta</span><span class="p">.</span><span class="n">largest</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">CompactionStats</span> <span class="n">stats</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">stats</span><span class="p">.</span><span class="n">micros</span> <span class="o">=</span> <span class="n">env_</span><span class="o">-&gt;</span><span class="n">NowMicros</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_micros</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">stats</span><span class="p">.</span><span class="n">bytes_written</span> <span class="o">=</span> <span class="n">meta</span><span class="p">.</span><span class="n">file_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">stats_</span><span class="p">[</span><span class="n">level</span><span class="p">].</span><span class="n">Add</span><span class="p">(</span><span class="n">stats</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><code>WriteLevel0Table</code>方法虽然较长但其逻辑非常简单，其获取了需要转储的MemTable的迭代器，并传给<code>BuildTable</code>方法。<code>BuildTable</code>方法会通过<code>TableBuilder</code>来构造SSTable文件然后写入，这里不再赘述。这里值得我们注意的是，<code>WriteLevel0Table</code>方法在处理完构造SSTable时需要的数据（及引用计数）后，在真正通过<code>BuildTable</code>方法转储SSTable时释放了全局的锁。因为Minor Compaction是由后台线程完成的，这样做可以在保证线程安全的前提下，避免后台线程执行耗时的Minor Compaction操作时阻塞LevelDB正常的读写。</p>
<h3 id="43-major-compaction">4.3 Major Compaction</h3>
<p>Major Compaction主要通过<code>DBImpl::DoCompactionWork</code>方法实现，其流程较为复杂，这里仍采用分段介绍的方式分析。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">Status</span> <span class="n">DBImpl</span><span class="o">::</span><span class="n">DoCompactionWork</span><span class="p">(</span><span class="n">CompactionState</span><span class="o">*</span> <span class="n">compact</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// (1)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">start_micros</span> <span class="o">=</span> <span class="n">env_</span><span class="o">-&gt;</span><span class="n">NowMicros</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int64_t</span> <span class="n">imm_micros</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// Micros spent doing imm_ compactions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">Log</span><span class="p">(</span><span class="n">options_</span><span class="p">.</span><span class="n">info_log</span><span class="p">,</span> <span class="s">&#34;Compacting %d@%d + %d@%d files&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">compact</span><span class="o">-&gt;</span><span class="n">compaction</span><span class="o">-&gt;</span><span class="n">num_input_files</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">compact</span><span class="o">-&gt;</span><span class="n">compaction</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">(),</span>
</span></span><span class="line"><span class="cl">      <span class="n">compact</span><span class="o">-&gt;</span><span class="n">compaction</span><span class="o">-&gt;</span><span class="n">num_input_files</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="n">compact</span><span class="o">-&gt;</span><span class="n">compaction</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">versions_</span><span class="o">-&gt;</span><span class="n">NumLevelFiles</span><span class="p">(</span><span class="n">compact</span><span class="o">-&gt;</span><span class="n">compaction</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">compact</span><span class="o">-&gt;</span><span class="n">builder</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">assert</span><span class="p">(</span><span class="n">compact</span><span class="o">-&gt;</span><span class="n">outfile</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>首先<code>DoCompactionWork</code>通过断言避免编码错误，同时做好日志，这里不再赘述。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// (2)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">snapshots_</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">compact</span><span class="o">-&gt;</span><span class="n">smallest_snapshot</span> <span class="o">=</span> <span class="n">versions_</span><span class="o">-&gt;</span><span class="n">LastSequence</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">compact</span><span class="o">-&gt;</span><span class="n">smallest_snapshot</span> <span class="o">=</span> <span class="n">snapshots_</span><span class="p">.</span><span class="n">oldest</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">sequence_number</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">Iterator</span><span class="o">*</span> <span class="n">input</span> <span class="o">=</span> <span class="n">versions_</span><span class="o">-&gt;</span><span class="n">MakeInputIterator</span><span class="p">(</span><span class="n">compact</span><span class="o">-&gt;</span><span class="n">compaction</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// Release mutex while we&#39;re actually doing the compaction work
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">mutex_</span><span class="p">.</span><span class="n">Unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// (...)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">mutex_</span><span class="p">.</span><span class="n">Lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">stats_</span><span class="p">[</span><span class="n">compact</span><span class="o">-&gt;</span><span class="n">compaction</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">Add</span><span class="p">(</span><span class="n">stats</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">status</span> <span class="o">=</span> <span class="n">InstallCompactionResults</span><span class="p">(</span><span class="n">compact</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">RecordBackgroundError</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">VersionSet</span><span class="o">::</span><span class="n">LevelSummaryStorage</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">Log</span><span class="p">(</span><span class="n">options_</span><span class="p">.</span><span class="n">info_log</span><span class="p">,</span> <span class="s">&#34;compacted to: %s&#34;</span><span class="p">,</span> <span class="n">versions_</span><span class="o">-&gt;</span><span class="n">LevelSummary</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">status</span><span class="p">;</span>
</span></span></code></pre></div><p>接着我们来看第(2)段代码，这段代码看上去很长，但做的工作较为简单。<code>DoCompactionWork</code>方法在遍历和生成SSTable是解锁的，我们将其放在后面分析，第(2)代码主要关注解锁前和上锁后的部分。</p>
<p>在解锁前，该方法准备了需要避免竟态的数据：需要保留的最大SequenceNumber（以实现Snapshot Read），并通过<code>MakeInputIterator</code>方法生成了所有参与Major Compaction的SSTable的全局迭代器Input Iterator（详见<a href="/posts/code-reading/leveldb-made-simple/8-iterator/" rel="">深入浅出LevelDB —— 08 Iterator</a>）。</p>
<p>在完成Compaction并上锁后，该方法更新了统计量和状态，输出日志后返回。</p>
<p>下面我们介绍的部分，几乎都是在解锁的情况下执行的，其不会阻塞LevelDB正常的读写操作。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// (3)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">input</span><span class="o">-&gt;</span><span class="n">SeekToFirst</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">Status</span> <span class="n">status</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ParsedInternalKey</span> <span class="n">ikey</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">current_user_key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">has_current_user_key</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">SequenceNumber</span> <span class="n">last_sequence_for_key</span> <span class="o">=</span> <span class="n">kMaxSequenceNumber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="n">input</span><span class="o">-&gt;</span><span class="n">Valid</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">shutting_down_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// (...)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">input</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">ok</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">shutting_down_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_acquire</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">status</span> <span class="o">=</span> <span class="n">Status</span><span class="o">::</span><span class="n">IOError</span><span class="p">(</span><span class="s">&#34;Deleting DB during compaction&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">ok</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">compact</span><span class="o">-&gt;</span><span class="n">builder</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">status</span> <span class="o">=</span> <span class="n">FinishCompactionOutputFile</span><span class="p">(</span><span class="n">compact</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">status</span> <span class="o">=</span> <span class="n">input</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">delete</span> <span class="n">input</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">input</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">CompactionStats</span> <span class="n">stats</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">stats</span><span class="p">.</span><span class="n">micros</span> <span class="o">=</span> <span class="n">env_</span><span class="o">-&gt;</span><span class="n">NowMicros</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_micros</span> <span class="o">-</span> <span class="n">imm_micros</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">which</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">which</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">which</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">compact</span><span class="o">-&gt;</span><span class="n">compaction</span><span class="o">-&gt;</span><span class="n">num_input_files</span><span class="p">(</span><span class="n">which</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">stats</span><span class="p">.</span><span class="n">bytes_read</span> <span class="o">+=</span> <span class="n">compact</span><span class="o">-&gt;</span><span class="n">compaction</span><span class="o">-&gt;</span><span class="n">input</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">file_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">compact</span><span class="o">-&gt;</span><span class="n">outputs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">stats</span><span class="p">.</span><span class="n">bytes_written</span> <span class="o">+=</span> <span class="n">compact</span><span class="o">-&gt;</span><span class="n">outputs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">file_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><p>第(3)段代码主要通过InputIterator顺序遍历参与Major Compaction的key/value，对每个key/value的处理会在下文介绍。在处理完所有key后，根据状态判断是否需要返回错误，同时通过<code>FinishCompactionOutputFile</code>方法关闭最后一个写入的SSTable。</p>
<p>因为LevelDB限制了每个SSTable的大小，因此在Major Compaction期间，如果当前写入的SSTable过大，会将其拆分成多个SSTable写入，所以这里关闭的是最后一个SSTable。该方法主要通过SSTable的Builder的<code>Finish</code>方法完成对SSTable的写入，这里不再赘述，感兴趣的读者可以自行阅读。</p>
<p>最后，这段代码更新了相关统计量。</p>
<p>接下来我们来看LevelDB对每个key/value的处理：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// (4)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Prioritize immutable compaction work
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">has_imm_</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="kt">uint64_t</span> <span class="n">imm_start</span> <span class="o">=</span> <span class="n">env_</span><span class="o">-&gt;</span><span class="n">NowMicros</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">mutex_</span><span class="p">.</span><span class="n">Lock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">imm_</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">CompactMemTable</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Wake up MakeRoomForWrite() if necessary.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">background_work_finished_signal_</span><span class="p">.</span><span class="n">SignalAll</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="n">mutex_</span><span class="p">.</span><span class="n">Unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">imm_micros</span> <span class="o">+=</span> <span class="p">(</span><span class="n">env_</span><span class="o">-&gt;</span><span class="n">NowMicros</span><span class="p">()</span> <span class="o">-</span> <span class="n">imm_start</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// (5)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Slice</span> <span class="n">key</span> <span class="o">=</span> <span class="n">input</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">compact</span><span class="o">-&gt;</span><span class="n">compaction</span><span class="o">-&gt;</span><span class="n">ShouldStopBefore</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">        <span class="n">compact</span><span class="o">-&gt;</span><span class="n">builder</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">status</span> <span class="o">=</span> <span class="n">FinishCompactionOutputFile</span><span class="p">(</span><span class="n">compact</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// (6)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// Handle key/value, add to state, etc.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">bool</span> <span class="n">drop</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// ... ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// (7)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">drop</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Open output file if necessary
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="n">compact</span><span class="o">-&gt;</span><span class="n">builder</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">status</span> <span class="o">=</span> <span class="n">OpenCompactionOutputFile</span><span class="p">(</span><span class="n">compact</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">compact</span><span class="o">-&gt;</span><span class="n">builder</span><span class="o">-&gt;</span><span class="n">NumEntries</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">compact</span><span class="o">-&gt;</span><span class="n">current_output</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">smallest</span><span class="p">.</span><span class="n">DecodeFrom</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="n">compact</span><span class="o">-&gt;</span><span class="n">current_output</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">largest</span><span class="p">.</span><span class="n">DecodeFrom</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">compact</span><span class="o">-&gt;</span><span class="n">builder</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">input</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="c1">// Close output file if it is big enough
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="n">compact</span><span class="o">-&gt;</span><span class="n">builder</span><span class="o">-&gt;</span><span class="n">FileSize</span><span class="p">()</span> <span class="o">&gt;=</span>
</span></span><span class="line"><span class="cl">          <span class="n">compact</span><span class="o">-&gt;</span><span class="n">compaction</span><span class="o">-&gt;</span><span class="n">MaxOutputFileSize</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">status</span> <span class="o">=</span> <span class="n">FinishCompactionOutputFile</span><span class="p">(</span><span class="n">compact</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>我们首先来看(4)、(5)、(7)。</p>
<p>段(4)判断当前是否有需要Minor Compaction的Immutable MemTable，如果有则让出任务，先进行Minor Compaction（该过程需要加锁）。</p>
<p>段(5)通过<code>ShouldStopBefore</code>方法估算当前SSTable大小，并判断其是否超过了<code>max_file_size</code>的限制，如果超过了则通过<code>FinishCompactionOutputFile</code>完整对当前SSTable的写入。</p>
<p>段(6)会判断当前key/value是否保留，如果保留则将<code>drop</code>置为true。其判断规则在下文介绍。</p>
<p>段(7)用来将需要保留的key/value加入到当前SSTable中。因为在段(5)中当前写入的SSTable可能已因文件过大而被关闭，所以这里需要在SSTable被关闭时通过<code>OpenCompactionOutputFIle</code>打开一个新的SSTable并为其分配新的编号。</p>
<p>最后我们来看段(6)中判断key/value是否需要保留的实现：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ParseInternalKey</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ikey</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Do not hide error keys
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">current_user_key</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">has_current_user_key</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">last_sequence_for_key</span> <span class="o">=</span> <span class="n">kMaxSequenceNumber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">has_current_user_key</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">          <span class="n">user_comparator</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Compare</span><span class="p">(</span><span class="n">ikey</span><span class="p">.</span><span class="n">user_key</span><span class="p">,</span> <span class="n">Slice</span><span class="p">(</span><span class="n">current_user_key</span><span class="p">))</span> <span class="o">!=</span>
</span></span><span class="line"><span class="cl">              <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// First occurrence of this user key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">current_user_key</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">ikey</span><span class="p">.</span><span class="n">user_key</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">ikey</span><span class="p">.</span><span class="n">user_key</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="n">has_current_user_key</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">last_sequence_for_key</span> <span class="o">=</span> <span class="n">kMaxSequenceNumber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">last_sequence_for_key</span> <span class="o">&lt;=</span> <span class="n">compact</span><span class="o">-&gt;</span><span class="n">smallest_snapshot</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Hidden by an newer entry for same user key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">drop</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>  <span class="c1">// (A)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">ikey</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">kTypeDeletion</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                 <span class="n">ikey</span><span class="p">.</span><span class="n">sequence</span> <span class="o">&lt;=</span> <span class="n">compact</span><span class="o">-&gt;</span><span class="n">smallest_snapshot</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                 <span class="n">compact</span><span class="o">-&gt;</span><span class="n">compaction</span><span class="o">-&gt;</span><span class="n">IsBaseLevelForKey</span><span class="p">(</span><span class="n">ikey</span><span class="p">.</span><span class="n">user_key</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// For this user key:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// (1) there is no data in higher levels
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// (2) data in lower levels will have larger sequence numbers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// (3) data in layers that are being compacted here and have
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//     smaller sequence numbers will be dropped in the next
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">//     few iterations of this loop (by rule (A) above).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// Therefore this deletion marker is obsolete and can be dropped.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">drop</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="n">last_sequence_for_key</span> <span class="o">=</span> <span class="n">ikey</span><span class="p">.</span><span class="n">sequence</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>段(6)中记录了当前key的UserKey的两个重要状态：</p>
<ul>
<li><code>has_current_user_key</code>：当前key的UserKey之前是否出现过。</li>
<li><code>last_sequence_for_key</code>：当前key的UserKey的上一次出现时的SequenceNumber，如果该UserKey之前未出现过，则将其置为最大的SequenceNumber（<code>kMaxSequenceNumber</code>），以避免当前key的最新状态在小于需要保留的snapshot number时被丢弃。</li>
</ul>
<p>段(6)执行了如下流程：</p>
<ol>
<li>解析当前key/value，如果解析失败则跳过当前key/value。</li>
<li>如果当前key/value解析成功，判断其UserKey是否未出现过，如果是则更新<code>has_current_user_key</code>和<code>last_sequence_for_key</code>的状态。</li>
<li>判断当前是否丢弃当前key/value：
<ol>
<li>如果当前key的UserKey不是第一次出现，且其SequenceNumber小于保留的最小snapshot number，则丢弃该key/value。</li>
<li>如果该key的InternalKey类型为<code>kTypeDeletion</code>、且其SequenceNumber小于需要保留的最小snapshot number，同时更高的level中不存在该key时，可以丢弃该key/value。</li>
</ol>
</li>
</ol>
<p>如果<code>drop</code>被置为true，则在段(7)中该key不会被写入到SSTable中。关于drop key的规则，需要注意的是，对于非<code>kTypeDeletion</code>类型的key，不能丢弃虽然SequenceNumber在smallest_snapshot前，但是其UserKey第一次出现的key；另外，对于<code>kTypeDeletion</code>类型，虽然可以丢弃在smallest_snapshot前的key，但是还需要保证在更高的level中没有该UserKey，否则在查询时，在当前level失配后会在下层中找到该UserKey的更旧的版本。</p>
<h3 id="44-compaction清理">4.4 Compaction清理</h3>
<p>在<code>BackgroundCompaction</code>方法通过<code>DoCompactionWork</code>执行Compaction完成后，会依次调用<code>CleanupCompaction</code>和<code>RemoveObsoleteFiles</code>方法来进行清理。</p>
<p><code>CleanupCompaction</code>方法用来释放Compaction过程中的占用（主要是内存）。</p>
<p><code>RemoveObsoleteFiles</code>方法用来删除Compaction后不再需要的旧文件。</p></div>

        <div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2021-03-15</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/leveldb/">LevelDB</a>,&nbsp;<a href="/tags/lsm-tree/">LSM-Tree</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/code-reading/leveldb-made-simple/8-iterator/" class="prev" rel="prev" title="深入浅出LevelDB —— 08 Iterator"><i class="fas fa-angle-left fa-fw"></i>深入浅出LevelDB —— 08 Iterator</a>
            <a href="/posts/code-reading/leveldb-made-simple/10-read-write/" class="next" rel="next" title="深入浅出LevelDB —— 10 Read &amp; Write">深入浅出LevelDB —— 10 Read &amp; Write<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
</article></div>
        </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.104.3">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/HEIGE-PCloud/DoIt" target="_blank" rel="noopener noreffer" title="DoIt 0.2.13"><i class="far fa-edit fa-fw"></i> DoIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2019 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="about" target="_blank" rel="noopener noreferrer">叉鸽</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a></span></div>
        </div></footer></div>

    <div id="fixed-buttons"><a href="#back-to-top" id="back-to-top-button" class="fixed-button" title="回到顶部">
            <i class="fas fa-arrow-up fa-fw"></i>
        </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
            <i class="fas fa-comment fa-fw"></i>
        </a>
    </div><div class="assets"><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.stemmer.support.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.zh.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/topbar/topbar.min.js"></script><script type="text/javascript" src="/lib/pjax/pjax.min.js"></script><script type="text/javascript" src="/js/theme.min.js"></script></div>

<div class="pjax-assets"><script type="text/javascript" src="/lib/twemoji/twemoji.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lightgallery.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-thumbnail.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-zoom.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/typeit/typeit.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js"></script><script type="text/javascript" src="/lib/katex/auto-render.min.js"></script><script type="text/javascript" src="/lib/katex/copy-tex.min.js"></script><script type="text/javascript" src="/lib/katex/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10000},"comment":{},"data":{"desktop-header-typeit":"叉鸽 | MrCroxx","mobile-header-typeit":"叉鸽 | MrCroxx"},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"},"twemoji":true,"typeit":{"cursorChar":null,"cursorSpeed":null,"data":{"desktop-header-typeit":["desktop-header-typeit"],"mobile-header-typeit":["mobile-header-typeit"]},"duration":null,"speed":null}};</script><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/lightgallery/lightgallery.min.css">
    <noscript><link rel="stylesheet" href="/lib/lightgallery/lightgallery.min.css"></noscript><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/katex/katex.min.css">
    <noscript><link rel="stylesheet" href="/lib/katex/katex.min.css"></noscript><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/katex/copy-tex.min.css">
    <noscript><link rel="stylesheet" href="/lib/katex/copy-tex.min.css"></noscript></div>
</body>

</html>