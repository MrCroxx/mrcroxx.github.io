<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>深入浅出boltdb —— 0x04 事务 - 叉鸽 MrCroxx 的博客</title><meta name="Description" content="Welcome to MrCroxx&#39;s Blog."><meta property="og:title" content="深入浅出boltdb —— 0x04 事务" />
<meta property="og:description" content="本文为原创文章，转载请严格遵守CC BY-NC-SA协议。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mrcroxx.github.io/posts/code-reading/boltdb-made-simple/4-transaction/" />
<meta property="og:image" content="https://mrcroxx.github.io/posts/code-reading/boltdb-made-simple/4-transaction/boltdb.jpg"/>
<meta property="article:published_time" content="2021-01-26T13:30:24+08:00" />
<meta property="article:modified_time" content="2021-02-05T21:21:25+08:00" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://mrcroxx.github.io/posts/code-reading/boltdb-made-simple/4-transaction/boltdb.jpg"/>
<meta name="twitter:title" content="深入浅出boltdb —— 0x04 事务"/>
<meta name="twitter:description" content="本文为原创文章，转载请严格遵守CC BY-NC-SA协议。"/>
<meta name="application-name" content="叉鸽 MrCroxx 的博客">
<meta name="apple-mobile-web-app-title" content="叉鸽 MrCroxx 的博客"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://mrcroxx.github.io/posts/code-reading/boltdb-made-simple/4-transaction/" /><link rel="prev" href="https://mrcroxx.github.io/posts/code-reading/boltdb-made-simple/3-bucket-cursor/" /><link rel="next" href="https://mrcroxx.github.io/posts/code-reading/leveldb-made-simple/0-introduction/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "深入浅出boltdb —— 0x04 事务",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/mrcroxx.github.io\/posts\/code-reading\/boltdb-made-simple\/4-transaction\/"
        },"image": [{
                            "@type": "ImageObject",
                            "url": "https:\/\/mrcroxx.github.io\/posts\/code-reading\/boltdb-made-simple\/4-transaction\/boltdb.jpg",
                            "width":  1200 ,
                            "height":  360 
                        }],"genre": "posts","keywords": "boltdb, B\x2bTree","wordcount":  13331 ,
        "url": "https:\/\/mrcroxx.github.io\/posts\/code-reading\/boltdb-made-simple\/4-transaction\/","datePublished": "2021-01-26T13:30:24+08:00","dateModified": "2021-02-05T21:21:25+08:00","publisher": {
            "@type": "Organization",
            "name": "叉鸽"},"author": {
                "@type": "Person",
                "name": "叉鸽"
            },"description": ""
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : '' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="叉鸽 MrCroxx 的博客"><span id="id-1" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 所有文章 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/tags/"> 标签 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="叉鸽 MrCroxx 的博客"><span id="id-2" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">所有文章</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/tags/" title="">标签</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">深入浅出boltdb —— 0x04 事务</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="about" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>叉鸽</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAboltdb/"><i class="far fa-folder fa-fw"></i>深入浅出boltdb</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-01-26">2021-01-26</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 13331 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 27 分钟&nbsp;</div>
        </div><div class="featured-image"><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/posts/code-reading/boltdb-made-simple/4-transaction/boltdb.jpg"
        data-srcset="/posts/code-reading/boltdb-made-simple/4-transaction/boltdb.jpg, /posts/code-reading/boltdb-made-simple/4-transaction/boltdb.jpg 1.5x, /posts/code-reading/boltdb-made-simple/4-transaction/boltdb.jpg 2x"
        data-sizes="auto"
        alt="/posts/code-reading/boltdb-made-simple/4-transaction/boltdb.jpg"
        title="/posts/code-reading/boltdb-made-simple/4-transaction/boltdb.jpg" /></div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#0-引言">0. 引言</a></li>
    <li><a href="#1-事务">1. 事务</a>
      <ul>
        <li><a href="#11-事务的acid性质">1.1 事务的ACID性质</a></li>
        <li><a href="#12-boltdb中acid的实现">1.2 boltdb中ACID的实现</a></li>
      </ul>
    </li>
    <li><a href="#2-boltdb中事务的封装与实现">2. boltdb中事务的封装与实现</a>
      <ul>
        <li><a href="#21-tx结构体">2.1 Tx结构体</a></li>
        <li><a href="#22-事务的生命周期">2.2 事务的生命周期</a>
          <ul>
            <li><a href="#221-事务开始">2.2.1 事务开始</a></li>
            <li><a href="#222-事务提交">2.2.2 事务提交</a></li>
            <li><a href="#223-事务回滚">2.2.3 事务回滚</a></li>
            <li><a href="#224-事务关闭">2.2.4 事务关闭</a></li>
          </ul>
        </li>
        <li><a href="#23-内置隐式事务">2.3 内置隐式事务</a>
          <ul>
            <li><a href="#231-隐式读写事务与隐式只读事务">2.3.1 隐式读写事务与隐式只读事务</a></li>
            <li><a href="#232-批处理隐式读写事务">2.3.2 批处理隐式读写事务</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#3-总结">3. 总结</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><p><em>本文为原创文章，转载请严格遵守<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener noreffer">CC BY-NC-SA协议</a>。</em></p>
<h2 id="0-引言">0. 引言</h2>
<p>boltdb是一个支持完整ACID事务的kv数据。虽然boltdb将“事务”封装成了<code>tx.go</code>中的<code>Tx</code>结构体，但boltdb中处处实现都与事务息息相关，<code>Tx</code>结构体只提供了事务的抽象。</p>
<p>因此本文将从整体的视角介绍事务与boltdb中事务的实现，并介绍<code>tx.go</code>与<code>db.go</code>中的源码。</p>
<h2 id="1-事务">1. 事务</h2>
<h3 id="11-事务的acid性质">1.1 事务的ACID性质</h3>
<p>ACID性质（Atomicity原子性、Consistency一致性、Isolation隔离性、Durability持久性）的解释方式有很多，笔者比较倾向于<a href="https://en.wikipedia.org/wiki/ACID" target="_blank" rel="noopener noreffer">英文wiki</a><sup>[引文1]</sup>和<a href="https://www.ibm.com/support/knowledgecenter/SSGMCP_5.4.0/product-overview/acid.html" target="_blank" rel="noopener noreffer">IBM Knowledge Center - ACID properties of transactions</a><sup>[引文2]</sup>中的描述。</p>
<div class="details admonition quote open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-quote-right fa-fw"></i>引文1<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p><strong>Atomicity :</strong></p>
<p>Transactions are often composed of multiple statements. Atomicity guarantees that each transaction is treated as a single &ldquo;unit&rdquo;, which either succeeds completely, or fails completely: if any of the statements constituting a transaction fails to complete, the entire transaction fails and the database is left unchanged. An atomic system must guarantee atomicity in each and every situation, including power failures, errors and crashes. A guarantee of atomicity prevents updates to the database occurring only partially, which can cause greater problems than rejecting the whole series outright. As a consequence, the transaction cannot be observed to be in progress by another database client. At one moment in time, it has not yet happened, and at the next it has already occurred in whole (or nothing happened if the transaction was cancelled in progress).</p>
<p><strong>Consistency :</strong></p>
<p>Consistency ensures that a transaction can only bring the database from one valid state to another, maintaining database invariants: any data written to the database must be valid according to all defined rules, including constraints, cascades, triggers, and any combination thereof. This prevents database corruption by an illegal transaction, but does not guarantee that a transaction is correct. Referential integrity guarantees the primary key – foreign key relationship.</p>
<p><strong>Isolation :</strong></p>
<p>Transactions are often executed concurrently (e.g., multiple transactions reading and writing to a table at the same time). Isolation ensures that concurrent execution of transactions leaves the database in the same state that would have been obtained if the transactions were executed sequentially. Isolation is the main goal of concurrency control; depending on the method used, the effects of an incomplete transaction might not even be visible to other transactions.</p>
<p><strong>Durability :</strong></p>
<p>Durability guarantees that once a transaction has been committed, it will remain committed even in the case of a system failure (e.g., power outage or crash). This usually means that completed transactions (or their effects) are recorded in non-volatile memory.</p>
</div>
        </div>
    </div>
<div class="details admonition quote open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-quote-right fa-fw"></i>引文2<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p><strong>Atomicity :</strong></p>
<p>All changes to data are performed as if they are a single operation. That is, all the changes are performed, or none of them are.
For example, in an application that transfers funds from one account to another, the atomicity property ensures that, if a debit is made successfully from one account, the corresponding credit is made to the other account.</p>
<p><strong>Consistency :</strong></p>
<p>Data is in a consistent state when a transaction starts and when it ends.
For example, in an application that transfers funds from one account to another, the consistency property ensures that the total value of funds in both the accounts is the same at the start and end of each transaction.</p>
<p><strong>Isolation :</strong></p>
<p>The intermediate state of a transaction is invisible to other transactions. As a result, transactions that run concurrently appear to be serialized.
For example, in an application that transfers funds from one account to another, the isolation property ensures that another transaction sees the transferred funds in one account or the other, but not in both, nor in neither.</p>
<p><strong>Durability :</strong></p>
<p>After a transaction successfully completes, changes to data persist and are not undone, even in the event of a system failure.
For example, in an application that transfers funds from one account to another, the durability property ensures that the changes made to each account will not be reversed.</p>
</div>
        </div>
    </div>
<p>关于ACID中的Isolation隔离性，可以分为多个隔离级别（Isolation levels）。关于隔离级别，笔者建议阅读<a href="https://en.wikipedia.org/wiki/Isolation_%28database_systems%29" target="_blank" rel="noopener noreffer">英文wiki</a>提供的描述<sup>[引文3]</sup>。</p>
<div class="details admonition quote open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-quote-right fa-fw"></i>引文3<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p><strong>Serializable</strong></p>
<p>This is the highest isolation level.</p>
<p>With a lock-based concurrency control DBMS implementation, serializability requires read and write locks (acquired on selected data) to be released at the end of the transaction. Also range-locks must be acquired when a SELECT query uses a ranged WHERE clause, especially to avoid the phantom reads phenomenon.</p>
<p>When using non-lock based concurrency control, no locks are acquired; however, if the system detects a write collision among several concurrent transactions, only one of them is allowed to commit. See snapshot isolation for more details on this topic.</p>
<p><strong>Repeatable reads</strong></p>
<p>In this isolation level, a lock-based concurrency control DBMS implementation keeps read and write locks (acquired on selected data) until the end of the transaction. However, range-locks are not managed, so phantom reads can occur.</p>
<p>Write skew is possible at this isolation level, a phenomenon where two writes are allowed to the same column(s) in a table by two different writers (who have previously read the columns they are updating), resulting in the column having data that is a mix of the two transactions.</p>
<p><strong>Read committed</strong></p>
<p>In this isolation level, a lock-based concurrency control DBMS implementation keeps write locks (acquired on selected data) until the end of the transaction, but read locks are released as soon as the SELECT operation is performed (so the non-repeatable reads phenomenon can occur in this isolation level). As in the previous level, range-locks are not managed.</p>
<p>Putting it in simpler words, read committed is an isolation level that guarantees that any data read is committed at the moment it is read. It simply restricts the reader from seeing any intermediate, uncommitted, &lsquo;dirty&rsquo; read. It makes no promise whatsoever that if the transaction re-issues the read, it will find the same data; data is free to change after it is read.</p>
<p><strong>Read uncommitted</strong>
This is the lowest isolation level. In this level, dirty reads are allowed, so one transaction may see not-yet-committed changes made by other transactions.</p>
</div>
        </div>
    </div>
<p>不同隔离级别相应的问题可总结为下表：</p>
<table>
<thead>
<tr>
<th align="center">隔离级别<br>（isolation level）<div style="width:12em"></div></th>
<th align="center">脏读<br>（dirty reads）<div style="width:8em"></div></th>
<th align="center">不可重复读<br>（non-repeatable reads）<div style="width:14em"></div></th>
<th align="center">幻读<br>（phantom reads）<div style="width:10em"></div></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">未提交读<br>（read uncommitted）</td>
<td align="center">⚠</td>
<td align="center">⚠</td>
<td align="center">⚠</td>
</tr>
<tr>
<td align="center">提交读<br>（read committed）</td>
<td align="center"></td>
<td align="center">⚠</td>
<td align="center">⚠</td>
</tr>
<tr>
<td align="center">可重复读<br>（repeatable reads）</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">⚠</td>
</tr>
<tr>
<td align="center">序列化读<br>（serializable）</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody>
</table>
<h3 id="12-boltdb中acid的实现">1.2 boltdb中ACID的实现</h3>
<p>在笔者看来，ACID性质的实现并不是相互孤立的，而是通过各种技术整体实现的。但是为了理解的清晰，这里简要划分一下boltdb中各种技术与ACID间的关系。</p>
<p><strong>Atomicity（原子性）：</strong></p>
<p>boltdb中事务的原子性是通过<a href="https://en.wikipedia.org/wiki/Shadow_paging" target="_blank" rel="noopener noreffer">Shadow Paging</a>实现的。当事务中的操作修改boltdb中的数据时，其不会直接修改数据库文件（mmap memory中的page），而是将更新内容写入到page buffer中。在事务提交时，会一并将这些page buffer中的dirty page写入到底层数据库文件，然后更新元数据将其指向新的页。因此，事务没有中间状态：要么全部写入，要么因回滚被丢弃。在元数据更新前，其指向的是事务执行前的旧page。因此，如果数据库在page buffer写入后且在元数据更新前故障，则数据仍保持在事务提交前的状态，而没有中间状态。</p>
<p><strong>Consistency（一致性）：</strong></p>
<p>数据库的“Consistency一致性”指事务前后的数据是否符合约束，有些资料也称其为“数据完整性”或“数据有效性”，论文《A relational model of data for large shared data banks》中有对其概念的形式化描述，感兴趣的读者可以看一下。</p>
<p>虽然boltdb不支持用户自定义约束，但笔者认为<sub>不保证正确性</sub>，boltdb中B+Tree结构也作为一种隐式约束。boltdb事务提交时，会通过<code>rebalance</code>与<code>spill</code>方法调整B+Tree结构，以使其满足B+Tree的性质。</p>
<p>有一种对ACID的解释为：Consistency是最终要实现的目标，而Atomicity、Isolation、Durability是实现Consistency的保证。笔者也比较认同这一观点，这也体现了ACID各个性质的实现不是孤立的，而是整个系统的结果。</p>
<p><strong>Isolation（隔离性）：</strong></p>
<p>上一节介绍了Isolation隔离性对应的4种隔离级别，boltdb实现的是最高的隔离界别：serializable序列化读。在serializable的基础上，boltdb支持“读读并发”与“读写并发”，boltdb中同时可以执行若干个只读事务，但同时只能执行一个读写事务，但只读事务与读写事务之间不影响。</p>
<p>Shadow Paging同样为实现事务隔离提供了支持。为了保证serializable的同时实现读写并发，当读写事务提交时，boltdb不会立即回收其不再使用的页（shadow page），这些页仍在freelist中该事务的<code>pending</code>列表中，因为此时这些页可能还在被未完成的只读事务读取。取而代之的是，boltdb会在事务开始时为其分配事务id<code>txid</code>，只读事务的<code>txid</code>为当前数据库的<code>txid</code>，读写事务的<code>txid</code>为当前数据库的<code>txid + 1</code>。boltdb会记录正在执行的事务的事务id；当创建读写事务时，boltdb会从只读事务中找到进行中的最小的<code>txid</code>，显然，该<code>txid</code>之前的读写事务的shadow page不再需要被读取，此时可以安全地释放这些读写事务的shadow page，即可以freelist中该事务的<code>pending</code>列表中的页合并到freelist的<code>ids</code>中。</p>
<p>Shadow Paging保证了读读并发、读写并发的事务隔离性，boltdb还需要保证最多只有1个读写事务在进行。boltdb的读写事务开始前会申请互斥锁，以避免读写事务并行执行。这里需要注意两点：第一，因为boltdb支持读写并发，所以只读事务不需要申请S锁，否则只有读读事务才能并行执行；第二，在数据库领域，这种锁机制应叫做“latch”而非“lock”，只是其粒度较大。CMU 15-721中较为详细地介绍了Lock与Latch的区别，这里笔者搬运一下其总结表格。</p>
<table>
<thead>
<tr>
<th align="center"><div style="width:6em"></div></th>
<th align="center">Locks<div style="width:10em"></div></th>
<th align="center">Latches<div style="width:10em"></div></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">Separate &hellip;</td>
<td align="center">User transactions</td>
<td align="center">Threads</td>
</tr>
<tr>
<td align="center">Proetect &hellip;</td>
<td align="center">Database contents</td>
<td align="center">In-memory data structures</td>
</tr>
<tr>
<td align="center">During &hellip;</td>
<td align="center">Entire transactions</td>
<td align="center">Critical sections</td>
</tr>
<tr>
<td align="center">Modes &hellip;</td>
<td align="center">Shared, exclusive, update, intention, escrow, schema, etc.</td>
<td align="center">Read, writes, (perhaps) update</td>
</tr>
<tr>
<td align="center">Deadlock &hellip;</td>
<td align="center">Detection &amp; resolution</td>
<td align="center">Avoidance</td>
</tr>
<tr>
<td align="center">&hellip; by &hellip;</td>
<td align="center">Aanlysis of the waits-for graph, timeout, transaction abort, partial rollback, lock de-escalation</td>
<td align="center">Coding discipline, &ldquo;lock leveling&rdquo;</td>
</tr>
<tr>
<td align="center">Kept in &hellip;</td>
<td align="center">Lock manager&rsquo;s hash table</td>
<td align="center">Protected data structure</td>
</tr>
</tbody>
</table>
<p><strong>Durability（持久性）：</strong></p>
<p>boltdb的读写事务提交时，会通过pwrite系统调用写底层文件，并通过fdatasync系统调用确保数据被安全写入到磁盘中。因为boltdb的mmap模式为<code>MAP_SHARED</code>，因此绕过mmap直接写入底层文件不会影响mmap中数据对底层文件修改的可见性。</p>
<h2 id="2-boltdb中事务的封装与实现">2. boltdb中事务的封装与实现</h2>
<p>boltdb将事务封装成了<code>tx.go</code>中的<code>Tx</code>结构体。但只从<code>Tx</code>结构体分析boltdb中事务的封装与实现是不够的。因此，本节将先介绍<code>Tx</code>结构体的基本实现，然后按照事务的生命周期的顺序，介绍boltdb中<code>tx.go</code>与<code>db.go</code>中对事务的封装与实现。</p>
<h3 id="21-tx结构体">2.1 Tx结构体</h3>
<p><code>Tx</code>结构体的源码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// txid represents the internal transaction identifier.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">txid</span> <span class="kt">uint64</span>

<span class="c1">// Tx represents a read-only or read/write transaction on the database.
</span><span class="c1">// Read-only transactions can be used for retrieving values for keys and creating cursors.
</span><span class="c1">// Read/write transactions can create and remove buckets and create and remove keys.
</span><span class="c1">//
</span><span class="c1">// IMPORTANT: You must commit or rollback transactions when you are done with
</span><span class="c1">// them. Pages can not be reclaimed by the writer until no more transactions
</span><span class="c1">// are using them. A long running read transaction can cause the database to
</span><span class="c1">// quickly grow.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Tx</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">writable</span>       <span class="kt">bool</span>
	<span class="nx">managed</span>        <span class="kt">bool</span>
	<span class="nx">db</span>             <span class="o">*</span><span class="nx">DB</span>
	<span class="nx">meta</span>           <span class="o">*</span><span class="nx">meta</span>
	<span class="nx">root</span>           <span class="nx">Bucket</span>
	<span class="nx">pages</span>          <span class="kd">map</span><span class="p">[</span><span class="nx">pgid</span><span class="p">]</span><span class="o">*</span><span class="nx">page</span>
	<span class="nx">stats</span>          <span class="nx">TxStats</span>
	<span class="nx">commitHandlers</span> <span class="p">[]</span><span class="kd">func</span><span class="p">()</span>

	<span class="c1">// WriteFlag specifies the flag for write-related methods like WriteTo().
</span><span class="c1"></span>	<span class="c1">// Tx opens the database file with the specified flag to copy the data.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// By default, the flag is unset, which works well for mostly in-memory
</span><span class="c1"></span>	<span class="c1">// workloads. For databases that are much larger than available RAM,
</span><span class="c1"></span>	<span class="c1">// set the flag to syscall.O_DIRECT to avoid trashing the page cache.
</span><span class="c1"></span>	<span class="nx">WriteFlag</span> <span class="kt">int</span>
<span class="p">}</span>

</code></pre></div><table>
<thead>
<tr>
<th align="center">字段<div style="width:12em"></div></th>
<th align="left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>writable bool</code></td>
<td align="left">true表示当前事务为读写事务，false表示当前事务为只读事务。</td>
</tr>
<tr>
<td align="center"><code>managed bool</code></td>
<td align="left">标识当前事务是否为隐式事务，隐式事务由boltdb自动提交或回滚，用户不能主动提交或回滚。</td>
</tr>
<tr>
<td align="center"><code>db *DB</code></td>
<td align="left">创建该事务的数据库对象。</td>
</tr>
<tr>
<td align="center"><code>meta *meta</code></td>
<td align="left">当前事务创建时的<code>meta</code>拷贝。</td>
</tr>
<tr>
<td align="center"><code>root Bucket</code></td>
<td align="left">当前事务所见的root bucket的<code>Bucket</code>实例。</td>
</tr>
<tr>
<td align="center"><code>page map[pgid]*page</code></td>
<td align="left">索引当前事务所使用的dirty page（page buffer）。</td>
</tr>
<tr>
<td align="center"><code>stats TxStats</code></td>
<td align="left">统计变量。</td>
</tr>
<tr>
<td align="center"><code>commitHandlers []func()</code></td>
<td align="left">事务成功提交后需调用的回调函数列表。</td>
</tr>
<tr>
<td align="center"><code>WriteFlag int</code></td>
<td align="left"><code>WriteTo</code>方法reader打开文件时可配置的额外的flag。</td>
</tr>
</tbody>
</table>
<p><code>Tx</code>为boltdb的用户提供了一些方法来访问其中部分字段：</p>
<table>
<thead>
<tr>
<th align="center">方法<div style="width:12em"></div></th>
<th align="left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>ID() int</code></td>
<td align="left">返回当前事务id（<code>tx.meta.txid</code>）。</td>
</tr>
<tr>
<td align="center"><code>DB *DB</code></td>
<td align="left">返回创建当前事务的数据库实例。</td>
</tr>
<tr>
<td align="center"><code>Size() int64</code></td>
<td align="left">返回当前事务所见的数据库大小（非数据大小）。</td>
</tr>
<tr>
<td align="center"><code>Writable() bool</code></td>
<td align="left">返回当前事务事务可写。</td>
</tr>
<tr>
<td align="center"><code>Stats() TxStats</code></td>
<td align="left">返回当前事务的统计量。</td>
</tr>
</tbody>
</table>
<p>此外，<code>Tx</code>还为boltdb的用户提供了一些访问root bucket的方法：</p>
<table>
<thead>
<tr>
<th align="center">方法<div style="width:12em"></div></th>
<th align="left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>Cursor() *Cursor</code></td>
<td align="left"><code>tx.root.Cursor()</code>。从当前事务获取root bucket的<code>Cursor</code>。由于root bucket中只保存子bucket，因此其返回的所有value都是nil。</td>
</tr>
<tr>
<td align="center"><code>Bucket(name []byte) *Bucket</code></td>
<td align="left"><code>tx.root.Bucket(name)</code>。获取root bucket的子bucket。</td>
</tr>
<tr>
<td align="center"><code>CreateBucket(name []byte) (*Bucket, error)</code></td>
<td align="left"><code>tx.root.CreateBucket(name)</code></td>
</tr>
<tr>
<td align="center"><code>CreateBucketIfNotExists(name []byte) (*Bucket, error)</code></td>
<td align="left"><code>tx.root.CreateBucketIfNotExists(name)</code>。如果root bucket的子bucket未创建，则创建子bucket并返回实例；否则直接返回其实例。</td>
</tr>
<tr>
<td align="center"><code>DeleteBucket(name []byte) error</code></td>
<td align="left"><code>tx.root.DeleteBucket(name)</code>。删除root bucket的子bucket。</td>
</tr>
<tr>
<td align="center"><code>ForEach(fn func(name []byte, b *Bucket) error) error</code></td>
<td align="left">遍历root bucket的所有子bucket并执行给定闭包。</td>
</tr>
</tbody>
</table>
<h3 id="22-事务的生命周期">2.2 事务的生命周期</h3>
<p>本节将按照事务的生命周期，介绍并分析boltdb中事务的封装与实现。</p>
<p>在介绍事务的生命周期前，先简单介绍一下boltdb的<code>DB</code>中三把重要的锁：</p>
<table>
<thead>
<tr>
<th align="center">字段<div style="width:10em"></div></th>
<th align="left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><code>rwlock sync.Mutex</code></td>
<td align="left">用来隔离可写事务的互斥锁（注意，不是读写锁）。</td>
</tr>
<tr>
<td align="center"><code>metalock sync.Mutex</code></td>
<td align="left">用来保护元数据访问的互斥锁。</td>
</tr>
<tr>
<td align="center"><code>mmaplock sync.RWMutex</code></td>
<td align="left">用来保护mmap操作的读写锁。</td>
</tr>
</tbody>
</table>
<p>boltdb支持“读读并发”与“读写并发”，用来隔离事务的锁<code>rwlock</code>是互斥锁，只有可写事务需要获取该锁，只读事务不受影响。由于事务开始时，需要复制当时的元数据，因此这里使用了互斥锁<code>metalock</code>来保护事务开始时的元数据访问，当事务初始化完成后就会释放<code>metalock</code>；另外，只读事务关闭时也需要获取<code>metalock</code>，但其目的是保护对<code>DB</code>对象的访问，而不时保护<code>meta</code>。而<code>mmaplock</code>是用来保护mmap操作的读写锁，只读事务会获取<code>mmaplock</code>的S锁，而mmap操作会获取<code>mmaplock</code>的X锁。这样，当可写事务需要更大的mmap空间时，其需要等待之前的只读事务都执行完毕，以避免只读事务引用的mmap地址失效；对于可写事务本身，其在mmap前会从根<code>Bucket</code>实例开始<code>dereference</code>操作，以避免可写事务本身引用了旧的mmap地址空间。</p>
<p>这三种锁的获取顺序是：（<code>rwlock</code>） $\rightarrow$ <code>metalock</code> $\rightarrow$ （<code>mmaplock</code>）。</p>
<p>此外，boltdb中还有两把锁。其一是读写锁<code>statlock sync.RWMutex</code>，其作用是保护统计量的访问，这里不作重点介绍；其二是互斥锁<code>batchMu</code>，该锁用来保护数据库实例的<code>batch</code>字段，作用较为单一，本文在<a href="#232-%e6%89%b9%e5%a4%84%e7%90%86%e9%9a%90%e5%bc%8f%e8%af%bb%e5%86%99%e4%ba%8b%e5%8a%a1" rel="">2.3.2节</a>介绍。</p>
<h4 id="221-事务开始">2.2.1 事务开始</h4>
<p>boltdb的用户可以通过<code>DB</code>的<code>Begin</code>方法启动一个事务，通过<code>Begin</code>方法启动的事务需要用户自己控制其提交或回滚（用户还可以通过<code>Update</code>或<code>View</code>方法启动隐式事务，但二者都是对<code>Begin</code>的封装，因此放在最后介绍）。</p>
<p><code>Begin</code>方法的实现如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// Begin starts a new transaction.
</span><span class="c1">// Multiple read-only transactions can be used concurrently but only one
</span><span class="c1">// write transaction can be used at a time. Starting multiple write transactions
</span><span class="c1">// will cause the calls to block and be serialized until the current write
</span><span class="c1">// transaction finishes.
</span><span class="c1">//
</span><span class="c1">// Transactions should not be dependent on one another. Opening a read
</span><span class="c1">// transaction and a write transaction in the same goroutine can cause the
</span><span class="c1">// writer to deadlock because the database periodically needs to re-mmap itself
</span><span class="c1">// as it grows and it cannot do that while a read transaction is open.
</span><span class="c1">//
</span><span class="c1">// If a long running read transaction (for example, a snapshot transaction) is
</span><span class="c1">// needed, you might want to set DB.InitialMmapSize to a large enough value
</span><span class="c1">// to avoid potential blocking of write transaction.
</span><span class="c1">//
</span><span class="c1">// IMPORTANT: You must close read-only transactions after you are finished or
</span><span class="c1">// else the database will not reclaim old pages.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">Begin</span><span class="p">(</span><span class="nx">writable</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Tx</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">writable</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">db</span><span class="p">.</span><span class="nf">beginRWTx</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">db</span><span class="p">.</span><span class="nf">beginTx</span><span class="p">()</span>
<span class="p">}</span>

</code></pre></div><p><code>Begin</code>方法会根据事务是否可写，调用<code>beginRWTx</code>方法或<code>beginTx</code>方法。</p>
<p>接下来首先分析启动只读事务<code>beginTx</code>方法的实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">beginTx</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">Tx</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Lock the meta pages while we initialize the transaction. We obtain
</span><span class="c1"></span>	<span class="c1">// the meta lock before the mmap lock because that&#39;s the order that the
</span><span class="c1"></span>	<span class="c1">// write transaction will obtain them.
</span><span class="c1"></span>	<span class="nx">db</span><span class="p">.</span><span class="nx">metalock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>

	<span class="c1">// Obtain a read-only lock on the mmap. When the mmap is remapped it will
</span><span class="c1"></span>	<span class="c1">// obtain a write lock so all transactions must finish before it can be
</span><span class="c1"></span>	<span class="c1">// remapped.
</span><span class="c1"></span>	<span class="nx">db</span><span class="p">.</span><span class="nx">mmaplock</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>

	<span class="c1">// Exit if the database is not open yet.
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">db</span><span class="p">.</span><span class="nx">opened</span> <span class="p">{</span>
		<span class="nx">db</span><span class="p">.</span><span class="nx">mmaplock</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
		<span class="nx">db</span><span class="p">.</span><span class="nx">metalock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrDatabaseNotOpen</span>
	<span class="p">}</span>

	<span class="c1">// Create a transaction associated with the database.
</span><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Tx</span><span class="p">{}</span>
	<span class="nx">t</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">db</span><span class="p">)</span>

	<span class="c1">// Keep track of transaction until it closes.
</span><span class="c1"></span>	<span class="nx">db</span><span class="p">.</span><span class="nx">txs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">txs</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">txs</span><span class="p">)</span>

	<span class="c1">// Unlock the meta pages.
</span><span class="c1"></span>	<span class="nx">db</span><span class="p">.</span><span class="nx">metalock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="c1">// Update the transaction stats.
</span><span class="c1"></span>	<span class="nx">db</span><span class="p">.</span><span class="nx">statlock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">db</span><span class="p">.</span><span class="nx">stats</span><span class="p">.</span><span class="nx">TxN</span><span class="o">++</span>
	<span class="nx">db</span><span class="p">.</span><span class="nx">stats</span><span class="p">.</span><span class="nx">OpenTxN</span> <span class="p">=</span> <span class="nx">n</span>
	<span class="nx">db</span><span class="p">.</span><span class="nx">statlock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="k">return</span> <span class="nx">t</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

</code></pre></div><p><code>beginTx</code>方法执行了如下操作：</p>
<ol>
<li>获取<code>metalock</code>锁与<code>mmaplock</code>的S锁。</li>
<li>检测数据库是否打开，如果没打开则释放锁并返回错误。</li>
<li>创建<code>writable</code>为false的<code>Tx</code>对象，调用<code>init</code>方法初始化<code>Tx</code>对象（<code>Tx</code>对象初始化时会复制当前的<code>meta</code>）。</li>
<li>将事务保存到<code>DB</code>的<code>txs</code>字段中。</li>
<li>释放<code>metalock</code>。</li>
<li>更新统计量，返回事务对象<code>Tx</code>。</li>
</ol>
<p><code>beginRWTx</code>方法实现与之相似：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">beginRWTx</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="nx">Tx</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// If the database was opened with Options.ReadOnly, return an error.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">db</span><span class="p">.</span><span class="nx">readOnly</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrDatabaseReadOnly</span>
	<span class="p">}</span>

	<span class="c1">// Obtain writer lock. This is released by the transaction when it closes.
</span><span class="c1"></span>	<span class="c1">// This enforces only one writer transaction at a time.
</span><span class="c1"></span>	<span class="nx">db</span><span class="p">.</span><span class="nx">rwlock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>

	<span class="c1">// Once we have the writer lock then we can lock the meta pages so that
</span><span class="c1"></span>	<span class="c1">// we can set up the transaction.
</span><span class="c1"></span>	<span class="nx">db</span><span class="p">.</span><span class="nx">metalock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">db</span><span class="p">.</span><span class="nx">metalock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="c1">// Exit if the database is not open yet.
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">db</span><span class="p">.</span><span class="nx">opened</span> <span class="p">{</span>
		<span class="nx">db</span><span class="p">.</span><span class="nx">rwlock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrDatabaseNotOpen</span>
	<span class="p">}</span>

	<span class="c1">// Create a transaction associated with the database.
</span><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Tx</span><span class="p">{</span><span class="nx">writable</span><span class="p">:</span> <span class="kc">true</span><span class="p">}</span>
	<span class="nx">t</span><span class="p">.</span><span class="nf">init</span><span class="p">(</span><span class="nx">db</span><span class="p">)</span>
	<span class="nx">db</span><span class="p">.</span><span class="nx">rwtx</span> <span class="p">=</span> <span class="nx">t</span>

	<span class="c1">// Free any pages associated with closed read-only transactions.
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">minid</span> <span class="nx">txid</span> <span class="p">=</span> <span class="mh">0xFFFFFFFFFFFFFFFF</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">t</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">db</span><span class="p">.</span><span class="nx">txs</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">txid</span> <span class="p">&lt;</span> <span class="nx">minid</span> <span class="p">{</span>
			<span class="nx">minid</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">txid</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">minid</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">db</span><span class="p">.</span><span class="nx">freelist</span><span class="p">.</span><span class="nf">release</span><span class="p">(</span><span class="nx">minid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">t</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

</code></pre></div><p><code>beginRWTx</code>方法执行了如下操作：</p>
<ol>
<li>若事务为只读事务，返回错误。</li>
<li>获取<code>rwlock</code>锁与<code>metalock</code>锁，并通过<code>defer</code>关键字确保<code>metalock</code>会在函数返回前被安全释放。</li>
<li>检测数据库是否打开，如果没打开则释放锁并返回错误。</li>
<li>创建<code>writable</code>为true的<code>Tx</code>对象，调用<code>init</code>方法初始化<code>Tx</code>对象（<code>Tx</code>对象初始化时会复制当前的<code>meta</code>），并更新<code>DB</code>的<code>rwtx</code>字段为当前<code>Tx</code>对象。</li>
<li>释放不再使用的shadow page。</li>
</ol>
<p>boltdb释放不再使用的shadow page的方法是：找到当前还在执行的读写事务中最小的<code>txid</code>，记为<code>minid</code>。显然，在该<code>minid</code>之前的读写事务产生的shadow page不再会被读取，此时，通过<code>freelist</code>的<code>release</code>方法释放<code>txid</code>不超过<code>minid-1</code>的事务产生的shadow page。</p>
<p>接下来分析初始化<code>Tx</code>对象时调用的<code>init</code>方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// init initializes the transaction.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="nf">init</span><span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">tx</span><span class="p">.</span><span class="nx">db</span> <span class="p">=</span> <span class="nx">db</span>
	<span class="nx">tx</span><span class="p">.</span><span class="nx">pages</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="c1">// Copy the meta page since it can be changed by the writer.
</span><span class="c1"></span>	<span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">meta</span><span class="p">{}</span>
	<span class="nx">db</span><span class="p">.</span><span class="nf">meta</span><span class="p">().</span><span class="nb">copy</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">)</span>

	<span class="c1">// Copy over the root bucket.
</span><span class="c1"></span>	<span class="nx">tx</span><span class="p">.</span><span class="nx">root</span> <span class="p">=</span> <span class="nf">newBucket</span><span class="p">(</span><span class="nx">tx</span><span class="p">)</span>
	<span class="nx">tx</span><span class="p">.</span><span class="nx">root</span><span class="p">.</span><span class="nx">bucket</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">bucket</span><span class="p">{}</span>
	<span class="o">*</span><span class="nx">tx</span><span class="p">.</span><span class="nx">root</span><span class="p">.</span><span class="nx">bucket</span> <span class="p">=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">root</span>

	<span class="c1">// Increment the transaction id and add a page cache for writable transactions.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">writable</span> <span class="p">{</span>
		<span class="nx">tx</span><span class="p">.</span><span class="nx">pages</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">pgid</span><span class="p">]</span><span class="o">*</span><span class="nx">page</span><span class="p">)</span>
		<span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">txid</span> <span class="o">+=</span> <span class="nf">txid</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div><p><code>init</code>方法初始化了<code>Tx</code>的一些字段。因为boltdb支持事务读写并发，所以其深拷贝了事务创建时的<code>meta</code>数据与root bucket的元数据，以避免只读事务读取到后续读写事务更新过的元数据。</p>
<p><code>init</code>方法还为读写事务初始化了<code>pages</code>字段，该字段是用来记录事务写入的dirty page（page buffer）的cache。此外，<code>init</code>在初始化读写事务时还会将其<code>meta</code>中的<code>txid + 1</code>。</p>
<h4 id="222-事务提交">2.2.2 事务提交</h4>
<p>boltdb的用户可以通过<code>Tx</code>的<code>Commit</code>方法提交非隐式事务；而隐式事务的提交则由boltdb调用该方法实现（在调用前会将其<code>managed</code>字段置为false以避免返回错误）。在提交前，用户还可以通过<code>OnCommit</code>方法注册事务的回调方法。</p>
<p>本节将介绍事务提交的实现。</p>
<h5 id="2221-commit方法">2.2.2.1 Commit方法</h5>
<p>事务提交方法<code>Commit</code>与注册成功提交回调的方法<code>OnCommit</code>的实现如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// OnCommit adds a handler function to be executed after the transaction successfully commits.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="nf">OnCommit</span><span class="p">(</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
	<span class="nx">tx</span><span class="p">.</span><span class="nx">commitHandlers</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">commitHandlers</span><span class="p">,</span> <span class="nx">fn</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Commit writes all changes to disk and updates the meta page.
</span><span class="c1">// Returns an error if a disk write error occurs, or if Commit is
</span><span class="c1">// called on a read-only transaction.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="nf">Commit</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nf">_assert</span><span class="p">(!</span><span class="nx">tx</span><span class="p">.</span><span class="nx">managed</span><span class="p">,</span> <span class="s">&#34;managed tx commit not allowed&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ErrTxClosed</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">!</span><span class="nx">tx</span><span class="p">.</span><span class="nx">writable</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ErrTxNotWritable</span>
	<span class="p">}</span>

	<span class="c1">// TODO(benbjohnson): Use vectorized I/O to write out dirty pages.
</span><span class="c1"></span>
	<span class="c1">// Rebalance nodes which have had deletions.
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">startTime</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
	<span class="nx">tx</span><span class="p">.</span><span class="nx">root</span><span class="p">.</span><span class="nf">rebalance</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">stats</span><span class="p">.</span><span class="nx">Rebalance</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">tx</span><span class="p">.</span><span class="nx">stats</span><span class="p">.</span><span class="nx">RebalanceTime</span> <span class="o">+=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">startTime</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// spill data onto dirty pages.
</span><span class="c1"></span>	<span class="nx">startTime</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">root</span><span class="p">.</span><span class="nf">spill</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">tx</span><span class="p">.</span><span class="nf">rollback</span><span class="p">()</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">tx</span><span class="p">.</span><span class="nx">stats</span><span class="p">.</span><span class="nx">SpillTime</span> <span class="o">+=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">startTime</span><span class="p">)</span>

	<span class="c1">// Free the old root bucket.
</span><span class="c1"></span>	<span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">root</span><span class="p">.</span><span class="nx">root</span> <span class="p">=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">root</span><span class="p">.</span><span class="nx">root</span>

	<span class="nx">opgid</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">pgid</span>

	<span class="c1">// Free the freelist and allocate new pages for it. This will overestimate
</span><span class="c1"></span>	<span class="c1">// the size of the freelist but not underestimate the size (which would be bad).
</span><span class="c1"></span>	<span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">freelist</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">txid</span><span class="p">,</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">page</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">freelist</span><span class="p">))</span>
	<span class="nx">p</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">allocate</span><span class="p">((</span><span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">freelist</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">/</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">pageSize</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">tx</span><span class="p">.</span><span class="nf">rollback</span><span class="p">()</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">freelist</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nx">p</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">tx</span><span class="p">.</span><span class="nf">rollback</span><span class="p">()</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">freelist</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">id</span>

	<span class="c1">// If the high water mark has moved up then attempt to grow the database.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">pgid</span> <span class="p">&gt;</span> <span class="nx">opgid</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">grow</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">pgid</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">pageSize</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">tx</span><span class="p">.</span><span class="nf">rollback</span><span class="p">()</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Write dirty pages to disk.
</span><span class="c1"></span>	<span class="nx">startTime</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">write</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">tx</span><span class="p">.</span><span class="nf">rollback</span><span class="p">()</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="c1">// If strict mode is enabled then perform a consistency check.
</span><span class="c1"></span>	<span class="c1">// Only the first consistency error is reported in the panic.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">StrictMode</span> <span class="p">{</span>
		<span class="nx">ch</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Check</span><span class="p">()</span>
		<span class="kd">var</span> <span class="nx">errs</span> <span class="p">[]</span><span class="kt">string</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="nx">err</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="nx">errs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">errs</span><span class="p">,</span> <span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">())</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">errs</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;check fail: &#34;</span> <span class="o">+</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">errs</span><span class="p">,</span> <span class="s">&#34;\n&#34;</span><span class="p">))</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Write meta to disk.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">writeMeta</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">tx</span><span class="p">.</span><span class="nf">rollback</span><span class="p">()</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">tx</span><span class="p">.</span><span class="nx">stats</span><span class="p">.</span><span class="nx">WriteTime</span> <span class="o">+=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">startTime</span><span class="p">)</span>

	<span class="c1">// Finalize the transaction.
</span><span class="c1"></span>	<span class="nx">tx</span><span class="p">.</span><span class="nb">close</span><span class="p">()</span>

	<span class="c1">// Execute commit handlers now that the locks have been removed.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">commitHandlers</span> <span class="p">{</span>
		<span class="nf">fn</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

</code></pre></div><p><code>Commit</code>方法可分为如下几个步骤：</p>
<ol>
<li>检查当前事务是否为隐式事务、是否已关闭、是为非读写事务，如果不是，则返回错误（隐式事务提交会引起panic）。</li>
<li>从root bucket开始执行<code>rebalance</code>操作与<code>spill</code>操作以调整B+Tree结构，并统计各自所用时间。</li>
<li>将当前事务<code>meta</code>中root bucket的pgid指向copy-on-write后新的root bucket。</li>
<li>释放旧freelist所在page，并为其分配新page，将其写入相应的page buffer中。</li>
<li>检查当前已使用的空间大小是否超过了底层数据库文件大小，如果超过了该大小需要通过<code>grow</code>方法增大数据库文件大小（详见下文说明）。</li>
<li>调用<code>Tx</code>的<code>write</code>方法，通过pwrite+fdatasync系统调用将dirty page写入的层文件，同时统计其耗时。</li>
<li>如果数据库处于严格模式<code>StructMode</code>，调用<code>Tx</code>的<code>Check</code>方法对数据库进行完整性检查。</li>
<li>调用<code>Tx</code>的<code>writeMeta</code>方法，通过pwrite+fdatasync系统调用将meta page写入的层文件。写入时根据事务<code>txid</code>交替写入meta page 0 或 1,。</li>
<li>调用<code>close</code>方法关闭事务。</li>
<li>一次调用之前通过<code>OnCommit</code>方法注册的回调函数。</li>
<li>如果步骤4~8出错，则通过<code>rollback</code>方法回滚事务。</li>
</ol>
<p>在<code>Commit</code>方法中，有一些地方需要注意，接下来笔者将依次对其进行介绍与分析（事务关闭方法在<a href="#224-%e4%ba%8b%e5%8a%a1%e5%85%b3%e9%97%ad" rel="">2.2.4节</a>中介绍）。</p>
<h5 id="2222-grow方法">2.2.2.2 grow方法</h5>
<p>第5步中的<code>grow</code>方法，是用来增长底层数据库文件大小的方法。在本系列的前文<a href="/posts/code-reading/boltdb-made-simple/1-storage-cache/" rel="">深入浅出boltdb —— 0x01 存储与缓存</a>中，笔者描述boltdb的mmap增长逻辑时埋下了一个伏笔：boltdb的mmap的增长策略是从32KB开始，每次倍增，在达到1GB后每次增长1GB；但是boltdb并不会在mmap的同时修改底层数据库文件大小。这样的问题是：当访问超出了文件大小的mmap空间时，会引起<code>SIGBUS</code>异常。为了避免访问越界，同时减少不必要的底层数据库文件增长，boltdb采用了在事务提交时按需增长的策略。</p>
<p>boltdb的实现方式是：在为事务分配完所需的页之后、在写入脏页前，先计算其使用了的空间大小（包括freelist中的页），即<code>int(tx.meta.pgid+1) * tx.db.pageSize</code>。之后调用<code>DB</code>的<code>grow</code>方法来按需增大底层数据库文件大小。其实现如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// grow grows the size of the database to the given sz.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">grow</span><span class="p">(</span><span class="nx">sz</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c1">// Ignore if the new size is less than available file size.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">sz</span> <span class="o">&lt;=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">filesz</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="c1">// If the data is smaller than the alloc size then only allocate what&#39;s needed.
</span><span class="c1"></span>	<span class="c1">// Once it goes over the allocation size then allocate in chunks.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">db</span><span class="p">.</span><span class="nx">datasz</span> <span class="p">&lt;</span> <span class="nx">db</span><span class="p">.</span><span class="nx">AllocSize</span> <span class="p">{</span>
		<span class="nx">sz</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">datasz</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">sz</span> <span class="o">+=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">AllocSize</span>
	<span class="p">}</span>

	<span class="c1">// Truncate and fsync to ensure file size metadata is flushed.
</span><span class="c1"></span>	<span class="c1">// https://github.com/boltdb/bolt/issues/284
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">db</span><span class="p">.</span><span class="nx">NoGrowSync</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">db</span><span class="p">.</span><span class="nx">readOnly</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">GOOS</span> <span class="o">!=</span> <span class="s">&#34;windows&#34;</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">file</span><span class="p">.</span><span class="nf">Truncate</span><span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="nx">sz</span><span class="p">));</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;file resize error: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">file</span><span class="p">.</span><span class="nf">Sync</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;file sync error: %s&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">db</span><span class="p">.</span><span class="nx">filesz</span> <span class="p">=</span> <span class="nx">sz</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

</code></pre></div><p><code>grow</code>方法会判断传入的所需文件大小，如果不需要增长底层文件大小则直接返回。同时，<code>grow</code>方法会检查当前mmap大小是否超过了门限<code>AllocSize</code>，在mmap大小达到该门限之前<code>grow</code>方法会按需增长数据库文件大小，在达到该门限后每次让数据库文件增大<code>AllocSize</code>。随后，<code>grow</code>方法会根据配置与系统来增长底层文件大小。其中需要注意两点：Windows支持mmap时自动扩展文件大小，而Linux不支持；ext3/ext4文件系统需要通过<code>fsync</code>方法强制同步元数据。这里笔者给出与<code>grow</code>相关的几个主要记录，以便读者参考：<a href="https://github.com/boltdb/bolt/issues/284" target="_blank" rel="noopener noreffer">issue#284</a>、<a href="https://github.com/boltdb/bolt/pull/286" target="_blank" rel="noopener noreffer">pull#286</a>、<a href="https://github.com/boltdb/bolt/pull/453" target="_blank" rel="noopener noreffer">pull#453</a>。</p>
<h5 id="2223-writewritemeta">2.2.2.3 write、writeMeta</h5>
<p><code>Tx</code>的<code>write</code>方法是将脏页写入到底层数据库文件的方法，其通过pwrite与fdatasync系统调用保证数据安全地写入磁盘。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// write writes any dirty pages to disk.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="nf">write</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c1">// Sort pages by id.
</span><span class="c1"></span>	<span class="nx">pages</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="nx">pages</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">pages</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">pages</span> <span class="p">{</span>
		<span class="nx">pages</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">pages</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// Clear out page cache early.
</span><span class="c1"></span>	<span class="nx">tx</span><span class="p">.</span><span class="nx">pages</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">pgid</span><span class="p">]</span><span class="o">*</span><span class="nx">page</span><span class="p">)</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nf">Sort</span><span class="p">(</span><span class="nx">pages</span><span class="p">)</span>

	<span class="c1">// Write pages to disk in order.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pages</span> <span class="p">{</span>
		<span class="nx">size</span> <span class="o">:=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">overflow</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">pageSize</span>
		<span class="nx">offset</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span> <span class="o">*</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">pageSize</span><span class="p">)</span>

		<span class="c1">// Write out page in &#34;max allocation&#34; sized chunks.
</span><span class="c1"></span>		<span class="nx">ptr</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nx">maxAllocSize</span><span class="p">]</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">p</span><span class="p">))</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="c1">// Limit our write to our max allocation size.
</span><span class="c1"></span>			<span class="nx">sz</span> <span class="o">:=</span> <span class="nx">size</span>
			<span class="k">if</span> <span class="nx">sz</span> <span class="p">&gt;</span> <span class="nx">maxAllocSize</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
				<span class="nx">sz</span> <span class="p">=</span> <span class="nx">maxAllocSize</span> <span class="o">-</span> <span class="mi">1</span>
			<span class="p">}</span>

			<span class="c1">// Write chunk to disk.
</span><span class="c1"></span>			<span class="nx">buf</span> <span class="o">:=</span> <span class="nx">ptr</span><span class="p">[:</span><span class="nx">sz</span><span class="p">]</span>
			<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">ops</span><span class="p">.</span><span class="nf">writeAt</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">offset</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">err</span>
			<span class="p">}</span>

			<span class="c1">// Update statistics.
</span><span class="c1"></span>			<span class="nx">tx</span><span class="p">.</span><span class="nx">stats</span><span class="p">.</span><span class="nx">Write</span><span class="o">++</span>

			<span class="c1">// Exit inner for loop if we&#39;ve written all the chunks.
</span><span class="c1"></span>			<span class="nx">size</span> <span class="o">-=</span> <span class="nx">sz</span>
			<span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>

			<span class="c1">// Otherwise move offset forward and move pointer to next chunk.
</span><span class="c1"></span>			<span class="nx">offset</span> <span class="o">+=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">sz</span><span class="p">)</span>
			<span class="nx">ptr</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nx">maxAllocSize</span><span class="p">]</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ptr</span><span class="p">[</span><span class="nx">sz</span><span class="p">]))</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Ignore file sync if flag is set on DB.
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">NoSync</span> <span class="o">||</span> <span class="nx">IgnoreNoSync</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">fdatasync</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Put small pages back to page pool.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pages</span> <span class="p">{</span>
		<span class="c1">// Ignore page sizes over 1 page.
</span><span class="c1"></span>		<span class="c1">// These are allocated using make() instead of the page pool.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">overflow</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>

		<span class="nx">buf</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nx">maxAllocSize</span><span class="p">]</span><span class="kt">byte</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">p</span><span class="p">))[:</span><span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">pageSize</span><span class="p">]</span>

		<span class="c1">// See https://go.googlesource.com/go/+/f03c9202c43e0abb130669852082117ca50aa9b1
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">buf</span> <span class="p">{</span>
			<span class="nx">buf</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
		<span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">pagePool</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">buf</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

</code></pre></div><p>从源码可知，<code>write</code>方法会将<code>tx.pages</code>中记录的脏页，有序地写入到底层文件。其默认的写入方法为go的<code>os.File.WriteAt</code>方法，其内部通过pwrite系统调用实现，同时，每次写入大小不超过<code>maxAllocSize</code>。在写入后，如果数据库没有启用<code>NoSync</code>参数或<code>IgnoreNoSync</code>为真（该参数在OpenBSD系统上为真，原因详见该参数注释）时，会通过fdatasync系统调用确保数据安全地写入到磁盘。最后，该方法会把分配的单页大小的page buffer放回pagePool中（详见<a href="/posts/code-reading/boltdb-made-simple/1-storage-cache/#321-page-buffermemory-memory" rel="">《深入浅出boltdb —— 0x01 存储与缓存》3.2.1 page buffer（memory-&gt;memory）</a>）。</p>
<p>而对于用来更新元数据的<code>writeMeta</code>方法也是如此：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// writeMeta writes the meta to the disk.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="nf">writeMeta</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c1">// Create a temporary buffer for the meta page.
</span><span class="c1"></span>	<span class="nx">buf</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">pageSize</span><span class="p">)</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">pageInBuffer</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>

	<span class="c1">// Write the meta page to file.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">ops</span><span class="p">.</span><span class="nf">writeAt</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span><span class="o">*</span><span class="nb">int64</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">pageSize</span><span class="p">));</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">NoSync</span> <span class="o">||</span> <span class="nx">IgnoreNoSync</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">fdatasync</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Update statistics.
</span><span class="c1"></span>	<span class="nx">tx</span><span class="p">.</span><span class="nx">stats</span><span class="p">.</span><span class="nx">Write</span><span class="o">++</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// write writes the meta onto a page.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">meta</span><span class="p">)</span> <span class="nf">write</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">page</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">root</span><span class="p">.</span><span class="nx">root</span> <span class="o">&gt;=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">pgid</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;root bucket pgid (%d) above high water mark (%d)&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">root</span><span class="p">.</span><span class="nx">root</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">pgid</span><span class="p">))</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">m</span><span class="p">.</span><span class="nx">freelist</span> <span class="o">&gt;=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">pgid</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;freelist pgid (%d) above high water mark (%d)&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">freelist</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">pgid</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="c1">// Page id is either going to be 0 or 1 which we can determine by the transaction ID.
</span><span class="c1"></span>	<span class="nx">p</span><span class="p">.</span><span class="nx">id</span> <span class="p">=</span> <span class="nf">pgid</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">txid</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>
	<span class="nx">p</span><span class="p">.</span><span class="nx">flags</span> <span class="o">|=</span> <span class="nx">metaPageFlag</span>

	<span class="c1">// Calculate the checksum.
</span><span class="c1"></span>	<span class="nx">m</span><span class="p">.</span><span class="nx">checksum</span> <span class="p">=</span> <span class="nx">m</span><span class="p">.</span><span class="nf">sum64</span><span class="p">()</span>

	<span class="nx">m</span><span class="p">.</span><span class="nb">copy</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nf">meta</span><span class="p">())</span>
<span class="p">}</span>

<span class="c1">// copy copies one meta object to another.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">meta</span><span class="p">)</span> <span class="nb">copy</span><span class="p">(</span><span class="nx">dest</span> <span class="o">*</span><span class="nx">meta</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">*</span><span class="nx">dest</span> <span class="p">=</span> <span class="o">*</span><span class="nx">m</span>
<span class="p">}</span>

</code></pre></div><p><code>writeMeta</code>方法同样通过pwrite+fdatasync的方式确保元数据被安全地写入到磁盘。同时，该方法会根据当前事务的<code>txid</code>来交替写入meta page 0 或 1。这样，即使在数据库写入meta页时挂掉，其重启时可以根据meta页的校验和切换到另一个数据完整的meta页。这样做也不会引起提交的事务数据丢失，因为如果还没写完meta页，那么该事务不会被认为是已提交的；另外，由于boltdb写入page时是copy-on-write的，旧meta页中指向的相应的页也都是有效的。</p>
<h5 id="2224-check">2.2.2.4 Check</h5>
<p>如果数据库处于严格模式<code>StrictMode</code>，则在事务提交的第7步中将调用<code>Check</code>方法对数据库进行完整性检查。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// Check performs several consistency checks on the database for this transaction.
</span><span class="c1">// An error is returned if any inconsistency is found.
</span><span class="c1">//
</span><span class="c1">// It can be safely run concurrently on a writable transaction. However, this
</span><span class="c1">// incurs a high cost for large databases and databases with a lot of subbuckets
</span><span class="c1">// because of caching. This overhead can be removed if running on a read-only
</span><span class="c1">// transaction, however, it is not safe to execute other writer transactions at
</span><span class="c1">// the same time.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="nf">Check</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">error</span><span class="p">)</span>
	<span class="k">go</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">check</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ch</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="nf">check</span><span class="p">(</span><span class="nx">ch</span> <span class="kd">chan</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Check if any pages are double freed.
</span><span class="c1"></span>	<span class="nx">freed</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">pgid</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
	<span class="nx">all</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">pgid</span><span class="p">,</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">freelist</span><span class="p">.</span><span class="nf">count</span><span class="p">())</span>
	<span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">freelist</span><span class="p">.</span><span class="nf">copyall</span><span class="p">(</span><span class="nx">all</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">id</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">all</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">freed</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;page %d: already freed&#34;</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">freed</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="c1">// Track every reachable page.
</span><span class="c1"></span>	<span class="nx">reachable</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">pgid</span><span class="p">]</span><span class="o">*</span><span class="nx">page</span><span class="p">)</span>
	<span class="nx">reachable</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">page</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// meta0
</span><span class="c1"></span>	<span class="nx">reachable</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">page</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// meta1
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">page</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">freelist</span><span class="p">).</span><span class="nx">overflow</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">reachable</span><span class="p">[</span><span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">freelist</span><span class="o">+</span><span class="nf">pgid</span><span class="p">(</span><span class="nx">i</span><span class="p">)]</span> <span class="p">=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">page</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">freelist</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Recursively check buckets.
</span><span class="c1"></span>	<span class="nx">tx</span><span class="p">.</span><span class="nf">checkBucket</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">tx</span><span class="p">.</span><span class="nx">root</span><span class="p">,</span> <span class="nx">reachable</span><span class="p">,</span> <span class="nx">freed</span><span class="p">,</span> <span class="nx">ch</span><span class="p">)</span>

	<span class="c1">// Ensure all pages below high water mark are either reachable or freed.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nf">pgid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">pgid</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">_</span><span class="p">,</span> <span class="nx">isReachable</span> <span class="o">:=</span> <span class="nx">reachable</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">isReachable</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">freed</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;page %d: unreachable unfreed&#34;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Close the channel to signal completion.
</span><span class="c1"></span>	<span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="nf">checkBucket</span><span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">Bucket</span><span class="p">,</span> <span class="nx">reachable</span> <span class="kd">map</span><span class="p">[</span><span class="nx">pgid</span><span class="p">]</span><span class="o">*</span><span class="nx">page</span><span class="p">,</span> <span class="nx">freed</span> <span class="kd">map</span><span class="p">[</span><span class="nx">pgid</span><span class="p">]</span><span class="kt">bool</span><span class="p">,</span> <span class="nx">ch</span> <span class="kd">chan</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Ignore inline buckets.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">root</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// Check every page used by this bucket.
</span><span class="c1"></span>	<span class="nx">b</span><span class="p">.</span><span class="nx">tx</span><span class="p">.</span><span class="nf">forEachPage</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">page</span><span class="p">,</span> <span class="nx">_</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">id</span> <span class="p">&gt;</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">pgid</span> <span class="p">{</span>
			<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;page %d: out of bounds: %d&#34;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">id</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">pgid</span><span class="p">))</span>
		<span class="p">}</span>

		<span class="c1">// Ensure each page is only referenced once.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nf">pgid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nf">pgid</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">overflow</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="kd">var</span> <span class="nx">id</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">id</span> <span class="o">+</span> <span class="nx">i</span>
			<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">reachable</span><span class="p">[</span><span class="nx">id</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
				<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;page %d: multiple references&#34;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">id</span><span class="p">))</span>
			<span class="p">}</span>
			<span class="nx">reachable</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span> <span class="p">=</span> <span class="nx">p</span>
		<span class="p">}</span>

		<span class="c1">// We should only encounter un-freed leaf and branch pages.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">freed</span><span class="p">[</span><span class="nx">p</span><span class="p">.</span><span class="nx">id</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;page %d: reachable freed&#34;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">id</span><span class="p">))</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">branchPageFlag</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">flags</span><span class="o">&amp;</span><span class="nx">leafPageFlag</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;page %d: invalid type: %s&#34;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">id</span><span class="p">),</span> <span class="nx">p</span><span class="p">.</span><span class="nf">typ</span><span class="p">())</span>
		<span class="p">}</span>
	<span class="p">})</span>

	<span class="c1">// Check each bucket within this bucket.
</span><span class="c1"></span>	<span class="nx">_</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">ForEach</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">v</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">child</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Bucket</span><span class="p">(</span><span class="nx">k</span><span class="p">);</span> <span class="nx">child</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">tx</span><span class="p">.</span><span class="nf">checkBucket</span><span class="p">(</span><span class="nx">child</span><span class="p">,</span> <span class="nx">reachable</span><span class="p">,</span> <span class="nx">freed</span><span class="p">,</span> <span class="nx">ch</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">})</span>
<span class="p">}</span>

</code></pre></div><p><code>Check</code>方法的完整性检查是对数据库的页完整性的检查，其检查了两方面问题：</p>
<ol>
<li>是否存在页被二次释放的问题。</li>
<li>是否所有页都能索引到，即是否存在既无法直接访问，又无法通过B+Tree索引到，也不在freelist中。</li>
</ol>
<h4 id="223-事务回滚">2.2.3 事务回滚</h4>
<p>boltdb的用户可以通过<code>Rollback</code>手动回滚事务，该方法会检测事务是否为隐式事务，如果是隐式事务则会返回错误（boltdb在回滚隐式事务前会将其<code>managed</code>字段置为false以避免返回错误）。<code>Rollback</code>方法会调用<code>rollback</code>方法进入回滚逻辑。另外，在事务提交时，发生部分错误时会直接调用<code>rollback</code>方法回滚事务。</p>
<p><code>Rollback</code>方法与<code>rollback</code>方法的实现如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// Rollback closes the transaction and ignores all previous updates. Read-only
</span><span class="c1">// transactions must be rolled back and not committed.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="nf">Rollback</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nf">_assert</span><span class="p">(!</span><span class="nx">tx</span><span class="p">.</span><span class="nx">managed</span><span class="p">,</span> <span class="s">&#34;managed tx rollback not allowed&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ErrTxClosed</span>
	<span class="p">}</span>
	<span class="nx">tx</span><span class="p">.</span><span class="nf">rollback</span><span class="p">()</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="nf">rollback</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">writable</span> <span class="p">{</span>
		<span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">freelist</span><span class="p">.</span><span class="nf">rollback</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">txid</span><span class="p">)</span>
		<span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">freelist</span><span class="p">.</span><span class="nf">reload</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">page</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">meta</span><span class="p">().</span><span class="nx">freelist</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="nx">tx</span><span class="p">.</span><span class="nb">close</span><span class="p">()</span>
<span class="p">}</span>

</code></pre></div><p><code>rollback</code>中的逻辑非常简单，对于只读事务只需要调用<code>close</code>方法关闭事务即可；而对于读写事务，首先要通过<code>freelist</code>的<code>rollback</code>方法，删除当前事务的<code>penging</code>列表中记录的页，因为这些页会被复用而不需要释放。另外，其还需要调用<code>freelist</code>的<code>reload</code>方法，其目的是将当前事务分配的页重新加入到<code>freelist</code>中；否则，这些页会无法引用，导致完整性检查失败。</p>
<h4 id="224-事务关闭">2.2.4 事务关闭</h4>
<p>无论是事务提交还是事务关闭，最后都需要调用<code>close</code>方法关闭事务。<code>close</code>方法的实现如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="nb">close</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">db</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">writable</span> <span class="p">{</span>
		<span class="c1">// Grab freelist stats.
</span><span class="c1"></span>		<span class="c1">// ... ...
</span><span class="c1"></span>
		<span class="c1">// Remove transaction ref &amp; writer lock.
</span><span class="c1"></span>		<span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">rwtx</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">rwlock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

		<span class="c1">// Merge statistics.
</span><span class="c1"></span>		<span class="c1">// ... ...
</span><span class="c1"></span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">tx</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">removeTx</span><span class="p">(</span><span class="nx">tx</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Clear all references.
</span><span class="c1"></span>	<span class="nx">tx</span><span class="p">.</span><span class="nx">db</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">tx</span><span class="p">.</span><span class="nx">meta</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">tx</span><span class="p">.</span><span class="nx">root</span> <span class="p">=</span> <span class="nx">Bucket</span><span class="p">{</span><span class="nx">tx</span><span class="p">:</span> <span class="nx">tx</span><span class="p">}</span>
	<span class="nx">tx</span><span class="p">.</span><span class="nx">pages</span> <span class="p">=</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// removeTx removes a transaction from the database.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">removeTx</span><span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Release the read lock on the mmap.
</span><span class="c1"></span>	<span class="nx">db</span><span class="p">.</span><span class="nx">mmaplock</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>

	<span class="c1">// Use the meta lock to restrict access to the DB object.
</span><span class="c1"></span>	<span class="nx">db</span><span class="p">.</span><span class="nx">metalock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>

	<span class="c1">// Remove the transaction.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">t</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">db</span><span class="p">.</span><span class="nx">txs</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">t</span> <span class="o">==</span> <span class="nx">tx</span> <span class="p">{</span>
			<span class="nx">last</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">txs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
			<span class="nx">db</span><span class="p">.</span><span class="nx">txs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">txs</span><span class="p">[</span><span class="nx">last</span><span class="p">]</span>
			<span class="nx">db</span><span class="p">.</span><span class="nx">txs</span><span class="p">[</span><span class="nx">last</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="nx">db</span><span class="p">.</span><span class="nx">txs</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">txs</span><span class="p">[:</span><span class="nx">last</span><span class="p">]</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">txs</span><span class="p">)</span>

	<span class="c1">// Unlock the meta pages.
</span><span class="c1"></span>	<span class="nx">db</span><span class="p">.</span><span class="nx">metalock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="c1">// Merge statistics.
</span><span class="c1"></span>	<span class="c1">// ... ...
</span><span class="c1"></span><span class="p">}</span>

</code></pre></div><p><code>close</code>主要做事务的清理工作并更新统计量（这里将其省略）。对于读写事务，其解除的<code>DB</code>对象中<code>rwtx</code>字段对其的引用，同时释放了<code>rwlock</code>；对于只读事务，其调用了<code>removeTx</code>方法。<code>removeTx</code>方法首先释放了<code>mmaplock</code>的S锁，然后获取<code>metalock</code>保护对<code>DB</code>对象的访问（而不是保护<code>meta</code>对象），然后从<code>DB</code>的<code>txs</code>字段中删除对当前事务的引用，之后释放<code>metalock</code>并更新统计量。</p>
<h3 id="23-内置隐式事务">2.3 内置隐式事务</h3>
<p>boltdb除了为用户提供了<code>Begin</code>方法来显式地启动读写事务或只读事务，其还提供一些内置的封装好的隐式事务方法，如<code>Update</code>、<code>View</code>与<code>Batch</code>。当用户只需要操作数据库而不需要关心何时提交或回滚时，可以使用这些方法。</p>
<h4 id="231-隐式读写事务与隐式只读事务">2.3.1 隐式读写事务与隐式只读事务</h4>
<p><code>Update</code>与<code>View</code>分别是通过读写隐式事务与只读隐式事务操作数据库的方法。二者实现如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// Update executes a function within the context of a read-write managed transaction.
</span><span class="c1">// If no error is returned from the function then the transaction is committed.
</span><span class="c1">// If an error is returned then the entire transaction is rolled back.
</span><span class="c1">// Any error that is returned from the function or returned from the commit is
</span><span class="c1">// returned from the Update() method.
</span><span class="c1">//
</span><span class="c1">// Attempting to manually commit or rollback within the function will cause a panic.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">Update</span><span class="p">(</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">t</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Begin</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="c1">// Make sure the transaction rolls back in the event of a panic.
</span><span class="c1"></span>	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">db</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">t</span><span class="p">.</span><span class="nf">rollback</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="c1">// Mark as a managed tx so that the inner function cannot manually commit.
</span><span class="c1"></span>	<span class="nx">t</span><span class="p">.</span><span class="nx">managed</span> <span class="p">=</span> <span class="kc">true</span>

	<span class="c1">// If an error is returned from the function then rollback and return error.
</span><span class="c1"></span>	<span class="nx">err</span> <span class="p">=</span> <span class="nf">fn</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">managed</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">_</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Rollback</span><span class="p">()</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Commit</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// View executes a function within the context of a managed read-only transaction.
</span><span class="c1">// Any error that is returned from the function is returned from the View() method.
</span><span class="c1">//
</span><span class="c1">// Attempting to manually rollback within the function will cause a panic.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">View</span><span class="p">(</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">t</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Begin</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="c1">// Make sure the transaction rolls back in the event of a panic.
</span><span class="c1"></span>	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">db</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">t</span><span class="p">.</span><span class="nf">rollback</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="c1">// Mark as a managed tx so that the inner function cannot manually rollback.
</span><span class="c1"></span>	<span class="nx">t</span><span class="p">.</span><span class="nx">managed</span> <span class="p">=</span> <span class="kc">true</span>

	<span class="c1">// If an error is returned from the function then pass it through.
</span><span class="c1"></span>	<span class="nx">err</span> <span class="p">=</span> <span class="nf">fn</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
	<span class="nx">t</span><span class="p">.</span><span class="nx">managed</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">_</span> <span class="p">=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Rollback</span><span class="p">()</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Rollback</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

</code></pre></div><p><code>Update</code>与<code>View</code>的参数是一个用来操作事务的方法闭包。这两个方法首先创建一个读写事务或只读事务，在执行方法闭包前先将<code>managed</code>字段置为true，以阻止用户在传入的方法闭包中手动提交或回滚事务，在执行后在将<code>managed</code>字段置为false，以便boltdb提交或回滚事务。</p>
<h4 id="232-批处理隐式读写事务">2.3.2 批处理隐式读写事务</h4>
<p>每个<code>Update</code>操作都要等待磁盘I/O完成才能执行下一个<code>Update</code>操作，虽然这保证了事务特性，但是性能较差。boltdb还为用户提供了一个能够将并发的多个读写事务合并为一次事务的方法——<code>Batch</code>。虽然通过<code>Batch</code>能够减少并发读写事务等待磁盘I/O的开销，但是其对事务中的操作有一定要求：<code>Batch</code>中的事务可能被重试若干次（即使某个事务正常，也可能被重试，笔者会在后文分析其原因），因此这要求通过<code>Batch</code>执行的操作必须是幂等（idempotent）的，且只有调用者调用的<code>Batch</code>方法成功返回后，其变更才保证被永久写入到存储。boltdb中的<code>Batch</code>分批操作对用户使透明的，用户只需要像调用<code>Update</code>一样调用<code>Batch</code>，boltdb就会自动将其分批。</p>
<p><code>Batch</code>方法使用到了<code>batch</code>结构体：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="kd">type</span> <span class="nx">batch</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">db</span>    <span class="o">*</span><span class="nx">DB</span>
	<span class="nx">timer</span> <span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Timer</span>
	<span class="nx">start</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
	<span class="nx">calls</span> <span class="p">[]</span><span class="nx">call</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">call</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">fn</span>  <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="kt">error</span>
	<span class="nx">err</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">error</span>
<span class="p">}</span>

</code></pre></div><p><code>batch</code>结构体的<code>calls</code>字段记录了每批读写事务的方法闭包与错误返回信道。记录错误返回信道的作用是为了将每个事务的错误返回给相应地调用者。</p>
<p>数据库结构体<code>db</code>的实例的<code>batch</code>字段是指向当前正在等待积累的<code>batch</code>指针，当一批<code>batch</code>执行时，其会将该字段置为nil，下一次调用<code>Batch</code>时会创建新实例。</p>
<p><code>Batch</code>方法的实现如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// Batch calls fn as part of a batch. It behaves similar to Update,
</span><span class="c1">// except:
</span><span class="c1">//
</span><span class="c1">// 1. concurrent Batch calls can be combined into a single Bolt
</span><span class="c1">// transaction.
</span><span class="c1">//
</span><span class="c1">// 2. the function passed to Batch may be called multiple times,
</span><span class="c1">// regardless of whether it returns error or not.
</span><span class="c1">//
</span><span class="c1">// This means that Batch function side effects must be idempotent and
</span><span class="c1">// take permanent effect only after a successful return is seen in
</span><span class="c1">// caller.
</span><span class="c1">//
</span><span class="c1">// The maximum batch size and delay can be adjusted with DB.MaxBatchSize
</span><span class="c1">// and DB.MaxBatchDelay, respectively.
</span><span class="c1">//
</span><span class="c1">// Batch is only useful when there are multiple goroutines calling it.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">DB</span><span class="p">)</span> <span class="nf">Batch</span><span class="p">(</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">errCh</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">error</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

	<span class="nx">db</span><span class="p">.</span><span class="nx">batchMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">if</span> <span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">batch</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">batch</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">batch</span><span class="p">.</span><span class="nx">calls</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">MaxBatchSize</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// There is no existing batch, or the existing batch is full; start a new one.
</span><span class="c1"></span>		<span class="nx">db</span><span class="p">.</span><span class="nx">batch</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">batch</span><span class="p">{</span>
			<span class="nx">db</span><span class="p">:</span> <span class="nx">db</span><span class="p">,</span>
		<span class="p">}</span>
		<span class="nx">db</span><span class="p">.</span><span class="nx">batch</span><span class="p">.</span><span class="nx">timer</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">AfterFunc</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">MaxBatchDelay</span><span class="p">,</span> <span class="nx">db</span><span class="p">.</span><span class="nx">batch</span><span class="p">.</span><span class="nx">trigger</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">db</span><span class="p">.</span><span class="nx">batch</span><span class="p">.</span><span class="nx">calls</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">batch</span><span class="p">.</span><span class="nx">calls</span><span class="p">,</span> <span class="nx">call</span><span class="p">{</span><span class="nx">fn</span><span class="p">:</span> <span class="nx">fn</span><span class="p">,</span> <span class="nx">err</span><span class="p">:</span> <span class="nx">errCh</span><span class="p">})</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">batch</span><span class="p">.</span><span class="nx">calls</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">MaxBatchSize</span> <span class="p">{</span>
		<span class="c1">// wake up batch, it&#39;s ready to run
</span><span class="c1"></span>		<span class="k">go</span> <span class="nx">db</span><span class="p">.</span><span class="nx">batch</span><span class="p">.</span><span class="nf">trigger</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">db</span><span class="p">.</span><span class="nx">batchMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="nx">err</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">errCh</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">trySolo</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="p">=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Update</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">err</span>
<span class="p">}</span>

</code></pre></div><p>在<code>Batch</code>方法中，其通过互斥锁<code>batchMu</code>保护了对<code>db</code>实例的<code>batch</code>字段的访问。如果<code>batch</code>为空或者已满时，创建新的<code>batch</code>实例，并为其注册定时器；如果该存在<code>batch</code>，则将当前方法与为其创建的错误信道加入到<code>batch</code>对象的<code>calls</code>字段中；如果此时<code>batch</code>已满，则立即触发其运行。在将当前事务加入到<code>batch</code>的列表中后，<code>Batch</code>方法会等待当前事务的错误信道的信号；如果从该信道收到的是<code>trySolo</code>错误，则通过<code>Update</code>方法重试该事务，返回结果。</p>
<p>没有满的<code>batch</code>会在定时器超时时触发，其<code>start sync.Once</code>字段确保每个<code>batch</code>只会被触发一次。<code>batch</code>触发时运行的相关代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// trigger runs the batch if it hasn&#39;t already been run.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">batch</span><span class="p">)</span> <span class="nf">trigger</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">start</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">run</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// run performs the transactions in the batch and communicates results
</span><span class="c1">// back to DB.Batch.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">batch</span><span class="p">)</span> <span class="nf">run</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">batchMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
	<span class="c1">// Make sure no new work is added to this batch, but don&#39;t break
</span><span class="c1"></span>	<span class="c1">// other batches.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">b</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">batch</span> <span class="o">==</span> <span class="nx">b</span> <span class="p">{</span>
		<span class="nx">b</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">batch</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">b</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nx">batchMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

<span class="nx">retry</span><span class="p">:</span>
	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">calls</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">failIdx</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
		<span class="nx">err</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">db</span><span class="p">.</span><span class="nf">Update</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
			<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">b</span><span class="p">.</span><span class="nx">calls</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">safelyCall</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">tx</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">failIdx</span> <span class="p">=</span> <span class="nx">i</span>
					<span class="k">return</span> <span class="nx">err</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">})</span>

		<span class="k">if</span> <span class="nx">failIdx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// take the failing transaction out of the batch. it&#39;s
</span><span class="c1"></span>			<span class="c1">// safe to shorten b.calls here because db.batch no longer
</span><span class="c1"></span>			<span class="c1">// points to us, and we hold the mutex anyway.
</span><span class="c1"></span>			<span class="nx">c</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">calls</span><span class="p">[</span><span class="nx">failIdx</span><span class="p">]</span>
			<span class="nx">b</span><span class="p">.</span><span class="nx">calls</span><span class="p">[</span><span class="nx">failIdx</span><span class="p">],</span> <span class="nx">b</span><span class="p">.</span><span class="nx">calls</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nx">calls</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">calls</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nx">b</span><span class="p">.</span><span class="nx">calls</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">calls</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="c1">// tell the submitter re-run it solo, continue with the rest of the batch
</span><span class="c1"></span>			<span class="nx">c</span><span class="p">.</span><span class="nx">err</span> <span class="o">&lt;-</span> <span class="nx">trySolo</span>
			<span class="k">continue</span> <span class="nx">retry</span>
		<span class="p">}</span>

		<span class="c1">// pass success, or bolt internal errors, to all callers
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">b</span><span class="p">.</span><span class="nx">calls</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">err</span> <span class="o">&lt;-</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="k">break</span> <span class="nx">retry</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">safelyCall</span><span class="p">(</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="kt">error</span><span class="p">,</span> <span class="nx">tx</span> <span class="o">*</span><span class="nx">Tx</span><span class="p">)</span> <span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">p</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">p</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">err</span> <span class="p">=</span> <span class="nx">panicked</span><span class="p">{</span><span class="nx">p</span><span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}()</span>
	<span class="k">return</span> <span class="nf">fn</span><span class="p">(</span><span class="nx">tx</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// trySolo is a special sentinel error value used for signaling that a
</span><span class="c1">// transaction function should be re-run. It should never be seen by
</span><span class="c1">// callers.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">trySolo</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;batch function returned an error and should be re-run solo&#34;</span><span class="p">)</span>

</code></pre></div><p><code>run</code>方法的逻辑如下：</p>
<ol>
<li>首先将当前<code>db</code>实例的<code>batch</code>字段置为nil，以避免之后调用的<code>Batch</code>将事务加入到当前队列，同时不影响其它<code>batch</code>的操作。</li>
<li>随后，循环重试。每次循环进行如下操作：
<ol>
<li>在一次<code>Update</code>方法中，循环执行<code>calls</code>列表中的每个事务的方法闭包，直到有一个事务返回错误时停止</li>
<li>如果发生了错误，则将发生错误的事务从<code>batch</code>中剔除，并向其错误信道中发送<code>trySolo</code>错误，告知调用者自行重试一次该事务，然后从头开始重试列表中的事务（这也是<code>Batch</code>要求其操作幂等的原因）。</li>
<li>循环通过或<code>Update</code>方法执行时boltdb内部产生错误（如果事务返回错误其会被从<code>calls</code>列表中剔除并重试，这里的<code>err</code>如果非空则为boltdb本身的错误），将错误（或nil）返回给<code>calls</code>中所有调用者的错误信道，通知调用者其事务执行完成或错误，退出循环。</li>
</ol>
</li>
</ol>
<h2 id="3-总结">3. 总结</h2>
<p>本文介绍了事务的基本概念与boltdb中事务的相关实现。在boltdb的实现中，事务在各方各面都有体现，其ACID的实现也相辅相成。</p>
<p>关于boltdb的源码分析在这里也告一段落了，<code>db.go</code>中的重要代码已经在本系列各篇文章中分散地介绍过，这里也不再赘述。</p></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2021-02-05</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/boltdb/">boltdb</a>,&nbsp;<a href="/tags/b&#43;tree/">B&#43;Tree</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/code-reading/boltdb-made-simple/3-bucket-cursor/" class="prev" rel="prev" title="深入浅出boltdb —— 0x03 bucket &amp; cursor"><i class="fas fa-angle-left fa-fw"></i>深入浅出boltdb —— 0x03 bucket &amp; cursor</a>
            <a href="/posts/code-reading/leveldb-made-simple/0-introduction/" class="next" rel="next" title="深入浅出LevelDB —— 0x00 引言 [施工中]">深入浅出LevelDB —— 0x00 引言 [施工中]<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.68.3">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2019 - 2021</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="about" target="_blank">叉鸽</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/lightgallery/lightgallery.min.css"><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/katex/copy-tex.min.css"><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.stemmer.support.min.js"></script><script type="text/javascript" src="/lib/lunr/lunr.zh.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/twemoji/twemoji.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lightgallery.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-thumbnail.min.js"></script><script type="text/javascript" src="/lib/lightgallery/lg-zoom.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/typeit/typeit.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js"></script><script type="text/javascript" src="/lib/katex/auto-render.min.js"></script><script type="text/javascript" src="/lib/katex/copy-tex.min.js"></script><script type="text/javascript" src="/lib/katex/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10000},"comment":{},"data":{"id-1":"叉鸽 | MrCroxx","id-2":"叉鸽 | MrCroxx"},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"highlightTag":"em","lunrIndexURL":"/index.json","lunrLanguageCode":"zh","lunrSegmentitURL":"/lib/lunr/lunr.segmentit.js","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"lunr"},"twemoji":true,"typeit":{"cursorChar":null,"cursorSpeed":null,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":null,"speed":null}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
